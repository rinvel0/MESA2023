{:	root[C{:ppo:Parslet::Slice:@positiono:Parslet::Position:@string"‡`// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT


#ifndef _MICROCHIP_ETHERNET_PHY_API_PHY_H_
#define _MICROCHIP_ETHERNET_PHY_API_PHY_H_

#include <microchip/ethernet/phy/api.h>
#include <microchip/ethernet/hdr_start.h>  /**< ALL INCLUDE ABOVE THIS LINE */

/** \brief Forigen pointer. MEPA only passes this pointer around, application instanting
 *   MEPA must define this type. If no bus-addressing data is needed, a null
 *   pointer can be used. */

struct mepa_callout_ctx;

/**
 * \brief MMD management read function (IEEE 802.3 clause 45).
 *
 * \param ctx  [IN]   Pointer to a callout structure.
 * \param mmd  [IN]   MMD register.
 * \param addr [IN]   Register address.
 * \param value[OUT]  Pointer to a value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
typedef mepa_rc (*mepa_mmd_read_t)(struct mepa_callout_ctx           *ctx,
                                   const uint8_t                      mmd,
                                   const uint16_t                     addr,
                                   uint16_t                          *const value);



/**
 * \brief MMD management read increment function (IEEE 802.3 clause 45)
 *
 * \param ctx   [IN]  Pointer to a callout structure.
 * \param mmd   [IN]  MMD register.
 * \param addr  [IN]  Start register address (0-65535).
 * \param buf   [OUT] The register values (pointer provided by user).
 * \param count [IN]  Number of register reads (increment register reads).
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
typedef mepa_rc (*mepa_mmd_read_inc_t)(struct mepa_callout_ctx       *ctx,
                                       const uint8_t                  mmd,
                                       const uint16_t                 addr,
                                       uint16_t                       *const buf,
                                       uint8_t                        count);

/**
 * \brief MMD management write function (IEEE 802.3 clause 45).
 *
 * \param ctx   [IN]  Pointer to a callout structure
 * \param mmd   [IN]  MMD register.
 * \param addr  [IN]  Start register address (0-65535).
 * \param value [OUT] Pointer to a value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
typedef mepa_rc (*mepa_mmd_write_t)(struct mepa_callout_ctx          *ctx,
                                    const uint8_t                     mmd,
                                    const uint16_t                    addr,
                                    const uint16_t                    value);

/**
 * \brief MII management read function (IEEE 802.3 clause 22)
 *
 * \param ctx   [IN] Pointer to a callout structure
 * \param addr  [IN] Start register address (0-65535).
 * \param value [OUT]Pointer to a value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
typedef mepa_rc (*mepa_miim_read_t)(struct mepa_callout_ctx          *ctx,
                                    const uint8_t                     addr,
                                    uint16_t                         *const value);

/**
 * \brief MII management write function (IEEE 802.3 clause 22)
 *
 * \param ctx   [IN]   Pointer to a callout structure.
 * \param addr  [IN]   Start register address (0-65535).
 * \param value [OUT]  Pointer to a value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
typedef mepa_rc (*mepa_miim_write_t)(struct mepa_callout_ctx         *ctx,
                                     const uint8_t                    addr,
                                     const uint16_t                   value);


typedef void (*mepa_trace_func_t)(const mepa_trace_data_t *data, va_list args);
typedef void *(*mepa_mem_alloc_t)(struct mepa_callout_ctx *ctx, size_t size);
typedef void (*mepa_mem_free_t)(struct mepa_callout_ctx *ctx, void *ptr);

/** \brief MEPA trace function
 *   The MEPA trace function is a single global variable. Traces will only work
 *   when a function is assigned to 'MEPA_TRACE_FUNCTION'.
 *   It is not per-instance, as it can be essential to provide tracing capability
 *   while creating instances. */

extern mepa_trace_func_t MEPA_TRACE_FUNCTION;

/** \brief PHY synchronisation callbacks passed by application */
typedef void (*mepa_lock_func_t)(const mepa_lock_t *const lock);

/** \brief Address mode that is specific for mchp phy. */
typedef struct mepa_callout {
    mepa_mmd_read_t        mmd_read;
    mepa_mmd_read_inc_t    mmd_read_inc;
    mepa_mmd_write_t       mmd_write;
    mepa_miim_read_t       miim_read;
    mepa_miim_write_t      miim_write;

    mepa_lock_func_t       lock_enter;
    mepa_lock_func_t       lock_exit;

    mepa_mem_alloc_t       mem_alloc;
    mepa_mem_free_t        mem_free;
} mepa_callout_t;

struct vtss_state_s;
typedef struct vtss_state_s *vtss_inst_t;

typedef struct mepa_board_conf {
    uint32_t                 numeric_handle;

    // By default all PHYs in the VTSS library will use default instance located
    // in mepa/vtss/src/vtss.c (as a static variable).
    // This makes it easy for simple usage, but sometime it is desirable to
    // control what PHYs belong to what instance. This can be controlled using
    // the below attributes:
    // - If vtss_instance_create is set to 1, then a new instance is created and
    //   pointer to the instance is avialable in the vtss_instance_ptr field.
    // - If vtss_instance_use is set to 1, then the pointer from
    //   'vtss_instance_ptr' is used for the given MEPA device.
    uint32_t                 vtss_instance_create;
    uint32_t                 vtss_instance_use;
    vtss_inst_t              vtss_instance_ptr;
} mepa_board_conf_t;

/** \brief Create a new MEPA instance.
 *
 *   NOTE: 'callout' and 'callout_ctx' pointers must be considered as SHARED,
 *   meaning that they must remain valid until all MEPA instances are deleted.
 *   MEPA will use these poiner values in sub-sequence MEPA calls.
 *   The same instance of the callout should be used for all MEPA instances.
 *   Each PHY should have a unique callout_ctx which contains mdio address
 *   controllers etc. */

struct mepa_device *mepa_create(const mepa_callout_t    MEPA_SHARED_PTR *callout,
                                struct mepa_callout_ctx MEPA_SHARED_PTR *callout_ctx,
                                struct mepa_board_conf  *conf);

/**
 * \brief Clears up the data allocated in the probe function.
 *
 * \param dev [IN] Driver Instance.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_delete(struct mepa_device *dev);

/**
 * \brief Resets PHY.
 *
 * \param dev      [IN]    Driver instance.
 * \param rst_conf [IN]    Reset configurations.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_reset(struct mepa_device *dev,
                   const mepa_reset_param_t *rst_conf);

/**
 * \brief Get the current status of the PHY.
 *
 * \param dev    [IN]       Driver instance.
 * \param status [OUT]      Represents the status of the PHY.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n
 *   MEPA_RC_ERROR on error.
 **/
mepa_rc mepa_poll(struct mepa_device *dev,
                  mepa_status_t *status);

/**
 * \brief Set the configuration of the PHY.
 * \brief conf   [IN] PHY configuration.
 *
 * \param dev  [IN]   Driver Instance.
 * \param conf [IN]   PHY configuration.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n
 *   MEPA_RC_ERROR on error.
 **/
mepa_rc mepa_conf_set(struct mepa_device *dev,
                      const mepa_conf_t *conf);

/**
 * \brief Get the current interface configuraton of the PHY.
 *
 * \param dev  [IN]   Driver instance.
 * \param conf [OUT]   PHY configuration.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n                                                    **/
mepa_rc mepa_conf_get(struct mepa_device *dev,
                      mepa_conf_t *const conf);

/**
 * \brief   Set the PHY interface.
 *
 * \param   dev  [IN]     Driver instance.
 * \param   intf [IN]     The current interface configuration of PHY.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n
 *   MEPA_RC_ERROR on error.
 **/
mepa_rc mepa_if_set(struct mepa_device *dev,
                    mepa_port_interface_t intf);

/**
 * \brief Get the PHY interface based on speed.
 *
 * \param dev    [IN]  Driver instance.
 * \param speed  [IN]  The PHY interface based on speed.
 * \param intf   [OUT] The current interface configuration of PHY.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_if_get(struct mepa_device *dev,
                    mepa_port_speed_t speed,
                    mepa_port_interface_t *intf);

/**
 * \brief Sets the power mode.
 *
 * \param dev    [IN]  Driver instance.
 * \param power  [IN]  Power mode.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.
 **/
mepa_rc mepa_power_set(struct mepa_device *dev,
                       mepa_power_mode_t power);

/**
 * \brief Starts cable diag.
 *
 * \param dev  [IN]  Driver instance.
 * \param mode [IN]  Mode in which to start.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n
 *   MEPA_RC_ERROR on error.
 **/
mepa_rc mepa_cable_diag_start(struct mepa_device *dev,
                              int mode);


/**
 * \brief Gets result from cable diagnostics.
 *
 * \param  dev     [IN]  Driver instance.
 * \param  result  [OUT] Result from cable diagnostics.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n
 *   MEPA_RC_ERROR on error.
 **/
mepa_rc mepa_cable_diag_get(struct mepa_device *dev,
                            mepa_cable_diag_result_t *result);

/**
 * \brief Sets the media type in case the port is a dual media port with external phy.
 *
 *  \param dev           [IN]  Driver instance.
 *  \param phy_media_if  [IN]  Media type.
 *
 *  \return
 *     MEPA_RC_NOT_IMPLEMENTED when not supported.
 **/
mepa_rc mepa_media_set(struct mepa_device *dev,
                       mepa_media_interface_t phy_media_if);

/**
 * \brief Get the media type in case the port is a dual media port with external
 * phy.
 *
 *  \param dev           [IN]  Driver instance.
 *  \param phy_media_if  [OUT] Media type.
 *
 *  \return
 *     MEPA_RC_NOT_IMPLEMENTED when not supported.
 **/
mepa_rc mepa_media_get(struct mepa_device *dev,
                       mepa_media_interface_t *phy_media_if);

/**
 * \brief  Gets copper PHY auto-negotiation status.
 *
 * \param dev   [IN]   Driver instance.
 * \param  mode [OUT]  PHY 1G status.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.\n
 *   MEPA_RC_ERROR on error.
 **/
mepa_rc mepa_aneg_status_get(struct mepa_device *dev,
                             mepa_aneg_status_t *status);


/**
 * \brief  PHY register read access using clause22 format for debugging
 *         address : bits 0 - 4 : address within page
 *                        5 - 31: page number
 *
 * \param dev     [IN]   Driver instance.
 * \param address [IN]   Address.
 * \param value   [OUT]  Value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_clause22_read(struct mepa_device *dev,
                           uint32_t address,
                           uint16_t *const value);

/**
 * \brief  PHY register write access using clause22 format for debugging
 *  address : bits 0 - 4 : address within page
 *                 5 - 31: page number
 *
 * \param dev     [IN]  Driver instance.
 * \param address [IN]  Address.
 * \param value   [IN]  Value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_clause22_write(struct mepa_device *dev,
                            uint32_t address,
                            uint16_t value);

/**
 * \brief  PHY register read access using clause45 format for debugging
 *  address : bits 0  - 15 : address within page
 *                 16 - 31 : page number
 *
 *  \param dev     [IN]  Driver instance.
 *  \param address [IN]  Address.
 *  \param value   [OUT] Value.
 *
 *  \return
 *    MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *    MEPA_RC_OK on success.
 **/
mepa_rc mepa_clause45_read(struct mepa_device *dev,
                           uint32_t address,
                           uint16_t *const value);

/**
 * \brief  PHY register write access using clause45 format for debugging
 *  address : bits 0  - 15 : address within page
 *                 16 - 31 : page number
 *
 *  \param dev     [IN]  Driver instance.
 *  \param address [OUT] Adress.
 *  \param value   [IN]  Value.
 *
 *  \return
 *    MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *    MEPA_RC_OK on success.
 **/
mepa_rc mepa_clause45_write(struct mepa_device *dev,
                            uint32_t address,
                            uint16_t value);

/**
 * \brief  Enable PHY events.
 *
 * \param dev    [IN] Driver instance.
 * \param event  [IN] PHY event mask to be enabled.
 * \param enable [IN] Enable or disable the event.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_event_enable_set(struct mepa_device *dev,
                              mepa_event_t event,
                              mesa_bool_t enable);

/**
 * \brief  Get the PHY events currently enabled.
 *
 * \param dev    [IN] Driver instance.
 * \param event  [OUT] Event mask which is currently enabled in PHY.
 *
 * \return
 *    MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *    MEPA_RC_OK on success.
 **/
mepa_rc mepa_event_enable_get(struct mepa_device *dev,
                              mepa_event_t *const event);

/**
 * \brief Poll the status of PHY events.
 *
 * \param dev      [IN]  Driver instance.
 * \param  ev_mask [OUT] Event mask containing current status of PHY events.
 *
 * \return
 *    MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *    MEPA_RC_OK on success.
 **/
mepa_rc mepa_event_poll(struct mepa_device *dev,
                        mepa_event_t *const ev_mask);

/**
 * \brief Set loopback. Used for debugging purpose
 *
 * \param dev       [IN] Driver Instance.
 * \param loopback  [IN] Loopback Types.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_loopback_set(struct mepa_device *dev,
                          const mepa_loopback_t *loopback);

/**
 * \brief  Get current loopback configuration.
 *
 * \param dev       [IN]  Driver instance.
 * \param loopback  [OUT] Loopback Types.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_loopback_get(struct mepa_device *dev,
                          mepa_loopback_t *const loopback);

/**
 * \brief Set the GPIO pin mode to input, output or alternate function.
 *
 * \param dev  [IN]  Driver instance.
 * \param data [OUT] GPIO configuration.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_gpio_mode_set(struct mepa_device *dev,
                           const mepa_gpio_conf_t *data);

/**
 * \brief  Set the GPIO pin value.
 *
 * \param dev     [IN]  Driver instance.
 * \param gpio_no [IN]  GPIO Number.
 * \param value   [IN]  Value.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_gpio_out_set(struct mepa_device *dev,
                          uint8_t gpio_no,
                          mepa_bool_t value);

/**
 * \brief  Get the GPIO pin value.
 *
 * \param dev      [IN]  Driver Instance.
 * \param gpio_no  [IN]  GPIO Number.
 * \param value    [OUT]  Value.
 *
 * \return
 *    MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *    MEPA_RC_OK on success.
 **/
mepa_rc mepa_gpio_in_get(struct mepa_device *dev,
                         uint8_t gpio_no,
                         mepa_bool_t *const value);

/**
 * \brief Configure recovered clock
 *
 * \param dev  [IN] Driver instance.
 * \param conf [IN] Synce recovered clock configuration.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_synce_clock_conf_set(struct mepa_device *dev,
                                  const mepa_synce_clock_conf_t *conf);

/**
 * \brief  Link Base Port. Used for accessing the chip leavel common resources.
 *
 * \param dev         [IN] Driver instance.
 * \param base_dev    [IN] Base port driver instance.
 * \param packet_idx  [IN] Link status.
 *
 * \return
 *  MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *  MEPA_RC_OK on success.
 **/
mepa_rc mepa_link_base_port(struct mepa_device *dev,
                            struct mepa_device *base_dev,
                            uint8_t packet_idx);

/**
 * \brief Get phy information like phy-id, revision etc.
 *
 * \param dev       [IN]   Driver instance.
 * \param phy_info  [OUT]  Phy information.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_phy_info_get(struct mepa_device *dev,
                          mepa_phy_info_t *const phy_info);

/**
 * \brief  Isolation mode as defined by IEEE 802.3-2012 section 22.2.4.1.6
 *
 * \param dev     [IN]    Driver instance.
 * \param iso_en  [OUT]   Enable /disable isolation mode.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_isolate_mode_conf(struct mepa_device *dev,
                               const mepa_bool_t iso_en);

/**
 * \brief  Debug dump API for PHY.
 *
 * \param dev  [IN]   Driver instance.
 * \param pr   [IN]   Debug printf function.
 * \param info [OUT]  Debug information.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_debug_info_dump(struct mepa_device *dev,
                             const mepa_debug_print_t pr,
                             const mepa_debug_info_t   *const info);

/** - I2C ---------------------------------------------------- */
/**
 * \brief I2C Read - perform i2C I/O thru PHY for Reading SFP using i2C i/f
 *
 * \param dev  [IN]            Driver instance.
 * \param i2c_mux [IN]         The i2c clock mux
 * \param i2c_reg_addr [IN]    The i2c register address to access.
 * \param i2c_device_addr [IN] The i2c address of the device to access.
 * \param value [OUT]          Pointer to where array which in going to contain the values read.
 * \param cnt [IN]             The number of registers to read.
 *                             Note: The reg_addr is incremented by 1 for each of the read counts. If you want to read 16 bites registers
 *                             (2 times 8 bits from the same register address), you need to do that by calling the vtss_phy_i2c_read twice,
 *                             and not use the cnt (set cnt to 1).
 * \param word_access [IN]     Set to TRUE if the register data width is 16bit. FALSE = 8 bits data width
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_ERROR on Error \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_i2c_read(mepa_device_t *dev,
                        const uint8_t i2c_mux,
                        const uint8_t i2c_reg_addr,
                        const uint8_t i2c_dev_addr,
                        uint8_t *const value,
                        uint8_t cnt,
                        const mepa_bool_t word_access);

/**
 *
 * \brief I2C Write - perform i2C I/O thru PHY for Writing to the SFP using i2C i/f
 *
 * \param dev  [IN]            Driver instance.
 * \param i2c_mux [IN]         The i2c clock mux
 * \param i2c_reg_addr [IN]    The i2c register address to access.
 * \param i2c_device_addr [IN] The i2c address of the device to access.
 * \param value [IN]           Pointer to where array containing the values to write.
 * \param cnt [IN]             The number of registers to write.
 *                             Note: The reg_addr is incremented by 1 for each of the write counts. If you want to write 16 bites registers
 *                             (2 times 8 bits to the same register address), you need to do that by calling the vtss_phy_i2c_write twice,
 *                             and not use the cnt (set cnt to 1).
 * \param word_access [IN]     Set to TRUE if the register data width is 16bit. FALSE = 8 bits data width
 *
 * \return Return code.
 *   MEPA_RC_NOT_IMPLEMENTED when not supported.\n
 *   MEPA_RC_ERROR on Error \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_i2c_write(mepa_device_t *dev,
                        const uint8_t i2c_mux,
                        const uint8_t i2c_reg_addr,
                        const uint8_t i2c_dev_addr,
                        uint8_t *value,
                        uint8_t cnt,
                        const mepa_bool_t word_access);


/**
 * \brief PHY get SQI value
 *
 * \param dev   [IN]   Driver instance.
 * \param value [OUT]   SQI value to return
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_sqi_read(struct mepa_device *dev, uint32_t *const value);

/**
 * \brief PHY write SOF value
 *
 * \param dev   [IN]   Driver instance.
 * \param conf [IN]   SOF value to be Configured
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_start_of_frame_conf_set(struct mepa_device *dev, mepa_start_of_frame_conf_t *const conf);

/**
 * \brief PHY get SOF value
 *
 * \param dev   [IN]   Driver instance.
 * \param value [OUT]   SOF value to return
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_start_of_frame_conf_get(struct mepa_device *dev, mepa_start_of_frame_conf_t *const value);

/**
 * \brief PHY get Frame Preemption
 *
 * \param dev   [IN]   Driver instance.
 * \param value [OUT]  Frame Preemption value to return
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_framepreempt_get(struct mepa_device *dev, mepa_bool_t *const value);

/**
 * \brief Start PHY Self-Test Frame
 *
 * \param dev     [IN]  Driver instance.
 * \param inf     [IN]  selftest information
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_selftest_start(struct mepa_device *dev, const mepa_selftest_info_t *inf);

/**
 * \brief Read PHY Self-Test Checking counters
 *
 * \param dev     [IN]  Driver instance.
 * \param inf     [OUT] selftest information
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_selftest_read(struct mepa_device *dev, mepa_selftest_info_t *const selftest_inf);

/**
 * \brief To Set the PRBS7 sequence configuration
 *
 * \param dev      [IN]  Driver instance.
 * \param conf     [IN] PRBS7 information.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_prbs_set(struct mepa_device *dev, mepa_phy_prbs_type_t type, mepa_phy_prbs_direction_t direction, mepa_phy_prbs_generator_conf_t *const mepa_conf);

/**
 * \brief To Get the PRBS7 sequence configuration
 *
 * \param dev      [IN]  Driver instance.
 * \param conf     [OUT] PRBS7 information.
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_prbs_get(struct mepa_device *dev, mepa_phy_prbs_type_t type, mepa_phy_prbs_direction_t direction, mepa_phy_prbs_generator_conf_t *const mepa_conf);

/**
 * \brief To inject an error
 *
 * \param dev       [IN]  Driver instance.
 * \param value     [IN] Error count information
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_prbs_monitor_set(struct mepa_device *dev, mepa_phy_prbs_monitor_conf_t *const value);

/**
 * \brief To Verify the PRBS7
 *
 * \param dev       [IN]  Driver instance.
 * \param value     [OUT] Error count information
 *
 * \return
 *   MEPA_RC_NOT_IMPLEMENTED when not supported. \n
 *   MEPA_RC_OK on success.
 **/
mepa_rc mepa_prbs_monitor_get(struct mepa_device *dev, mepa_phy_prbs_monitor_conf_t *const value);

#include <microchip/ethernet/hdr_end.h>
#endif
:@byteposir:	@str"0#ifndef _MICROCHIP_ETHERNET_PHY_API_PHY_H_
:@line_cacheo:Parslet::Source::LineCache:@line_endse:!Parslet::Source::RangeSearch[ˇiPipiqiriòi√iƒiÏi;i<iïi‚iˇi iiii]i`iñi∫i‚iiiiMiiiniπiiPi§i•i¶ißi´iÛiˆi,iPiàiŒiii'iZivi{i∆ii]iØi˝i˛iiBiEiziûi÷i 	i	i	iA	i]	ib	i≠	i¯	iD
ií
iì
ió
i’
iÿ
iiCilioizi≠i…iŒiieiπi∫iæi˝i i7ipiõiûi©i‹i¯i˝iHiîi‚i„i‰i4iÇiÃiÕiÏi<iwi…iÎiÏiii]iûiüiŸi˜iiEikiëi∏iπi‡iii-iRidieizi§i•i∆iÛiÙiEi|i»ii4iÖi”iiTiái∑iÁi¸i˝i$i'iuiƒiiTiüi∏iπiiai°i¢i¶i‰iÁiiiiLihimiõiúi†i∂iπiÂiii$iWisixi§i‹i›i·iii>i|iiäiΩi€i¯i˝i(iRiSiWiÉi¨iØi÷iˇiii@i^i{iÄiØiﬂi‡i‰i!i$iKiuixiÉi∂i i: ij ik io ií iï i¿ i!i	!i!iG!ie!iÇ!iá!i¥!iÂ!iÊ!iÍ!i"i"iE"i~"i¡"iƒ"iœ"i#i#i##iP#i}#iØ#i∞#i¥#i”#i÷#i˛#i!$i$$i/$i`$ie$iï$i∆$i«$iÀ$iË$iÎ$i%i>%iA%iL%i%iù%i∫%iø%iˆ%i&i &i!&i%&iS&iV&iÄ&i∏&iª&i∆&i˘&i'i4'i9'in'i≠'iÆ'i≤'i	(i(i<(ig(ij(iv(i©(iÆ(iﬁ(i)i)i )iq)iy)i|)i¨)i◊)i⁄)iÊ)i*i*iN*iå*iç*ië*i≈*i»*i*i+i+i$+iW+iu+ií+ió+iÕ+i,i,i	,i,iU,iã,iπ,iº,iÊ,i-i(-i+-i6-ii-iÖ-iä-iæ-iÎ-i.i.i#.il.iõ.i¬.i≈.iÓ.i/i./i1/i</io/iã/iê/i≈/iÛ/i 0i!0i%0im0iû0i«0i 0iÙ0i1i61i91iE1iy1iñ1iõ1iœ1i¸1i/2i02i42i}2iÆ2i◊2i⁄2i3i%3iE3iH3iT3ià3i•3i™3iﬂ3i4i:4i;4i?4i]4i`4iá4iª4iÓ4iÒ4i¸4i/5iK5iP5iá5iπ5iÏ5iÌ5iÒ5i"6i%6iL6ië6iî6iü6i”6i6iı6i,7if7ig7ik7iî7ió7i¡7i8i8i8iP8im8ir8i£8iŸ8i⁄8iﬁ8i9i9i>9ig9ij9iu9i¶9iŸ9iı9i˙9i-:ii:ij:in:iù:i†:iÀ:iı:i¯:i;i6;iR;iW;iä;i∆;i«;iÀ;i<i<i<<ie<ih<is<i¶<i¬<i«<i˚<i5=i6=i:=i]=i`=iâ=iÆ=iÕ=i–=i€=i>i*>i/>ib>iç>iª>iº>i¿>i„>iÊ>i?i6?iW?iZ?ie?iô?i∂?iª?iÌ?i@iK@iL@iP@it@iw@iú@i’@iÿ@i„@iAi2Ai7AirAi∫AiªAiøAiBiBi>BitBiúBiüBi™Bi‹Bi˜Bi¸Bi1CikCiúCiùCi°Ci⁄Ci›Ci	Di5Di8DiCDivDiíDióDi DiEiEiEiVEiYEiÑEiæEi¡EiÃEiˇEiFi FiXFiíFiìFióFi∫FiΩFi‰FiGi:Gi=GiHGi{GióGiúGi“GiHiQHiRHiîHiòHi‰HiÁHiIiHIiãIi”Ii4JitJi˛JiäKiÕKi7Li:LiELixLióLi≥Li∏Li‚LiMiEMiyMißMiÃMiNiNi	NiNi`NicNiìNiƒNiOiOOi•OiÊOirPi˝Pi@Qi™Qi≠Qi≈Qi¯QiRi3Ri8RicRiíRi∆Ri˙Ri"SiGSiSiÄSiÅSiÖSi°Si§SiÃSi¯Si˚SiTi:TiVTi[Ti¢Ti£TißTi≈Ti»TiTi!Ui$Ui/UicUiUiÑUiÎUiÏUiUiViVi7VicVifViqVi•Vi¡Vi∆Vi.Wi/Wi3WiVWiYWiÅWiπWiºWi«Wi˚WiXiXinXioXisXióXiöXi√XiXiÛXi˛Xi2YiNYiSYi™Yi´YiØYiﬁYi·Yi
Zi7Zi:ZiEZiyZiïZiöZi˘Zi˙Zi˛Zi0[i3[i][ià[iã[iñ[i [iÊ[iÎ[iå\iç\ië\i√\i∆\i\i]i]i*]i^]iz]i]i ^i!^i%^iB^iE^ip^i°^i§^iØ^i„^iˇ^i_ig_ih_il_iä_iç_i∏_iÍ_iÌ_i¯_i,`iH`iM`i∞`i±`iŸ`i‡`:@last_line_endi‡`{;o;;o;	;
@
;iò;"1#define _MICROCHIP_ETHERNET_PHY_API_PHY_H_

;@{;o;;o;	;
@
;iƒ;"-#include <microchip/ethernet/phy/api.h>
;@{;o;;o;	;
@
;iÏ;"U#include <microchip/ethernet/hdr_start.h>  /**< ALL INCLUDE ABOVE THIS LINE */

;@{:keywordo;;o;	;
@
;in;"typedef;@:typedef_fptr{	:return_typeo;;o;	;
@
;iv;"mepa_rc ;@:fptr_nameo;;o;	;
@
;iÄ;"mepa_mmd_read_t;@:	args[	{:normal{	:	typeo;;o;	;
@
;ië;"(struct mepa_callout_ctx           *;@:	nameo;;o;	;
@
;i¥;"ctx;@:
array[ :cap0{;{	;o;;o;	;
@
;i‹;"(const uint8_t                      ;@;o;;o;	;
@
;iˇ;"mmd;@;[ ;0{;{	;o;;o;	;
@
;i';"(const uint16_t                     ;@;o;;o;	;
@
;iJ;"	addr;@;[ ;0{;{	;o;;o;	;
@
;is;".uint16_t                          *const ;@;o;;o;	;
@
;iú;"
value;@;[ ;0;0{;o;;o;	;
@
;i{;"typedef;@;{	;o;;o;	;
@
;iÉ;"mepa_rc ;@;o;;o;	;
@
;iç;"mepa_mmd_read_inc_t;@;[
{;{	;o;;o;	;
@
;i¢;"$struct mepa_callout_ctx       *;@;o;;o;	;
@
;i¡;"ctx;@;[ ;0{;{	;o;;o;	;
@
;iÌ;"$const uint8_t                  ;@;o;;o;	;
@
;i;"mmd;@;[ ;0{;{	;o;;o;	;
@
;i8;"$const uint16_t                 ;@;o;;o;	;
@
;iW;"	addr;@;[ ;0{;{	;o;;o;	;
@
;iÑ;"+uint16_t                       *const ;@;o;;o;	;
@
;i™;"buf;@;[ ;0{;{	;o;;o;	;
@
;i÷;"$uint8_t                        ;@;o;;o;	;
@
;iı;"
count;@;[ ;0;0{;o;;o;	;
@
;ib	;"typedef;@;{	;o;;o;	;
@
;ij	;"mepa_rc ;@;o;;o;	;
@
;it	;"mepa_mmd_write_t;@;[	{;{	;o;;o;	;
@
;iÜ	;"'struct mepa_callout_ctx          *;@;o;;o;	;
@
;i®	;"ctx;@;[ ;0{;{	;o;;o;	;
@
;i—	;"'const uint8_t                     ;@;o;;o;	;
@
;iÛ	;"mmd;@;[ ;0{;{	;o;;o;	;
@
;i
;"'const uint16_t                    ;@;o;;o;	;
@
;i>
;"	addr;@;[ ;0{;{	;o;;o;	;
@
;ih
;"'const uint16_t                    ;@;o;;o;	;
@
;iä
;"
value;@;[ ;0;0{;o;;o;	;
@
;iŒ;"typedef;@;{	;o;;o;	;
@
;i÷;"mepa_rc ;@;o;;o;	;
@
;i‡;"mepa_miim_read_t;@;[{;{	;o;;o;	;
@
;iÚ;"'struct mepa_callout_ctx          *;@;o;;o;	;
@
;i;"ctx;@;[ ;0{;{	;o;;o;	;
@
;i=;"'const uint8_t                     ;@;o;;o;	;
@
;i_;"	addr;@;[ ;0{;{	;o;;o;	;
@
;iâ;"-uint16_t                         *const ;@;o;;o;	;
@
;i±;"
value;@;[ ;0;0{;o;;o;	;
@
;i˝;"typedef;@;{	;o;;o;	;
@
;i;"mepa_rc ;@;o;;o;	;
@
;i;"mepa_miim_write_t;@;[{;{	;o;;o;	;
@
;i";"&struct mepa_callout_ctx         *;@;o;;o;	;
@
;iC;"ctx;@;[ ;0{;{	;o;;o;	;
@
;im;"&const uint8_t                    ;@;o;;o;	;
@
;ié;"	addr;@;[ ;0{;{	;o;;o;	;
@
;iπ;"&const uint16_t                   ;@;o;;o;	;
@
;i⁄;"
value;@;[ ;0;0{;o;;o;	;
@
;i‰;"typedef;@;{	;o;;o;	;
@
;iÏ;"
void ;@;o;;o;	;
@
;iÛ;"mepa_trace_func_t;@;[{;{	;o;;o;	;
@
;i;"const mepa_trace_data_t *;@;o;;o;	;
@
;i;"	data;@;[ ;0{;{	;o;;o;	;
@
;i%;"va_list ;@;o;;o;	;
@
;i-;"	args;@;[ ;0;0{;o;;o;	;
@
;i4;"typedef;@;{	;o;;o;	;
@
;i<;"void *;@;o;;o;	;
@
;iD;"mepa_mem_alloc_t;@;[{;{	;o;;o;	;
@
;iV;"struct mepa_callout_ctx *;@;o;;o;	;
@
;io;"ctx;@;[ ;0{;{	;o;;o;	;
@
;it;"size_t ;@;o;;o;	;
@
;i{;"	size;@;[ ;0;0{;o;;o;	;
@
;iÇ;"typedef;@;{	;o;;o;	;
@
;iä;"
void ;@;o;;o;	;
@
;ië;"mepa_mem_free_t;@;[{;{	;o;;o;	;
@
;i¢;"struct mepa_callout_ctx *;@;o;;o;	;
@
;iª;"ctx;@;[ ;0{;{	;o;;o;	;
@
;i¿;"void *;@;o;;o;	;
@
;i∆;"ptr;@;[ ;0;0{;o;;o;	;
@
;iÏ;"extern;@;{	;o;;o;	;
@
;iÛ;"mepa_trace_func_t ;@;o;;o;	;
@
;i;"MEPA_TRACE_FUNCTION;@;[ ;0{;o;;o;	;
@
;i];"typedef;@;{	;o;;o;	;
@
;ie;"
void ;@;o;;o;	;
@
;il;"mepa_lock_func_t;@;[{;{	;o;;o;	;
@
;i~;"const mepa_lock_t *const ;@;o;;o;	;
@
;ió;"	lock;@;[ ;0;0{
;o;;o;	;
@
;iŸ;"typedef;@:struct_type_declare{:struct_members[{:member{;{	;o;;o;	;
@
;i˚;"mepa_mmd_read_t        ;@;o;;o;	;
@
;i;"mmd_read;@;[ ;0{;{;{	;o;;o;	;
@
;i ;"mepa_mmd_read_inc_t    ;@;o;;o;	;
@
;i7;"mmd_read_inc;@;[ ;0{;{;{	;o;;o;	;
@
;iI;"mepa_mmd_write_t       ;@;o;;o;	;
@
;i`;"mmd_write;@;[ ;0{;{;{	;o;;o;	;
@
;io;"mepa_miim_read_t       ;@;o;;o;	;
@
;iÜ;"miim_read;@;[ ;0{;{;{	;o;;o;	;
@
;iï;"mepa_miim_write_t      ;@;o;;o;	;
@
;i¨;"miim_write;@;[ ;0{;{;{	;o;;o;	;
@
;iΩ;"mepa_lock_func_t       ;@;o;;o;	;
@
;i‘;"lock_enter;@;[ ;0{;{;{	;o;;o;	;
@
;i‰;"mepa_lock_func_t       ;@;o;;o;	;
@
;i˚;"lock_exit;@;[ ;0{;{;{	;o;;o;	;
@
;i;"mepa_mem_alloc_t       ;@;o;;o;	;
@
;i";"mem_alloc;@;[ ;0{;{;{	;o;;o;	;
@
;i1;"mepa_mem_free_t        ;@;o;;o;	;
@
;iH;"mem_free;@;[ ;0:typedef_nameo;;o;	;
@
;iT;"mepa_callout_t;@;[ ;0{
;o;;o;	;
@
;iz;"typedef;@:type_aliaso;;o;	;
@
;iÇ;"struct vtss_state_s *;@;o;;o;	;
@
;ió;"vtss_inst_t;@;[ ;0{
;o;;o;	;
@
;i•;"typedef;@;{;[	{;{;{	;o;;o;	;
@
;i ;"uint32_t                 ;@;o;;o;	;
@
;i„;"numeric_handle;@;[ ;0{;{;{	;o;;o;	;
@
;iX;"uint32_t                 ;@;o;;o;	;
@
;iq;"vtss_instance_create;@;[ ;0{;{;{	;o;;o;	;
@
;iã;"uint32_t                 ;@;o;;o;	;
@
;i§;"vtss_instance_use;@;[ ;0{;{;{	;o;;o;	;
@
;iª;"vtss_inst_t              ;@;o;;o;	;
@
;i‘;"vtss_instance_ptr;@;[ ;0;o;;o;	;
@
;iÈ;"mepa_board_conf_t;@;[ ;0{:func_proto{;{	;o;;o;	;
@
;iπ;"struct mepa_device *;@;o;;o;	;
@
;iÕ;"mepa_create;@;[ ;0;[{;{	;o;;o;	;
@
;iŸ;".const mepa_callout_t    MEPA_SHARED_PTR *;@;o;;o;	;
@
;i;"callout;@;[ ;0{;{	;o;;o;	;
@
;i+;".struct mepa_callout_ctx MEPA_SHARED_PTR *;@;o;;o;	;
@
;iT;"callout_ctx;@;[ ;0{;{	;o;;o;	;
@
;iÅ;"struct mepa_board_conf  *;@;o;;o;	;
@
;iö;"	conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;im;"mepa_rc ;@;o;;o;	;
@
;iu;"mepa_delete;@;[ ;0;[{;{	;o;;o;	;
@
;iÅ;"struct mepa_device *;@;o;;o;	;
@
;iï;"dev;@;[ ;0;0{;!{;{	;o;;o;	;
@
;ix;"mepa_rc ;@;o;;o;	;
@
;iÄ;"mepa_reset;@;[ ;0;[{;{	;o;;o;	;
@
;iã;"struct mepa_device *;@;o;;o;	;
@
;iü;"dev;@;[ ;0{;{	;o;;o;	;
@
;i∑;"const mepa_reset_param_t *;@;o;;o;	;
@
;i—;"rst_conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i˝;"mepa_rc ;@;o;;o;	;
@
;i;"mepa_poll;@;[ ;0;[{;{	;o;;o;	;
@
;i;"struct mepa_device *;@;o;;o;	;
@
;i#;"dev;@;[ ;0{;{	;o;;o;	;
@
;i:;"mepa_status_t *;@;o;;o;	;
@
;iI;"status;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iÄ;"mepa_rc ;@;o;;o;	;
@
;ià;"mepa_conf_set;@;[ ;0;[{;{	;o;;o;	;
@
;iñ;"struct mepa_device *;@;o;;o;	;
@
;i™;"dev;@;[ ;0{;{	;o;;o;	;
@
;i≈;"const mepa_conf_t *;@;o;;o;	;
@
;iÿ;"	conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i ;"mepa_rc ;@;o;;o;	;
@
;i ;"mepa_conf_get;@;[ ;0;[{;{	;o;;o;	;
@
;i! ;"struct mepa_device *;@;o;;o;	;
@
;i5 ;"dev;@;[ ;0{;{	;o;;o;	;
@
;iP ;"mepa_conf_t *const ;@;o;;o;	;
@
;ic ;"	conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iá!;"mepa_rc ;@;o;;o;	;
@
;iè!;"mepa_if_set;@;[ ;0;[{;{	;o;;o;	;
@
;iõ!;"struct mepa_device *;@;o;;o;	;
@
;iØ!;"dev;@;[ ;0{;{	;o;;o;	;
@
;i»!;"mepa_port_interface_t ;@;o;;o;	;
@
;iﬁ!;"	intf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i##;"mepa_rc ;@;o;;o;	;
@
;i+#;"mepa_if_get;@;[ ;0;[{;{	;o;;o;	;
@
;i7#;"struct mepa_device *;@;o;;o;	;
@
;iK#;"dev;@;[ ;0{;{	;o;;o;	;
@
;id#;"mepa_port_speed_t ;@;o;;o;	;
@
;iv#;"
speed;@;[ ;0{;{	;o;;o;	;
@
;ië#;"mepa_port_interface_t *;@;o;;o;	;
@
;i®#;"	intf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;ie$;"mepa_rc ;@;o;;o;	;
@
;im$;"mepa_power_set;@;[ ;0;[{;{	;o;;o;	;
@
;i|$;"struct mepa_device *;@;o;;o;	;
@
;iê$;"dev;@;[ ;0{;{	;o;;o;	;
@
;i¨$;"mepa_power_mode_t ;@;o;;o;	;
@
;iæ$;"
power;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iø%;"mepa_rc ;@;o;;o;	;
@
;i«%;"mepa_cable_diag_start;@;[ ;0;[{;{	;o;;o;	;
@
;i›%;"struct mepa_device *;@;o;;o;	;
@
;iÒ%;"dev;@;[ ;0{;{	;o;;o;	;
@
;i&;"	int ;@;o;;o;	;
@
;i&;"	mode;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i9';"mepa_rc ;@;o;;o;	;
@
;iA';"mepa_cable_diag_get;@;[ ;0;[{;{	;o;;o;	;
@
;iU';"struct mepa_device *;@;o;;o;	;
@
;ii';"dev;@;[ ;0{;{	;o;;o;	;
@
;iä';"mepa_cable_diag_result_t *;@;o;;o;	;
@
;i§';"result;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iÆ(;"mepa_rc ;@;o;;o;	;
@
;i∂(;"mepa_media_set;@;[ ;0;[{;{	;o;;o;	;
@
;i≈(;"struct mepa_device *;@;o;;o;	;
@
;iŸ(;"dev;@;[ ;0{;{	;o;;o;	;
@
;iı(;"mepa_media_interface_t ;@;o;;o;	;
@
;i);"phy_media_if;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i*;"mepa_rc ;@;o;;o;	;
@
;i&*;"mepa_media_get;@;[ ;0;[{;{	;o;;o;	;
@
;i5*;"struct mepa_device *;@;o;;o;	;
@
;iI*;"dev;@;[ ;0{;{	;o;;o;	;
@
;ie*;"mepa_media_interface_t *;@;o;;o;	;
@
;i}*;"phy_media_if;@;[ ;0;0{;!{;{	;o;;o;	;
@
;ió+;"mepa_rc ;@;o;;o;	;
@
;iü+;"mepa_aneg_status_get;@;[ ;0;[{;{	;o;;o;	;
@
;i¥+;"struct mepa_device *;@;o;;o;	;
@
;i»+;"dev;@;[ ;0{;{	;o;;o;	;
@
;iÍ+;"mepa_aneg_status_t *;@;o;;o;	;
@
;i˛+;"status;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iä-;"mepa_rc ;@;o;;o;	;
@
;ií-;"mepa_clause22_read;@;[ ;0;[{;{	;o;;o;	;
@
;i•-;"struct mepa_device *;@;o;;o;	;
@
;iπ-;"dev;@;[ ;0{;{	;o;;o;	;
@
;iŸ-;"uint32_t ;@;o;;o;	;
@
;i‚-;"address;@;[ ;0{;{	;o;;o;	;
@
;i.;"uint16_t *const ;@;o;;o;	;
@
;i.;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iê/;"mepa_rc ;@;o;;o;	;
@
;iò/;"mepa_clause22_write;@;[ ;0;[{;{	;o;;o;	;
@
;i¨/;"struct mepa_device *;@;o;;o;	;
@
;i¿/;"dev;@;[ ;0{;{	;o;;o;	;
@
;i·/;"uint32_t ;@;o;;o;	;
@
;iÍ/;"address;@;[ ;0{;{	;o;;o;	;
@
;i0;"uint16_t ;@;o;;o;	;
@
;i0;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iõ1;"mepa_rc ;@;o;;o;	;
@
;i£1;"mepa_clause45_read;@;[ ;0;[{;{	;o;;o;	;
@
;i∂1;"struct mepa_device *;@;o;;o;	;
@
;i 1;"dev;@;[ ;0{;{	;o;;o;	;
@
;iÍ1;"uint32_t ;@;o;;o;	;
@
;iÛ1;"address;@;[ ;0{;{	;o;;o;	;
@
;i2;"uint16_t *const ;@;o;;o;	;
@
;i'2;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i™3;"mepa_rc ;@;o;;o;	;
@
;i≤3;"mepa_clause45_write;@;[ ;0;[{;{	;o;;o;	;
@
;i∆3;"struct mepa_device *;@;o;;o;	;
@
;i⁄3;"dev;@;[ ;0{;{	;o;;o;	;
@
;i˚3;"uint32_t ;@;o;;o;	;
@
;i4;"address;@;[ ;0{;{	;o;;o;	;
@
;i)4;"uint16_t ;@;o;;o;	;
@
;i24;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iP5;"mepa_rc ;@;o;;o;	;
@
;iX5;"mepa_event_enable_set;@;[ ;0;[{;{	;o;;o;	;
@
;in5;"struct mepa_device *;@;o;;o;	;
@
;iÇ5;"dev;@;[ ;0{;{	;o;;o;	;
@
;i•5;"mepa_event_t ;@;o;;o;	;
@
;i≤5;"
event;@;[ ;0{;{	;o;;o;	;
@
;i◊5;"mesa_bool_t ;@;o;;o;	;
@
;i„5;"enable;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iı6;"mepa_rc ;@;o;;o;	;
@
;i˝6;"mepa_event_enable_get;@;[ ;0;[{;{	;o;;o;	;
@
;i7;"struct mepa_device *;@;o;;o;	;
@
;i'7;"dev;@;[ ;0{;{	;o;;o;	;
@
;iJ7;"mepa_event_t *const ;@;o;;o;	;
@
;i^7;"
event;@;[ ;0;0{;!{;{	;o;;o;	;
@
;ir8;"mepa_rc ;@;o;;o;	;
@
;iz8;"mepa_event_poll;@;[ ;0;[{;{	;o;;o;	;
@
;iä8;"struct mepa_device *;@;o;;o;	;
@
;iû8;"dev;@;[ ;0{;{	;o;;o;	;
@
;iª8;"mepa_event_t *const ;@;o;;o;	;
@
;iœ8;"ev_mask;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i˙9;"mepa_rc ;@;o;;o;	;
@
;i:;"mepa_loopback_set;@;[ ;0;[{;{	;o;;o;	;
@
;i:;"struct mepa_device *;@;o;;o;	;
@
;i(:;"dev;@;[ ;0{;{	;o;;o;	;
@
;iG:;"const mepa_loopback_t *;@;o;;o;	;
@
;i^:;"loopback;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iW;;"mepa_rc ;@;o;;o;	;
@
;i_;;"mepa_loopback_get;@;[ ;0;[{;{	;o;;o;	;
@
;iq;;"struct mepa_device *;@;o;;o;	;
@
;iÖ;;"dev;@;[ ;0{;{	;o;;o;	;
@
;i§;;"mepa_loopback_t *const ;@;o;;o;	;
@
;iª;;"loopback;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i«<;"mepa_rc ;@;o;;o;	;
@
;iœ<;"mepa_gpio_mode_set;@;[ ;0;[{;{	;o;;o;	;
@
;i‚<;"struct mepa_device *;@;o;;o;	;
@
;iˆ<;"dev;@;[ ;0{;{	;o;;o;	;
@
;i=;"const mepa_gpio_conf_t *;@;o;;o;	;
@
;i.=;"	data;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i/>;"mepa_rc ;@;o;;o;	;
@
;i7>;"mepa_gpio_out_set;@;[ ;0;[{;{	;o;;o;	;
@
;iI>;"struct mepa_device *;@;o;;o;	;
@
;i]>;"dev;@;[ ;0{;{	;o;;o;	;
@
;i|>;"uint8_t ;@;o;;o;	;
@
;iÑ>;"gpio_no;@;[ ;0{;{	;o;;o;	;
@
;iß>;"mepa_bool_t ;@;o;;o;	;
@
;i≥>;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iª?;"mepa_rc ;@;o;;o;	;
@
;i√?;"mepa_gpio_in_get;@;[ ;0;[{;{	;o;;o;	;
@
;i‘?;"struct mepa_device *;@;o;;o;	;
@
;iË?;"dev;@;[ ;0{;{	;o;;o;	;
@
;i@;"uint8_t ;@;o;;o;	;
@
;i@;"gpio_no;@;[ ;0{;{	;o;;o;	;
@
;i0@;"mepa_bool_t *const ;@;o;;o;	;
@
;iC@;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i7A;"mepa_rc ;@;o;;o;	;
@
;i?A;"mepa_synce_clock_conf_set;@;[ ;0;[{;{	;o;;o;	;
@
;iYA;"struct mepa_device *;@;o;;o;	;
@
;imA;"dev;@;[ ;0{;{	;o;;o;	;
@
;iîA;"$const mepa_synce_clock_conf_t *;@;o;;o;	;
@
;i≥A;"	conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i¸B;"mepa_rc ;@;o;;o;	;
@
;iC;"mepa_link_base_port;@;[ ;0;[{;{	;o;;o;	;
@
;iC;"struct mepa_device *;@;o;;o;	;
@
;i,C;"dev;@;[ ;0{;{	;o;;o;	;
@
;iMC;"struct mepa_device *;@;o;;o;	;
@
;iaC;"base_dev;@;[ ;0{;{	;o;;o;	;
@
;iáC;"uint8_t ;@;o;;o;	;
@
;ièC;"packet_idx;@;[ ;0;0{;!{;{	;o;;o;	;
@
;ióD;"mepa_rc ;@;o;;o;	;
@
;iüD;"mepa_phy_info_get;@;[ ;0;[{;{	;o;;o;	;
@
;i±D;"struct mepa_device *;@;o;;o;	;
@
;i≈D;"dev;@;[ ;0{;{	;o;;o;	;
@
;i‰D;"mepa_phy_info_t *const ;@;o;;o;	;
@
;i˚D;"phy_info;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i F;"mepa_rc ;@;o;;o;	;
@
;i(F;"mepa_isolate_mode_conf;@;[ ;0;[{;{	;o;;o;	;
@
;i?F;"struct mepa_device *;@;o;;o;	;
@
;iSF;"dev;@;[ ;0{;{	;o;;o;	;
@
;iwF;"const mepa_bool_t ;@;o;;o;	;
@
;iâF;"iso_en;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iúG;"mepa_rc ;@;o;;o;	;
@
;i§G;"mepa_debug_info_dump;@;[ ;0;[{;{	;o;;o;	;
@
;iπG;"struct mepa_device *;@;o;;o;	;
@
;iÕG;"dev;@;[ ;0{;{	;o;;o;	;
@
;iÔG;"const mepa_debug_print_t ;@;o;;o;	;
@
;iH;"pr;@;[ ;0{;{	;o;;o;	;
@
;i)H;"&const mepa_debug_info_t   *const ;@;o;;o;	;
@
;iJH;"	info;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i∏L;"mepa_rc ;@;o;;o;	;
@
;i¿L;"mepa_i2c_read;@;[ ;0;[{;{	;o;;o;	;
@
;iŒL;"mepa_device_t *;@;o;;o;	;
@
;i›L;"dev;@;[ ;0{;{	;o;;o;	;
@
;i˙L;"const uint8_t ;@;o;;o;	;
@
;iM;"i2c_mux;@;[ ;0{;{	;o;;o;	;
@
;i)M;"const uint8_t ;@;o;;o;	;
@
;i7M;"i2c_reg_addr;@;[ ;0{;{	;o;;o;	;
@
;i]M;"const uint8_t ;@;o;;o;	;
@
;ikM;"i2c_dev_addr;@;[ ;0{;{	;o;;o;	;
@
;iëM;"uint8_t *const ;@;o;;o;	;
@
;i†M;"
value;@;[ ;0{;{	;o;;o;	;
@
;iøM;"uint8_t ;@;o;;o;	;
@
;i«M;"cnt;@;[ ;0{;{	;o;;o;	;
@
;i‰M;"const mepa_bool_t ;@;o;;o;	;
@
;iˆM;"word_access;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i8R;"mepa_rc ;@;o;;o;	;
@
;i@R;"mepa_i2c_write;@;[ ;0;[{;{	;o;;o;	;
@
;iOR;"mepa_device_t *;@;o;;o;	;
@
;i^R;"dev;@;[ ;0{;{	;o;;o;	;
@
;i{R;"const uint8_t ;@;o;;o;	;
@
;iâR;"i2c_mux;@;[ ;0{;{	;o;;o;	;
@
;i™R;"const uint8_t ;@;o;;o;	;
@
;i∏R;"i2c_reg_addr;@;[ ;0{;{	;o;;o;	;
@
;iﬁR;"const uint8_t ;@;o;;o;	;
@
;iÏR;"i2c_dev_addr;@;[ ;0{;{	;o;;o;	;
@
;iS;"uint8_t *;@;o;;o;	;
@
;iS;"
value;@;[ ;0{;{	;o;;o;	;
@
;i:S;"uint8_t ;@;o;;o;	;
@
;iBS;"cnt;@;[ ;0{;{	;o;;o;	;
@
;i_S;"const mepa_bool_t ;@;o;;o;	;
@
;iqS;"word_access;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i[T;"mepa_rc ;@;o;;o;	;
@
;icT;"mepa_sqi_read;@;[ ;0;[{;{	;o;;o;	;
@
;iqT;"struct mepa_device *;@;o;;o;	;
@
;iÖT;"dev;@;[ ;0{;{	;o;;o;	;
@
;iäT;"uint32_t *const ;@;o;;o;	;
@
;iöT;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iÑU;"mepa_rc ;@;o;;o;	;
@
;iåU;"!mepa_start_of_frame_conf_set;@;[ ;0;[{;{	;o;;o;	;
@
;i©U;"struct mepa_device *;@;o;;o;	;
@
;iΩU;"dev;@;[ ;0{;{	;o;;o;	;
@
;i¬U;"'mepa_start_of_frame_conf_t *const ;@;o;;o;	;
@
;i‰U;"	conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i∆V;"mepa_rc ;@;o;;o;	;
@
;iŒV;"!mepa_start_of_frame_conf_get;@;[ ;0;[{;{	;o;;o;	;
@
;iÎV;"struct mepa_device *;@;o;;o;	;
@
;iˇV;"dev;@;[ ;0{;{	;o;;o;	;
@
;iW;"'mepa_start_of_frame_conf_t *const ;@;o;;o;	;
@
;i&W;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iX;"mepa_rc ;@;o;;o;	;
@
;i$X;"mepa_framepreempt_get;@;[ ;0;[{;{	;o;;o;	;
@
;i:X;"struct mepa_device *;@;o;;o;	;
@
;iNX;"dev;@;[ ;0{;{	;o;;o;	;
@
;iSX;"mepa_bool_t *const ;@;o;;o;	;
@
;ifX;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iSY;"mepa_rc ;@;o;;o;	;
@
;i[Y;"mepa_selftest_start;@;[ ;0;[{;{	;o;;o;	;
@
;ioY;"struct mepa_device *;@;o;;o;	;
@
;iÉY;"dev;@;[ ;0{;{	;o;;o;	;
@
;iàY;"!const mepa_selftest_info_t *;@;o;;o;	;
@
;i§Y;"inf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iöZ;"mepa_rc ;@;o;;o;	;
@
;i¢Z;"mepa_selftest_read;@;[ ;0;[{;{	;o;;o;	;
@
;iµZ;"struct mepa_device *;@;o;;o;	;
@
;i…Z;"dev;@;[ ;0{;{	;o;;o;	;
@
;iŒZ;"!mepa_selftest_info_t *const ;@;o;;o;	;
@
;iÍZ;"selftest_inf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iÎ[;"mepa_rc ;@;o;;o;	;
@
;iÛ[;"mepa_prbs_set;@;[ ;0;[	{;{	;o;;o;	;
@
;i\;"struct mepa_device *;@;o;;o;	;
@
;i\;"dev;@;[ ;0{;{	;o;;o;	;
@
;i\;"mepa_phy_prbs_type_t ;@;o;;o;	;
@
;i/\;"	type;@;[ ;0{;{	;o;;o;	;
@
;i5\;"mepa_phy_prbs_direction_t ;@;o;;o;	;
@
;iO\;"direction;@;[ ;0{;{	;o;;o;	;
@
;iZ\;"+mepa_phy_prbs_generator_conf_t *const ;@;o;;o;	;
@
;iÄ\;"mepa_conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i];"mepa_rc ;@;o;;o;	;
@
;iá];"mepa_prbs_get;@;[ ;0;[	{;{	;o;;o;	;
@
;iï];"struct mepa_device *;@;o;;o;	;
@
;i©];"dev;@;[ ;0{;{	;o;;o;	;
@
;iÆ];"mepa_phy_prbs_type_t ;@;o;;o;	;
@
;i√];"	type;@;[ ;0{;{	;o;;o;	;
@
;i…];"mepa_phy_prbs_direction_t ;@;o;;o;	;
@
;i„];"direction;@;[ ;0{;{	;o;;o;	;
@
;iÓ];"+mepa_phy_prbs_generator_conf_t *const ;@;o;;o;	;
@
;i^;"mepa_conf;@;[ ;0;0{;!{;{	;o;;o;	;
@
;i_;"mepa_rc ;@;o;;o;	;
@
;i_;"mepa_prbs_monitor_set;@;[ ;0;[{;{	;o;;o;	;
@
;i"_;"struct mepa_device *;@;o;;o;	;
@
;i6_;"dev;@;[ ;0{;{	;o;;o;	;
@
;i;_;")mepa_phy_prbs_monitor_conf_t *const ;@;o;;o;	;
@
;i__;"
value;@;[ ;0;0{;!{;{	;o;;o;	;
@
;iM`;"mepa_rc ;@;o;;o;	;
@
;iU`;"mepa_prbs_monitor_get;@;[ ;0;[{;{	;o;;o;	;
@
;ik`;"struct mepa_device *;@;o;;o;	;
@
;i`;"dev;@;[ ;0{;{	;o;;o;	;
@
;iÑ`;")mepa_phy_prbs_monitor_conf_t *const ;@;o;;o;	;
@
;i®`;"
value;@;[ ;0;0{;o;;o;	;
@
;i±`;"-#include <microchip/ethernet/hdr_end.h>
;@{;o;;o;	;
@
;iŸ`;"#endif
;@