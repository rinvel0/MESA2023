{:	root[{:ppo:Parslet::Slice:@positiono:Parslet::Position:@string"•// Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT


/**
 * \file
 * \brief TimeStamping API.
 * \details This header file describes PTP/OAM TimeStamping API functions and
 * associated types.
 */

#ifndef _VTSS_TS_API_H_
#define _VTSS_TS_API_H_

#include <vtss/api/types.h>
#include <vtss_security_api.h>    /* For vtss_ace_u8_t */

// ***************************************************************************
//
//  TimeStamping interface
//
// ***************************************************************************

#if defined(VTSS_FEATURE_TIMESTAMP)
#ifdef __cplusplus
extern "C" {
#endif

/** \brief Number of clock cycle counts pr sec. */
#if defined (VTSS_ARCH_OCELOT)
#define VTSS_HW_TIME_CNT_PR_SEC 1000000000 /* Serval counts ns instead of clock cycles */
/** \brief Number of nanoseconds pr clock count. */
#define VTSS_HW_TIME_NSEC_PR_CNT 1
#endif
#if defined (VTSS_ARCH_LUTON26)
#define VTSS_HW_TIME_CNT_PR_SEC 250000000 /* L26 counts clock cycles instead of ns */
/** \brief Number of nanoseconds pr clock count. */
#define VTSS_HW_TIME_NSEC_PR_CNT 4
#endif
#if defined (VTSS_ARCH_LAN966X)  /* TBD. Check/set correct value */
#define VTSS_HW_TIME_CNT_PR_SEC 1000000000
/** \brief Number of nanoseconds pr clock count. */
#define VTSS_HW_TIME_NSEC_PR_CNT 1
#define VTSS_HW_TIME_WRAP_LIMIT  0       /* time counter wrap around limit+1 */
#define VTSS_HW_TIME_MIN_ADJ_RATE  10       /* 1 ppb */
#endif

#if defined (VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5)
#define VTSS_HW_TIME_CNT_PR_SEC 1000000000
/** \brief Number of nanoseconds pr clock count. */
#define VTSS_HW_TIME_NSEC_PR_CNT 1
/** \brief Jaguar2 nanosecond time counter wrap around value (jaguar2 time counter wraps when 0xffffffff is reached). */
#define VTSS_HW_TIME_WRAP_LIMIT  0       /* time counter wrap around limit+1 */
#endif

#if defined (VTSS_ARCH_LUTON26) || defined (VTSS_ARCH_OCELOT)
/** \brief Caracal nanosecond time counter wrap around value (Caracal time counter wraps when 0xffffffff is reached). */
#define VTSS_HW_TIME_WRAP_LIMIT  0       /* time counter wrap around limit+1 (=0 if wrap at 0xffffffff) */
#endif

#if defined (VTSS_ARCH_LUTON26)
/** \brief Luton26 minimum adjustment rate in units of 0,1 ppb. */
#define VTSS_HW_TIME_MIN_ADJ_RATE  40       /* 4 ppb */
#endif
#if defined (VTSS_ARCH_OCELOT)
/** \brief Serval minimum adjustment rate in units of 0,1 ppb. */
#define VTSS_HW_TIME_MIN_ADJ_RATE  10       /* 1 ppb */
#endif

#if defined (VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5)
/** \brief Jaguar 2 minimum adjustment rate in units of 0,1 ppb. */
#define VTSS_HW_TIME_MIN_ADJ_RATE  10       /* 1 ppb */
#endif

#if defined (VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5)
/** \brief Number of Jaguar2 PTP pins, that can be used as 1PPS or clock output/input. */
#define VTSS_TS_IO_ARRAY_SIZE       4
/** \brief Number of separate clock domains in Jaguar2 */
#define VTSS_TS_DOMAIN_ARRAY_SIZE   3
#elif defined (VTSS_ARCH_LAN966X)
/** \brief Number of LAN966X PTP pins, that can be used as 1PPS or clock output/input. */
#define VTSS_TS_IO_ARRAY_SIZE       7
/** \brief Number of separate clock domains in LAN966X */
#define VTSS_TS_DOMAIN_ARRAY_SIZE   3
#elif defined(VTSS_ARCH_OCELOT)
/** \brief Number of Ocelot PTP pins that can be used as 1 PPS or clock output/input. */
#define VTSS_TS_IO_ARRAY_SIZE       4
/** \brief Number of separate clock domains in Ocelot */
#define VTSS_TS_DOMAIN_ARRAY_SIZE   1
#else
/** \brief Number of L26 or Serval PTP pins, that can be used as 1PPS or clock output/input. */
#define VTSS_TS_IO_ARRAY_SIZE       1
/** \brief Number of separate clock domains in L26 */
#define VTSS_TS_DOMAIN_ARRAY_SIZE   1
#endif

#if defined(VTSS_ARCH_SPARX5)
/** \brief Number of Automatic Delay Response controllers in SparX-5 */
#define VTSS_TS_RESP_CTRL_ARRAY_SIZE 4
#endif

/** \brief This is the max time offset adjustment that os done without setting ports in disabled state */
#define VTSS_HW_TIME_MAX_FINE_ADJ   25

/**
 * \brief Set the current time in a Timestamp format.
 * \param inst [IN]     handle to an API instance.
 * \param ts [IN]       pointer to a TimeStamp structure.
 * Architecture:
 *   All
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_set(const vtss_inst_t             inst,
                              const vtss_timestamp_t        *const ts);

/**
 * \brief Set the current time in a Timestamp format for a domain.
 * \param inst   [IN]   handle to an API instance.
 * \param domain [IN]   Clock domain.
 * \param ts     [IN]   pointer to a TimeStamp structure.
 * Architecture:
 *   Jaguar2: domain 0..2
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_timeofday_set(const vtss_inst_t             inst,
                                     const u32                     domain,
                                     const vtss_timestamp_t        *const ts);

/**
 * \brief Set delta the current time in a Timestamp format.
 * \param inst     [IN] handle to an API instance.
 * \param ts       [IN] pointer to a TimeStamp structure.
 * \param negative [IN] True if ts is subtracted from current time, else ts is added.
 * Architecture:
 *   All
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_set_delta(const vtss_inst_t       inst,
                                    const vtss_timestamp_t  *ts,
                                    BOOL                    negative);

/**
 * \brief Set delta the current time in a Timestamp format.
 * \param inst     [IN] handle to an API instance.
 * \param domain   [IN] Clock domain.
 * \param ts       [IN] pointer to a TimeStamp structure.
 * \param negative [IN] True if ts is subtracted from current time, else ts is added.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_timeofday_set_delta(const vtss_inst_t       inst,
                                           const u32               domain,
                                           const vtss_timestamp_t  *ts,
                                           BOOL                    negative);

/**
 * \brief Subtract offset from the current time.
 * \param inst [IN]     handle to an API instance.
 * \param offset [IN]   offset in ns.
 * Architecture:
 *   All
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_offset_set(const vtss_inst_t          inst,
                                     const i32                  offset);

/**
 * \brief Subtract offset from the current time.
 * \param inst   [IN]   handle to an API instance.
 * \param domain [IN]   Clock domain.
 * \param offset [IN]   offset in ns.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_timeofday_offset_set(const vtss_inst_t          inst,
                                            const u32                  domain,
                                            const i32                  offset);

/**
 * \brief Do the one sec administration in the Timestamp function.
 * \param inst [IN]     handle to an API instance.
 * \param ongoing_adjustment [OUT]  True if clock adjustment is ongoing
 *
 * \return Return code.
 *
 * Architecture:
 *  Jr1    : Maintains the clock setting process
 *  Caracal: Maintains the clock setting process
 *  Serval1: Maintains the clock setting process
 *  JR2,
 *  S5     : it must only be called when the PPS output pin is low, therefore it shall be called at least 200 microseconds after the 1PPS interrupt
 *
 * \return Return code.
 */
vtss_rc vtss_ts_adjtimer_one_sec(const vtss_inst_t             inst,
                                 BOOL                          *const ongoing_adjustment);

/**
 * \brief Check if the clock adjustment is ongoing.
 * \param inst [IN]     handle to an API instance.
 * \param ongoing_adjustment [OUT]  True if clock adjustment is ongoing
 * Architecture:
 *  Jr1    ,
 *  Caracal,
 *  Serval1: Checks if the clock setting process is ongoing.
 *  JR2,
 *  S5     : Always returns False, as the time can be set immediately.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_ongoing_adjustment(const vtss_inst_t           inst,
                                   BOOL                        *const ongoing_adjustment);

/**
 * \brief Get the current time in a Timestamp format, and the corresponding
 *        time counter.
 * \param inst [IN]     handle to an API instance
 * \param ts [OUT]      pointer to a TimeStamp structure
 * \param tc [OUT]      pointer to a time counter (internal hw format)
 * Architecture:
 *  Caracal: tc = free running clock cycle counter
 *  Ocelot:
 *  Serval:  tc = (seconds + nanoseconds). In 16 bit fraction of nano seconds.
 *  Jaguar2: tc = free running nanoseconds counter.  In 16 bit fraction of nano seconds.
 *  SparX-5: tc = (seconds + nanoseconds + fractional nanoseconds). In 16 bit fraction of nano seconds.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_get(const vtss_inst_t             inst,
                              vtss_timestamp_t              *const ts,
                              u64                           *const tc);

/**
 * \brief Get the current raw time in a Timestamp format, and the corresponding
 *        time counter. (like vtss_ts_timeofday_get but without correction for outstanding adjustments.)
 *        Used to be able to poll the time and call the onsec function in architectures that do not support interrupt.
 * \param inst [IN]     handle to an API instance
 * \param ts [OUT]      pointer to a TimeStamp structure
 * \param tc [OUT]      pointer to a time counter (internal hw format)
 * Architecture:
 *  Ocelot:
 *  Serval:  tc = (seconds + nanoseconds).  In 16 bit fraction of nano seconds.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_raw(const vtss_inst_t             inst,
                              vtss_timestamp_t              *const ts,
                              u64                           *const tc);

/**
 * \brief Get the current time in a Timestamp format, and the corresponding
 *        time counter.
 * \param inst   [IN]   handle to an API instance
 * \param domain [IN]   Clock domain.
 * \param ts     [OUT]  pointer to a TimeStamp structure
 * \param tc     [OUT]  pointer to a time counter (internal hw format)
 * Architecture:
 *  Same as vtss_ts_timeofday_get
 *
 * \return Return code.
 *
 * Note: This is the same function as vtss_ts_domain_timeofday_get except for no
 *       locking/unlocking of API critical region. This variant of the function
 *       assumes that locking has already been done and that the function is
 *       called from within another API function.
 */
vtss_rc _vtss_ts_domain_timeofday_get(const vtss_inst_t            inst,
                                     const u32                     domain,
                                     vtss_timestamp_t              *const ts,
                                     u64                           *const tc);

/**
 * \brief Get the current time in a Timestamp format, and the corresponding
 *        time counter.
 * \param inst   [IN]   handle to an API instance
 * \param domain [IN]   Clock domain.
 * \param ts     [OUT]  pointer to a TimeStamp structure
 * \param tc     [OUT]  pointer to a time counter (internal hw format)
 * Architecture:
 *  Same as vtss_ts_timeofday_get
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_timeofday_get(const vtss_inst_t             inst,
                                     const u32                     domain,
                                     vtss_timestamp_t              *const ts,
                                     u64                           *const tc);

/**
 * \brief Get the time at the next 1PPS pulse edge in a Timestamp format.
 * \param inst [IN]     handle to an API instance
 * \param ts   [OUT]    pointer to a TimeStamp structure
 * Architecture:
 *  All
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_next_pps_get(const vtss_inst_t             inst,
                                       vtss_timestamp_t              *const ts);

/**
 * \brief Get the time at the prev 1PPS pulse edge in a Timestamp format.
 * \param inst [IN]     handle to an API instance
 * \param ts   [OUT]    pointer to a TimeStamp structure
 * Architecture:
 *  All
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_prev_pps_get(const vtss_inst_t             inst,
                                       vtss_timestamp_t              *const ts);

/**
 * \brief Get the time at the next 1PPS pulse edge in a Timestamp format.
 * \param inst   [IN]   handle to an API instance
 * \param domain [IN]   Clock domain.
 * \param ts     [OUT]  pointer to a TimeStamp structure
 * Architecture:
 *  All
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_timeofday_next_pps_get(const vtss_inst_t      inst,
                                              const u32              domain,
                                              vtss_timestamp_t       *const ts);

/**
 * \brief Adjust the clock timer ratio.
 * \param inst [IN]     handle to an API instance.
 * \param adj [IN]      Clock ratio frequency offset in units of 0,1 ppb (parts pr billion).
 *                      ratio > 0 => clock runs faster
 *
 * \return Return code.
 */
vtss_rc vtss_ts_adjtimer_set(const vtss_inst_t              inst,
                             const i32                      adj);

/**
* \brief get the clock timer ratio.
*
* \param inst [IN]     handle to an API instance.
* \param adj [OUT]     Clock ratio frequency offset in ppb (parts pr billion).
*                      ratio > 0 => clock runs faster
*
* \return Return code.
*/
vtss_rc vtss_ts_adjtimer_get(const vtss_inst_t              inst,
                             i32                            *const adj);

/**
 * \brief Adjust the clock timer ratio for a domain.
 * Architecture:
 *   Jaguar2: domain 0..2
 *   Luton26, Serval1: domain 0
 *
 * \param inst   [IN]     handle to an API instance.
 * \param domain [IN]     Clock domain.
 * \param adj    [IN]     Clock ratio frequency offset in units of 0,1 ppb (parts pr billion).
 *                      ratio > 0 => clock runs faster
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_adjtimer_set(const vtss_inst_t              inst,
                                    const u32                      domain,
                                    const i32                      adj);

/**
 * \brief get the clock timer ratio for a domain.
 * Architecture:
 *   Jaguar2: domain 0..2
 *   Luton26, Serval1: domain 0
 *
 * \param inst   [IN]     handle to an API instance.
 * \param domain [IN]     Clock domain.
 * \param adj    [OUT]    Clock ratio frequency offset in units of 0,1 ppb (parts pr billion).
 *                        ratio > 0 => clock runs faster
 *
 * \return Return code.
 */
vtss_rc vtss_ts_domain_adjtimer_get(const vtss_inst_t              inst,
                                    const u32                      domain,
                                    i32                            *const adj);

/**
* \brief get the clock internal timer frequency offset, compared to external clock input.
*
* \param inst [IN]     handle to an API instance.
* \param adj [OUT]     Clock ratio frequency offset in ppb (parts pr billion).
*                      ratio > 0 => internal clock runs faster than external clock
*
* \return Return code.
*/
vtss_rc vtss_ts_freq_offset_get(const vtss_inst_t           inst,
                                i32                         *const adj);

#if defined(VTSS_ARCH_OCELOT) || defined(VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5) || defined(VTSS_ARCH_LAN966X) /* TBD_henrikb */
/**
 * \brief parameter for setting the alternative  clock mode.
 */
/** \brief external clock output configuration. */
typedef struct vtss_ts_alt_clock_mode_t {
    BOOL one_pps_out;       /**< Enable 1pps output */
    BOOL one_pps_in;        /**< Enable 1pps input */
    BOOL save;              /**< Save actual time counter at next 1 PPS input */
    BOOL load;              /**< Load actual time counter with at next 1 PPS input */
} vtss_ts_alt_clock_mode_t;

/**
 * \brief Get the latest saved nanosec counter from the alternative clock.
 *
 * \param inst [IN]             handle to an API instance
 * \param saved [OUT]           latest saved value.  In 16 bit fraction of nano seconds.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_alt_clock_saved_get(const vtss_inst_t           inst,
                                    u64    *const               saved);

#if defined(VTSS_ARCH_OCELOT)
/**
 * \brief Get the latest saved timeofday from the alternative clock.
 *
 * \param inst [IN]             handle to an API instance
 * \param ts   [OUT]            latest saved timeofday.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_alt_clock_saved_timeofday_get(const vtss_inst_t     inst,
                                    vtss_timestamp_t  *const        ts);
#endif

/**
 * \brief Get the alternative external clock mode.
 *
 * \param inst [IN]             handle to an API instance
 * \param alt_clock_mode [OUT]  alternative clock mode.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_alt_clock_mode_get(const vtss_inst_t              inst,
                                   vtss_ts_alt_clock_mode_t       *const alt_clock_mode);

/**
 * \brief Set the alternative external clock mode.
 *  This function configures the 1PPS, L/S pin usage for pin set no 0 in Serval
 *
 * \param inst [IN]             handle to an API instance
 * \param alt_clock_mode [IN]   alternative clock mode.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_alt_clock_mode_set(const vtss_inst_t              inst,
                                   const vtss_ts_alt_clock_mode_t *const alt_clock_mode);

/**
 * \brief Set the time at the next 1PPS pulse edge in a Timestamp format.
 * \param inst [IN]     handle to an API instance
 * \param ts [OUT]      pointer to a TimeStamp structure
 *
 * \return Return code.
 */
vtss_rc vtss_ts_timeofday_next_pps_set(const vtss_inst_t       inst,
                                       const vtss_timestamp_t  *const ts);
#endif

/**
 * \brief parameter for setting the external clock mode.
 */
typedef enum  {
    VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_DISABLE,
    VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT,
    VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_INPUT,
    VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT_INPUT,
    VTSS_TS_EXT_CLOCK_MODE_MAX
} vtss_ts_ext_clock_one_pps_mode_t;

#define TS_EXT_CLOCK_MODE_ONE_PPS_DISABLE      VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_DISABLE      /**< Backward compatibility */
#define TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT       VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT       /**< Backward compatibility */
#define TS_EXT_CLOCK_MODE_ONE_PPS_INPUT        VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_INPUT        /**< Backward compatibility */
#define TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT_INPUT VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT_INPUT /**< Backward compatibility */
#define TS_EXT_CLOCK_MODE_MAX                  VTSS_TS_EXT_CLOCK_MODE_MAX                  /**< Backward compatibility */

/** \brief external clock output configuration. */
typedef struct vtss_ts_ext_clock_mode_t {
    vtss_ts_ext_clock_one_pps_mode_t   one_pps_mode;    
                            /**< Select 1pps ext clock mode:
                               input :  lock clock to 1pps input
                               output:  enable external sync pulse output
                               disable: disable 1 pps */
    BOOL enable;            /**< Select internal sync pulse (enable = false) 
                                or external sync pulse (enable = true) */
    u32  freq;              /**< clock output frequency (hz [1..25.000.000]). */
} vtss_ts_ext_clock_mode_t;


/**
 * \brief Get the external clock mode.
 *  The mode depends on the hardware capability, it may be:
 *          Enable/disable external synch pulse
 *          Set clock output frequency
 *
 * \param inst [IN]             handle to an API instance
 * \param ext_clock_mode [OUT]  external clock mode.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_external_clock_mode_get(const vtss_inst_t           inst,
                                        vtss_ts_ext_clock_mode_t    *const ext_clock_mode);

/**
 * \brief Set the external clock mode.
 *  The mode depends on the hardware capability, it may be:
 *          Enable/disable external synch pulse
 *          Set clock output frequency
 *
 * \param inst [IN]             handle to an API instance
 * \param ext_clock_mode [IN]   external clock mode.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_external_clock_mode_set(const vtss_inst_t              inst,
                                        const vtss_ts_ext_clock_mode_t *const ext_clock_mode);

#if defined(VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5) || defined(VTSS_ARCH_LAN966X) || defined(VTSS_ARCH_LUTON26) || defined(VTSS_ARCH_OCELOT)
/**
 * \brief parameter for setting the external io mode.
 * Architecture:
 *   Jaguar2: 
 */
typedef enum  {
    VTSS_TS_EXT_IO_MODE_ONE_PPS_DISABLE,     /**< Disable IO pin */
    VTSS_TS_EXT_IO_MODE_ONE_PPS_OUTPUT,      /**< enable external sync pulse output */
    VTSS_TS_EXT_IO_MODE_WAVEFORM_OUTPUT,     /**< enable external clock output frequency */
    VTSS_TS_EXT_IO_MODE_ONE_PPS_LOAD,        /**< enable input and load time at positive edge of input signal */
    VTSS_TS_EXT_IO_MODE_ONE_PPS_SAVE,        /**< enable input and save time at positive edge of input signal */
    VTSS_TS_EXT_IO_MODE_MAX
} vtss_ts_ext_io_pin_cfg_t;

#define TS_EXT_IO_MODE_ONE_PPS_DISABLE VTSS_TS_EXT_IO_MODE_ONE_PPS_DISABLE /**< Backward compatibility */
#define TS_EXT_IO_MODE_ONE_PPS_OUTPUT  VTSS_TS_EXT_IO_MODE_ONE_PPS_OUTPUT  /**< Backward compatibility */
#define TS_EXT_IO_MODE_WAVEFORM_OUTPUT VTSS_TS_EXT_IO_MODE_WAVEFORM_OUTPUT /**< Backward compatibility */
#define TS_EXT_IO_MODE_ONE_PPS_LOAD    VTSS_TS_EXT_IO_MODE_ONE_PPS_LOAD    /**< Backward compatibility */
#define TS_EXT_IO_MODE_ONE_PPS_SAVE    VTSS_TS_EXT_IO_MODE_ONE_PPS_SAVE    /**< Backward compatibility */
#define TS_EXT_IO_MODE_MAX             VTSS_TS_EXT_IO_MODE_MAX             /**< Backward compatibility */

/** \brief external clock io configuration. */
typedef struct vtss_ts_ext_io_mode_s {
    vtss_ts_ext_io_pin_cfg_t    pin;    /**< Defines the io operation modefor the io pin */
    u32                         domain; /**< clock domain [0..2] assigned to the IO pin */
    u32                         freq;   /**< clock output frequency (hz [1..25.000.000]). only relevant in WAVEFORM _OUTPUT mode */
} vtss_ts_ext_io_mode_t;

/**
 * \brief Get the external io mode.
 * Architecture:
 *   Jaguar2: 
 *
 * \param inst [IN]             handle to an API instance
 * \param io   [IN]             Input/Output pin number [0..3]
 * \param ext_io_mode [OUT]     external clock io pin mode.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_external_io_mode_get(const vtss_inst_t           inst,
                                     const u32                   io,
                                     vtss_ts_ext_io_mode_t       *const ext_io_mode);

/**
 * \brief Set the external io mode.
 * Architecture:
 *   Jaguar2: 
 *
 * \param inst [IN]             handle to an API instance
 * \param io   [IN]             Input/Output pin number [0..3]
 * \param ext_io_mode [IN]      external clock io pin mode.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_external_io_mode_set(const vtss_inst_t              inst,
                                     const u32                      io,
                                     const vtss_ts_ext_io_mode_t    *const ext_io_mode);

/**
 * \brief Get the latest saved time.
 *
 * \param inst [IN]             handle to an API instance
 * \param io   [IN]             Input/Output pin number [0..3]
 * \param ts  [OUT]             latest saved timeofday for the io pin's domain
 * \param tc  [OUT]             latest saved time counter for the io pin's domain
 *
 * \return Return code.
 */
vtss_rc vtss_ts_saved_timeofday_get(const vtss_inst_t               inst,
                                    const u32                       io,
                                    vtss_timestamp_t                *const ts,
                                    u64                             *const tc);

/**
 * \brief Get the output pin generated clock edge offset to requested time.
 *
 * \param inst    [IN]             handle to an API instance
 * \param io      [IN]             Input/Output pin number [0..3]
 * \param offset  [OUT]            The last output clock edge was generated with this offset. Value 256 is one nano second.
 *
 * \return Return code.
 */
vtss_rc vtss_ts_output_clock_edge_offset_get(const vtss_inst_t inst,
                                             const u32         io,
                                             u32               *const offset);
#endif

/**
 * \brief Get the latest saved time counter in nanosec.
 *
 * \param inst [IN]             handle to an API instance
 * \param saved [OUT]           latest saved value. [0..999.999.999]
 *
 * \return Return code.
 */
vtss_rc vtss_ts_external_clock_saved_get(const vtss_inst_t               inst,
                                         u32                             *const saved);

/**
 * \brief Set the ingress latency.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param ingress_latency [IN]  pointer to ingress latency
 *
 * \return Return code.
 */
vtss_rc vtss_ts_ingress_latency_set(const vtss_inst_t              inst,
                                    const vtss_port_no_t           port_no,
                                    const vtss_timeinterval_t             *const ingress_latency);

/**
 * \brief Get the ingress latency.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param ingress_latency [OUT] pointer to ingress_latency
 *
 * \return Return code.
 */
vtss_rc vtss_ts_ingress_latency_get(const vtss_inst_t              inst,
                                    const vtss_port_no_t           port_no,
                                    vtss_timeinterval_t            *const ingress_latency);

/**
 * \brief Set the P2P delay.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param p2p_delay [IN]        peer-2-peer delay (measured)
 *
 * \return Return code.
 */
vtss_rc vtss_ts_p2p_delay_set(const vtss_inst_t                   inst,
                              const vtss_port_no_t                port_no,
                              const vtss_timeinterval_t           *const p2p_delay);

/**
 * \brief Get the P2P delay.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param p2p_delay [OUT]       pointer to peer-2-peer delay
 *
 * \return Return code.
 */
vtss_rc vtss_ts_p2p_delay_get(const vtss_inst_t              inst,
                              const vtss_port_no_t           port_no,
                              vtss_timeinterval_t            *const p2p_delay);


/**
 * \brief Set the egress latency.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param egress_latency [IN]   egress latency
 *
 * \return Return code.
 */
vtss_rc vtss_ts_egress_latency_set(const vtss_inst_t            inst,
                                   const vtss_port_no_t         port_no,
                                   const vtss_timeinterval_t    *const egress_latency);

/**
 * \brief Get the egress latency.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param egress_latency [OUT]  pointer to  egress latency
 *
 * \return Return code.
 */
vtss_rc vtss_ts_egress_latency_get(const vtss_inst_t            inst,
                                   const vtss_port_no_t         port_no,
                                   vtss_timeinterval_t          *const egress_latency);

/**
 * \brief Set the delay asymmetry.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param delay_asymmetry [IN]  delay asymmetry. The (signed) delay is subtracted on egress and added on ingress. 
 *
 * \return Return code.
 */
vtss_rc vtss_ts_delay_asymmetry_set(const vtss_inst_t           inst,
                                   const vtss_port_no_t         port_no,
                                   const vtss_timeinterval_t    *const delay_asymmetry);

/**
 * \brief Get the delay asymmetry.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param delay_asymmetry [OUT] pointer to  delay asymmetry
 *
 * \return Return code.
 */
vtss_rc vtss_ts_delay_asymmetry_get(const vtss_inst_t           inst,
                                   const vtss_port_no_t         port_no,
                                   vtss_timeinterval_t          *const delay_asymmetry);

/**
 * \brief parameter for setting the timestamp operating mode
 */
typedef enum  {
    VTSS_TS_MODE_NONE,
    VTSS_TS_MODE_EXTERNAL,
    VTSS_TS_MODE_INTERNAL,
    VTSS_TX_MODE_MAX
} vtss_ts_mode_t;

#define TS_MODE_NONE     VTSS_TS_MODE_NONE     /**< Backward compatibility */
#define TS_MODE_EXTERNAL VTSS_TS_MODE_EXTERNAL /**< Backward compatibility */
#define TS_MODE_INTERNAL VTSS_TS_MODE_INTERNAL /**< Backward compatibility */
#define TX_MODE_MAX      VTSS_TX_MODE_MAX      /**< Backward compatibility */

/** \brief Timestamp operation */
typedef struct vtss_ts_operation_mode_t {
    vtss_ts_mode_t mode;                /**< Hardware Timestamping mode for a port(EXTERNAL or INTERNAL) */
#if defined(VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5) || defined(VTSS_ARCH_LAN966X)
    u32            domain;              /**< Hardware timestamping domain for a port */
#endif
} vtss_ts_operation_mode_t;


/**
 * \brief Set the timestamping operation mode for a port.
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param mode [IN]             pointer to a struct holding the operation mode
 *
 * \return Return code.
 *
 * Serval:  Used to set backplane (INTERNAL) mode/normal(EXTERNAL) mode
 * Jaguar2: Used to set backplane (INTERNAL) mode/front(EXTERNAL) mode
 *          In backplane mode the internal format is determined by the internal mode (see below)
 * Other : Not used
 */
vtss_rc vtss_ts_operation_mode_set(const vtss_inst_t              inst,
                                   const vtss_port_no_t           port_no,
                                   const vtss_ts_operation_mode_t *const mode);

/**
 * \brief Get the timestamping operation mode for a port
 * \param inst [IN]             handle to an API instance
 * \param port_no [IN]          port number
 * \param mode [OUT]            pointer to a struct holding the operation mode
 *
 * \return Return code.
 */
vtss_rc vtss_ts_operation_mode_get(const vtss_inst_t              inst,
                                   const vtss_port_no_t           port_no,
                                   vtss_ts_operation_mode_t       *const mode);
                                   
/**
 * \brief parameter for setting the internal timestamp format
 */
typedef enum  {
    VTSS_TS_INTERNAL_FMT_NONE,
    VTSS_TS_INTERNAL_FMT_RESERVED_LEN_30BIT,        /* Ts is stored in reservedField as 30 bit (ns only) */
    VTSS_TS_INTERNAL_FMT_RESERVED_LEN_32BIT,        /* Ts is stored in reservedField as 32 bit (ns+sec*10^9) mod 2^32) */
    VTSS_TS_INTERNAL_FMT_SUB_ADD_LEN_44BIT_CF62,    /* Ts is subtracted from cf at ingress as 44 bit (ns+sec*10^9) mod 2^44), MSB is saved in cf bit 62 */
    VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_3_0, /* Ts is subtracted from cf at ingress as 48 bit (ns+sec*10^9) mod 2^48), MSBs are saved in cf bit 3-0 */
    VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_0,   /* Ts is subtracted from cf at ingress as 48 bit (ns+sec*10^9) mod 2^48), MSB is saved in cf bit 0 */
    VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF,     /* Ts is subtracted from cf at ingress as 48 bit (ns+sec*10^9) mod 2^48) */
    VTSS_TS_INTERNAL_FMT_MAX
} vtss_ts_internal_fmt_t;

#define TS_INTERNAL_FMT_NONE                      VTSS_TS_INTERNAL_FMT_NONE                      /**< Backward compatibility */
#define TS_INTERNAL_FMT_RESERVED_LEN_30BIT        VTSS_TS_INTERNAL_FMT_RESERVED_LEN_30BIT        /**< Backward compatibility */
#define TS_INTERNAL_FMT_RESERVED_LEN_32BIT        VTSS_TS_INTERNAL_FMT_RESERVED_LEN_32BIT        /**< Backward compatibility */
#define TS_INTERNAL_FMT_SUB_ADD_LEN_44BIT_CF62    VTSS_TS_INTERNAL_FMT_SUB_ADD_LEN_44BIT_CF62    /**< Backward compatibility */
#define TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_3_0 VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_3_0 /**< Backward compatibility */
#define TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_0   VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_0   /**< Backward compatibility */
#define TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF     VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF     /**< Backward compatibility */
#define TX_INTERNAL_FMT_MAX                       VTSS_TS_INTERNAL_FMT_MAX                       /**< Backward compatibility */

/** \brief Hardware timestamping format mode for internal ports */
typedef struct vtss_ts_internal_mode_t {
    vtss_ts_internal_fmt_t int_fmt;    /**< Hardware Timestamping format mode for INTERNAL ports */
} vtss_ts_internal_mode_t;


/**
 * \brief Set the internal timestamping mode.
 * \param inst [IN]             handle to an API instance
 * \param mode [IN]             pointer to a struct holding the operation mode
 *
 * \return Return code.
 *
 * Serval: Used to set INTERNAL mode timestamping format
 * Other : Not used
 */
vtss_rc vtss_ts_internal_mode_set(const vtss_inst_t              inst,
                                   const vtss_ts_internal_mode_t *const mode);

/**
 * \brief Get the internal timestamping mode.
 * \param inst [IN]             handle to an API instance
 * \param mode [OUT]            pointer to a struct holding the operation mode
 *
 * \return Return code.
 */
vtss_rc vtss_ts_internal_mode_get(const vtss_inst_t              inst,
                                  vtss_ts_internal_mode_t        *const mode);

/** \brief Timestamp identifier */
typedef struct vtss_ts_id_t {
    u32                 ts_id;  /**< Timestamp identifier */
} vtss_ts_id_t;

/** \brief Timestamp structure */
typedef struct vtss_ts_timestamp_t {
    u64 ts;                     /**< Timestamp value (tc in 16 bit fraction of nano seconds) */
    u32 id;                     /**< Timestamp identifier */
    void * context;             /**< Application specific context */
    BOOL ts_valid;              /**< Timestamp is valid (can be not valid if timestamp is not received */
} vtss_ts_timestamp_t;

/**
 * \brief Update the internal timestamp table, from HW
 * \param inst    [IN]          handle to an API instance
 *
 * \return Return code.
 */
vtss_rc vtss_tx_timestamp_update(const vtss_inst_t              inst);

/**
* \brief Get the rx FIFO timestamp for a {timestampId}
* Architecture:
*   Luton26
*
* \param inst    [IN]          handle to an API instance
* \param ts_id   [IN]          timestamp id
* \param ts     [OUT]          pointer to a struct holding the fifo timestamp
*
* \return Return code.
*/
vtss_rc vtss_rx_timestamp_get(const vtss_inst_t              inst,
                              const vtss_ts_id_t             *const ts_id,
                              vtss_ts_timestamp_t            *const ts);

/**
* \brief Get the rx FIFO timestamp for a {timestampId}
* Architecture:
*   Luton26
*
* \param inst    [IN]          handle to an API instance
* \param ts_id   [IN]          timestamp id
* \param ts     [OUT]          pointer to a struct holding the fifo timestamp
*
* \return Return code.
* 
* Note: This is the same function as vtss_rx_timestamp_get except for no
*       locking/unlocking of API critical region. This variant of the function
*       assumes that locking has already been done and that the function is
*       called from within another API function.
*/
vtss_rc _vtss_rx_timestamp_get(const vtss_inst_t              inst,
                               const vtss_ts_id_t             *const ts_id,
                               vtss_ts_timestamp_t            *const ts);

/**
* \brief Release the FIFO rx timestamp id 
* \param inst    [IN]          handle to an API instance
* \param ts_id   [IN]          timestamp id
*
* \return Return code.
*/
vtss_rc vtss_rx_timestamp_id_release(const vtss_inst_t              inst,
                                     const vtss_ts_id_t             *const ts_id);

/**
* \brief Get rx timestamp from a port (convert from slave time to the master time)
* Architecture:
*   Jaguar1
*
* \param inst    [IN]          handle to an API instance
* \param port_no [IN]          port number
* \param ts     [IN/OUT]       pointer to a struct holding the timestamp
*
* \return Return code.
*/
vtss_rc vtss_rx_master_timestamp_get(const vtss_inst_t              inst,
                                     const vtss_port_no_t           port_no,
                                     vtss_ts_timestamp_t            *const ts);

/** \brief Timestamp allocation callback */
typedef void (*vtss_ts_timestamp_alloc_cb_t)(void *context, u32 port_no,
                                             vtss_ts_timestamp_t *ts);

/** \brief Timestamp allocation */
typedef struct vtss_ts_timestamp_alloc_t {
    /** Identify the ports that a timestamp id is allocated to */
    uint64_t port_mask;

    /** Application specific context used as parameter in the call-out */
    void * context;

    /** Application call-out function called when the timestamp is available */
    vtss_ts_timestamp_alloc_cb_t cb;
} vtss_ts_timestamp_alloc_t;
/**
 * \brief Allocate a timestamp id for a two step transmission
 * \param inst       [IN]          handle to an API instance
 * \param alloc_parm [IN]          pointer allocation parameters
 * \param ts_id      [OUT]         timestamp id
 *
 * \return Return code.
 */
vtss_rc vtss_tx_timestamp_idx_alloc(const vtss_inst_t               inst,
                                    const vtss_ts_timestamp_alloc_t *const alloc_parm,
                                    vtss_ts_id_t                    *const ts_id);

/**
 * \brief Age the FIFO timestamps
 * \param inst    [IN]          handle to an API instance
 *
 * \return Return code.
 */
vtss_rc vtss_timestamp_age(const vtss_inst_t              inst);

/**
* \brief Signal port status change (used to detect and compensate for the internal ingress and egress latencies)
* \param inst    [IN]          handle to an API instance
* \param port_no [IN]          port number
*
* \return Return code.
*/
vtss_rc vtss_ts_status_change(const vtss_inst_t      inst,
                              const vtss_port_no_t   port_no);

#if defined (VTSS_FEATURE_DELAY_REQ_AUTO_RESP)
/**
 * \brief parameter for setting auto response behaviour pr domain
 */
typedef struct vtss_ts_autoresp_dom_cfg_s {
    BOOL                        ptp_port_individual;/**< TRUE => PortIdentity = ptp_port_msb || ptp_port_lsb, FALSE => PortIdentity = ptp_port_msb */
    u16                         ptp_port_msb;       /**< ptp port number most significant bits 15:6 */
    vtss_clock_identity         clock_identity;     /**< ptp clock identity */
    vtss_ace_u8_t               flag_field_update;  /**< flag field [0] update value and mask */

} vtss_ts_autoresp_dom_cfg_t;

/**
 * \brief Set auto response behaviour pr. domain.
 * \param inst    [IN]          handle to an API instance
 * \param domain  [IN]          ptp domain number [0..VTSS_TS_DOMAIN_ARRAY_SIZE-1]
 * \param cfg     [IN]          domain configuration for autoresponse feature
 *
 * \return Return code.
 */
vtss_rc vtss_ts_autoresp_dom_cfg_set(const vtss_inst_t                  inst,
                                     const u8                           domain,
                                     const vtss_ts_autoresp_dom_cfg_t   *const cfg);

/**
 * \brief Get auto response behaviour pr. domain.
 * \param inst    [IN]          handle to an API instance
 * \param domain  [IN]          ptp domain number [0..VTSS_TS_DOMAIN_ARRAY_SIZE-1]
 * \param cfg     [OUT]         domain configuration for autoresponse feature
 *
 * \return Return code.
 */
vtss_rc vtss_ts_autoresp_dom_cfg_get(const vtss_inst_t                  inst,
                                     const u8                           domain,
                                     vtss_ts_autoresp_dom_cfg_t         *const cfg);

/**
 * \brief Set the source mac address used in autp Delay_Req/Resp
 * \param inst    [IN]          handle to an API instance
 * \param port_no [IN]          port number
 * \param smac    [IN]          port mac configuration for autoresponse feature
 *
 * \return Return code.
 */
vtss_rc vtss_ts_smac_set(const vtss_inst_t    inst,
                         const vtss_port_no_t port_no,
                         const vtss_mac_t  *const smac);

/**
 * \brief Get the source mac address used in autp Delay_Req/Resp
 * \param inst    [IN]          handle to an API instance
 * \param port_no [IN]          port number
 * \param smac   [OUT]          port mac configuration for autoresponse feature
 *
 * \return Return code.
 */
vtss_rc vtss_ts_smac_get(const vtss_inst_t    inst,
                         const vtss_port_no_t port_no,
                         vtss_mac_t  *const smac);

#endif /* VTSS_FEATURE_DELAY_REQ_AUTO_RESP */

/**
 * \brief Read sequence counter from AFI.
 * \param inst     [IN]          handle to an API instance
 * \param sec_cntr [IN]          sequence counter number [0..255]
 * \param cnt_val  [OUT]         actual value of the sequence counter
 *
 * \return Return code.
 */
vtss_rc vtss_ts_seq_cnt_get(const vtss_inst_t                inst,
                            const u32                        sec_cntr,
                            u16 *const                       cnt_val);

#ifdef __cplusplus
}
#endif
#endif /* VTSS_FEATURE_TIMESTAMP */
#endif // _VTSS_TS_API_H_

// ***************************************************************************
//
//  End of file.
//
// ***************************************************************************
:@byteposi˛:	@str"#ifndef _VTSS_TS_API_H_
:@line_cacheo:Parslet::Source::LineCache:@line_endse:!Parslet::Source::RangeSearch[iPipiqiriviiñi‰i˘i˝i˛ii.i/iKiÖiÜi’iÿiÛiˆiEiFiji}iäiëiíi≈i‰i>iriïiúiºiiFiiipi¥iﬂii6iÜiæi≈i∆ii/iciÜiˇiOiViWiïiiyiÄiÅi°i‰i	i#	iB	iÑ	iº	i√	iƒ	i
iF
i~
iÖ
iÜ
iƒ
iiDi~i§i∆i iFiÄi¶i∆iiEi~i§i™i
i0ifiåiìiîi≤i˙i!i(i)iìi∫iªiøiıi(ibisi|iióiõi›i%i&i*imi†i∆i ii+i.iFiJiìiﬁi-i.i2ini°i€i1iBiKiNifiji¨iÌi4i5i9iui®iŒii^iaiyi}i∆iiYißi®i¨i›ii6iGiPiSikioiµi˛iˇii4igiçi≥i∂iŒi“iiniæiøi√ii9iÅiÑiúiüi∞i·iiCiLi‡i„i˚iˇiDiüi†i§iÿiiSidiqi~iªiƒiii&i*ioi iÀiœi i3 ie iû iÂ iˆ i)!i5!iÑ!i›!iE"iH"i`"id"i¶"iÌ"i5#i6#i:#iä#iÛ#ij$iú$i’$i%i-%i9%iâ%iå%i§%i®%iÍ%i1&iy&iz&i~&i &i‚&i'i:'is'i∫'iÀ'iÌ'i'i(i(i\(i¨(i˘(i+)i/)ix)i√)i*i`*ia*ie*i±*i…*i˚*i!+iZ+i°+i≤+i‘+i◊+iÔ+iÛ+i<,iá,i’,i$-i%-i)-is-i•-iﬁ-iÔ-i˜-i˙-i.i.ia.i≤.i≥.i∑.i/i3/il/i}/iÖ/ià/i†/i§/iÔ/i@0iA0iE0iè0i¡0iÁ0i 1i11i91i<1iT1iX1i£1i1iA2iB2iF2in2i°2i˛2i53i83iP3iT3iñ3iÿ3iŸ3i›3i4i4i54iÑ4i∫4iº4i”4i÷4i5ia5ib5if5iõ5i¨5i∆5iÊ5iÈ5i6iF6i•6i‹6iﬂ6i˜6i˚6iD7iè7iÿ7iŸ7i›7i8i 8i:8iZ8i]8ií8i∫8i9iR9iU9im9iq9i∫9i:iU:iV:iZ:i¥:i∂:iË:i7;iä;iå;i£;i¶;iË;i1<i2<iº<i¿<i˝<i=i4=i^=iï=iÀ=i>ir>ié>iè>iì>iﬁ>i·>i?it?iw?iè?iì?iŸ?i!@i"@i@@iD@iâ@iå@i∆@i˛@iAiAiAigAi∞Ai∑Ai∏AiºAiÔAiÚAi,BidBigBiBiÉBiÀBi%Ci&Ci*Ci]Ci≠Ci∞CiÍCi"Di%Di=DiADiâDi„Di‰DiËDi2EidEiùEi†Ei∏EiºEiFiLFiSFiTFiXFiëFiïFi•Fi—Fi¸Fi&GiWGivGiöGiõGiHièHi	IiÉIi˝Ii˛Ii1Ji[JiîJi—JiKi\KiïKi„Ki-Li~LiöLiõLiúLi†Li«LiMi3MiZMi]MióMiÃMiœMiÁMiÎMi5NiëNiíNiñNiΩNi˘Ni)OiPOiSOiçOi¬Oi≈Oi›Oi·Oi.PiçPiéPi$Qi(Qi^QioQi~QiÇQiíQi÷Qi-RiâRi˙RikSiáSi£Si§SiTixTi‚TiLUi∂Ui Vi!ViPViwVi”Vi.Wi≤WiÀWiÃWi–WiÙWiXiXiXiQXiêXiÃXiœXiÁXiÎXi2YiwYiÕYiŒYi“YiˆYiZiZiZiSZiíZiŒZi—ZiÈZiÌZi7[i[iÿ[iŸ[i›[i\i\i?\i~\iÕ\i]i"]i:]i>]ià]i–]i^io^ip^it^i¿^i√^i _iB_iæ_i¡_iŸ_i›_i"`ie`i¥`iª`iº`i¿`i¯`i˚`i5aizai}aiïaiôaiËai@biAbiEbihbi¢biŒbi	cici$ci(ciqciΩci di!di%diHdiÇdiÆdiÈdiÏdieieiQeiùei˘ei˙ei˛eifiUfiÅfiæfi¡fiŸfi›fi%gipgi≈gi∆gi giÁgi!hiMhiähiçhi•hi©hiÏhi2iiÇiiÉiiÑiiàii™ii‰iiji?jiBjiZji^ji§jiÌjiEkiFkiJkilki¶ki“kilili(li,lirliªlimimimi;miumi°minini/ni3niyni¬nioioi oiCoi}oi©oiÂoiËoi pipiJpiìpiÏpiÌpiÒpi.qi2qiBqiYqitqièqi§qi∂qi∑qiriSri°riÔririsi<si®siti[tibti~titiÄtiÑtiæti¯ti$uisuivuiéuiëuiŸui viÅviïviôvi·vi,wi|wi}wiÅwi∫wiÙwi xioxirxiäxiéxi÷xi!yiqyiïyiôyi◊yi€yiÎyi
zivziziã{i)|i√|iC}i`}iz}i{}i˚}i{~i˚~i{i˚i{Äi˚Äi{Åi|ÅiøÅiËÅiLÇigÇihÇiiÇimÇiõÇi’Çi$Éi'Éi?ÉiBÉi{ÉièÉiìÉi⁄Éi)Ñi*Ñi.Ñi\ÑiñÑiÂÑiËÑi ÖiÖiKÖiöÖiõÖiæÖi‹ÖiÜi)Üi*ÜiLÜiqÜi—ÜiáiSáiΩái‘ái’áiŸáiàiJàiMàieàiiài∞ài±àiµàiÏài¸àiâi
âiCâioâiΩâiøâi÷âiŸâiäigäi∞äi±äiµäiÏäi¸äiãi
ãiCãioãiΩãiøãi÷ãiŸãi"åiqåiΩåiÓåiÒåi5çiÅçiÀçiÃçi–çi˚çi4éi`éibéiyéi|éi∆éièièièiqèiÅèiçèièèi»èiÛèi<êi>êiUêiXêi¢êiÔêi?ëi@ëilëiµëi¸ëi˝ëi íiKíiçíi•íi¶íiíiìiìiUìizìióìiõìiŸìiîiWîiáîiäîi¢îi¶îiîiGïiöïiõïiüïi¡ïi˚ïi˛ïiñiñi[ñi\ñi`ñi—ñi
ói5ói7óiNóiQóiåóiÀóiÃói˚óiˇóiAòiEòiqòiôinôiΩôiöiöi=öi>öiBöitöiÆöiõiOõiRõijõinõiºõiúiaúibúifúiòúi“úi%ùisùivùiéùiíùi‡ùi0ûiÖûiÜûiäûiÀûiüi1üiÅüiÑüiúüi†üi‘üi†iD†iE†iI†iä†iƒ†i†i@°iC°i[°i_°iì°i °i˝°i˛°i,¢i-¢i1¢i[¢iñ¢iÿ¢i£i!£i9£i=£iÄ£i«£i§i§i"§i$§i+§iO§ii§ij§iπ§iº§iÕ§i–§i•:@last_line_endi•{;o;;o;	;
@
;i;"#define _VTSS_TS_API_H_

;@{;o;;o;	;
@
;i/;"!#include <vtss/api/types.h>
;@{;o;;o;	;
@
;iK;"@#include <vtss_security_api.h>    /* For vtss_ace_u8_t */

;@{;o;;o;	;
@
;iF;")#if defined(VTSS_FEATURE_TIMESTAMP)
;@{;o;;o;	;
@
;ij;"#ifdef __cplusplus
;@{:keywordo;;o;	;
@
;i};"extern;@:stringo;;o;	;
@
;iÑ;""C";@; [ò{;o;;o;	;
@
;iä;"#endif

;@{;o;;o;	;
@
;i≈;"$#if defined (VTSS_ARCH_OCELOT)
;@{;o;;o;	;
@
;i‰;"_#define VTSS_HW_TIME_CNT_PR_SEC 1000000000 /* Serval counts ns instead of clock cycles */
;@{;o;;o;	;
@
;ir;"(#define VTSS_HW_TIME_NSEC_PR_CNT 1
;@{;o;;o;	;
@
;iï;"#endif
;@{;o;;o;	;
@
;iú;"%#if defined (VTSS_ARCH_LUTON26)
;@{;o;;o;	;
@
;iº;"[#define VTSS_HW_TIME_CNT_PR_SEC 250000000 /* L26 counts clock cycles instead of ns */
;@{;o;;o;	;
@
;iF;"(#define VTSS_HW_TIME_NSEC_PR_CNT 4
;@{;o;;o;	;
@
;ii;"#endif
;@{;o;;o;	;
@
;ip;"I#if defined (VTSS_ARCH_LAN966X)  /* TBD. Check/set correct value */
;@{;o;;o;	;
@
;i¥;"0#define VTSS_HW_TIME_CNT_PR_SEC 1000000000
;@{;o;;o;	;
@
;i;"(#define VTSS_HW_TIME_NSEC_PR_CNT 1
;@{;o;;o;	;
@
;i6;"U#define VTSS_HW_TIME_WRAP_LIMIT  0       /* time counter wrap around limit+1 */
;@{;o;;o;	;
@
;iÜ;"=#define VTSS_HW_TIME_MIN_ADJ_RATE  10       /* 1 ppb */
;@{;o;;o;	;
@
;iæ;"#endif

;@{;o;;o;	;
@
;i∆;"C#if defined (VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5)
;@{;o;;o;	;
@
;i;"0#define VTSS_HW_TIME_CNT_PR_SEC 1000000000
;@{;o;;o;	;
@
;ic;"(#define VTSS_HW_TIME_NSEC_PR_CNT 1
;@{;o;;o;	;
@
;iˇ;"U#define VTSS_HW_TIME_WRAP_LIMIT  0       /* time counter wrap around limit+1 */
;@{;o;;o;	;
@
;iO;"#endif

;@{;o;;o;	;
@
;iW;"C#if defined (VTSS_ARCH_LUTON26) || defined (VTSS_ARCH_OCELOT)
;@{;o;;o;	;
@
;i;"p#define VTSS_HW_TIME_WRAP_LIMIT  0       /* time counter wrap around limit+1 (=0 if wrap at 0xffffffff) */
;@{;o;;o;	;
@
;iy;"#endif

;@{;o;;o;	;
@
;iÅ;"%#if defined (VTSS_ARCH_LUTON26)
;@{;o;;o;	;
@
;i‰;"=#define VTSS_HW_TIME_MIN_ADJ_RATE  40       /* 4 ppb */
;@{;o;;o;	;
@
;i	;"#endif
;@{;o;;o;	;
@
;i#	;"$#if defined (VTSS_ARCH_OCELOT)
;@{;o;;o;	;
@
;iÑ	;"=#define VTSS_HW_TIME_MIN_ADJ_RATE  10       /* 1 ppb */
;@{;o;;o;	;
@
;iº	;"#endif

;@{;o;;o;	;
@
;iƒ	;"C#if defined (VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5)
;@{;o;;o;	;
@
;iF
;"=#define VTSS_HW_TIME_MIN_ADJ_RATE  10       /* 1 ppb */
;@{;o;;o;	;
@
;i~
;"#endif

;@{;o;;o;	;
@
;iÜ
;"C#if defined (VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5)
;@{;o;;o;	;
@
;i;"+#define VTSS_TS_IO_ARRAY_SIZE       4
;@{;o;;o;	;
@
;i~;"+#define VTSS_TS_DOMAIN_ARRAY_SIZE   3
;@{;o;;o;	;
@
;i§;"'#elif defined (VTSS_ARCH_LAN966X)
;@{;o;;o;	;
@
;i ;"+#define VTSS_TS_IO_ARRAY_SIZE       7
;@{;o;;o;	;
@
;iÄ;"+#define VTSS_TS_DOMAIN_ARRAY_SIZE   3
;@{;o;;o;	;
@
;i¶;"%#elif defined(VTSS_ARCH_OCELOT)
;@{;o;;o;	;
@
;i;"+#define VTSS_TS_IO_ARRAY_SIZE       4
;@{;o;;o;	;
@
;i~;"+#define VTSS_TS_DOMAIN_ARRAY_SIZE   1
;@{;o;;o;	;
@
;i§;"#else
;@{;o;;o;	;
@
;i
;"+#define VTSS_TS_IO_ARRAY_SIZE       1
;@{;o;;o;	;
@
;if;"+#define VTSS_TS_DOMAIN_ARRAY_SIZE   1
;@{;o;;o;	;
@
;iå;"#endif

;@{;o;;o;	;
@
;iî;"##if defined(VTSS_ARCH_SPARX5)
;@{;o;;o;	;
@
;i˙;",#define VTSS_TS_RESP_CTRL_ARRAY_SIZE 4
;@{;o;;o;	;
@
;i!;"#endif

;@{;o;;o;	;
@
;iì;"-#define VTSS_HW_TIME_MAX_FINE_ADJ   25

;@{:func_proto{:normal{	:	typeo;;o;	;
@
;iõ;"vtss_rc ;@:	nameo;;o;	;
@
;i£;"vtss_ts_timeofday_set;@:
array[ :cap0:	args[{;{	;o;;o;	;
@
;iπ;"#const vtss_inst_t             ;@;o;;o;	;
@
;i◊;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i˚;"*const vtss_timestamp_t        *const ;@;o;;o;	;
@
;i ;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;iJ;"vtss_rc ;@;o;;o;	;
@
;iR;"!vtss_ts_domain_timeofday_set;@;[ ;0;[{;{	;o;;o;	;
@
;io;"#const vtss_inst_t             ;@;o;;o;	;
@
;iç;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i∏;"#const u32                     ;@;o;;o;	;
@
;i÷;"domain;@;[ ;0{;{	;o;;o;	;
@
;i;"*const vtss_timestamp_t        *const ;@;o;;o;	;
@
;i(;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;ij;"vtss_rc ;@;o;;o;	;
@
;ir;" vtss_ts_timeofday_set_delta;@;[ ;0;[{;{	;o;;o;	;
@
;ié;"const vtss_inst_t       ;@;o;;o;	;
@
;i¶;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i–;"const vtss_timestamp_t  *;@;o;;o;	;
@
;iÈ;"ts;@;[ ;0{;{	;o;;o;	;
@
;i;"BOOL                    ;@;o;;o;	;
@
;i);"negative;@;[ ;0;0{;{;{	;o;;o;	;
@
;i};"vtss_rc ;@;o;;o;	;
@
;iÖ;"'vtss_ts_domain_timeofday_set_delta;@;[ ;0;[	{;{	;o;;o;	;
@
;i®;"const vtss_inst_t       ;@;o;;o;	;
@
;i¿;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iÒ;"const u32               ;@;o;;o;	;
@
;i	;"domain;@;[ ;0{;{	;o;;o;	;
@
;i<;"const vtss_timestamp_t  *;@;o;;o;	;
@
;iU;"ts;@;[ ;0{;{	;o;;o;	;
@
;iÑ;"BOOL                    ;@;o;;o;	;
@
;iú;"negative;@;[ ;0;0{;{;{	;o;;o;	;
@
;io;"vtss_rc ;@;o;;o;	;
@
;iw;"!vtss_ts_timeofday_offset_set;@;[ ;0;[{;{	;o;;o;	;
@
;iî;" const vtss_inst_t          ;@;o;;o;	;
@
;iØ;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i⁄;" const i32                  ;@;o;;o;	;
@
;iı;"offset;@;[ ;0;0{;{;{	;o;;o;	;
@
;i“;"vtss_rc ;@;o;;o;	;
@
;i⁄;"(vtss_ts_domain_timeofday_offset_set;@;[ ;0;[{;{	;o;;o;	;
@
;i˛;" const vtss_inst_t          ;@;o;;o;	;
@
;i;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iK;" const u32                  ;@;o;;o;	;
@
;if;"domain;@;[ ;0{;{	;o;;o;	;
@
;iö;" const i32                  ;@;o;;o;	;
@
;iµ;"offset;@;[ ;0;0{;{;{	;o;;o;	;
@
;iˇ;"vtss_rc ;@;o;;o;	;
@
;i;"vtss_ts_adjtimer_one_sec;@;[ ;0;[{;{	;o;;o;	;
@
;i ;"#const vtss_inst_t             ;@;o;;o;	;
@
;i>;"	inst;@;[ ;0{;{	;o;;o;	;
@
;ie;"*BOOL                          *const ;@;o;;o;	;
@
;iä;"ongoing_adjustment;@;[ ;0;0{;{;{	;o;;o;	;
@
;i*;"vtss_rc ;@;o;;o;	;
@
;i2;"vtss_ts_ongoing_adjustment;@;[ ;0;[{;{	;o;;o;	;
@
;iM;"!const vtss_inst_t           ;@;o;;o;	;
@
;ii;"	inst;@;[ ;0{;{	;o;;o;	;
@
;ií;"(BOOL                        *const ;@;o;;o;	;
@
;iµ;"ongoing_adjustment;@;[ ;0;0{;{;{	;o;;o;	;
@
;id";"vtss_rc ;@;o;;o;	;
@
;il";"vtss_ts_timeofday_get;@;[ ;0;[{;{	;o;;o;	;
@
;iÇ";"#const vtss_inst_t             ;@;o;;o;	;
@
;i†";"	inst;@;[ ;0{;{	;o;;o;	;
@
;iƒ";"*vtss_timestamp_t              *const ;@;o;;o;	;
@
;iÈ";"ts;@;[ ;0{;{	;o;;o;	;
@
;i#;"*u64                           *const ;@;o;;o;	;
@
;i0#;"tc;@;[ ;0;0{;{;{	;o;;o;	;
@
;i®%;"vtss_rc ;@;o;;o;	;
@
;i∞%;"vtss_ts_timeofday_raw;@;[ ;0;[{;{	;o;;o;	;
@
;i∆%;"#const vtss_inst_t             ;@;o;;o;	;
@
;i‰%;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i&;"*vtss_timestamp_t              *const ;@;o;;o;	;
@
;i-&;"ts;@;[ ;0{;{	;o;;o;	;
@
;iO&;"*u64                           *const ;@;o;;o;	;
@
;it&;"tc;@;[ ;0;0{;{;{	;o;;o;	;
@
;i/);"vtss_rc ;@;o;;o;	;
@
;i7);""_vtss_ts_domain_timeofday_get;@;[ ;0;[	{;{	;o;;o;	;
@
;iU);""const vtss_inst_t            ;@;o;;o;	;
@
;ir);"	inst;@;[ ;0{;{	;o;;o;	;
@
;iù);"#const u32                     ;@;o;;o;	;
@
;iª);"domain;@;[ ;0{;{	;o;;o;	;
@
;iË);"*vtss_timestamp_t              *const ;@;o;;o;	;
@
;i*;"ts;@;[ ;0{;{	;o;;o;	;
@
;i6*;"*u64                           *const ;@;o;;o;	;
@
;i[*;"tc;@;[ ;0;0{;{;{	;o;;o;	;
@
;iÛ+;"vtss_rc ;@;o;;o;	;
@
;i˚+;"!vtss_ts_domain_timeofday_get;@;[ ;0;[	{;{	;o;;o;	;
@
;i,;"#const vtss_inst_t             ;@;o;;o;	;
@
;i6,;"	inst;@;[ ;0{;{	;o;;o;	;
@
;ia,;"#const u32                     ;@;o;;o;	;
@
;i,;"domain;@;[ ;0{;{	;o;;o;	;
@
;i¨,;"*vtss_timestamp_t              *const ;@;o;;o;	;
@
;i—,;"ts;@;[ ;0{;{	;o;;o;	;
@
;i˙,;"*u64                           *const ;@;o;;o;	;
@
;i-;"tc;@;[ ;0;0{;{;{	;o;;o;	;
@
;i.;"vtss_rc ;@;o;;o;	;
@
;i.;"#vtss_ts_timeofday_next_pps_get;@;[ ;0;[{;{	;o;;o;	;
@
;i=.;"#const vtss_inst_t             ;@;o;;o;	;
@
;i[.;"	inst;@;[ ;0{;{	;o;;o;	;
@
;ià.;"*vtss_timestamp_t              *const ;@;o;;o;	;
@
;i≠.;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;i§/;"vtss_rc ;@;o;;o;	;
@
;i¨/;"#vtss_ts_timeofday_prev_pps_get;@;[ ;0;[{;{	;o;;o;	;
@
;iÀ/;"#const vtss_inst_t             ;@;o;;o;	;
@
;iÈ/;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i0;"*vtss_timestamp_t              *const ;@;o;;o;	;
@
;i;0;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;iX1;"vtss_rc ;@;o;;o;	;
@
;i`1;"*vtss_ts_domain_timeofday_next_pps_get;@;[ ;0;[{;{	;o;;o;	;
@
;iÜ1;"const vtss_inst_t      ;@;o;;o;	;
@
;iù1;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i—1;"const u32              ;@;o;;o;	;
@
;iË1;"domain;@;[ ;0{;{	;o;;o;	;
@
;i2;"#vtss_timestamp_t       *const ;@;o;;o;	;
@
;i<2;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;iT3;"vtss_rc ;@;o;;o;	;
@
;i\3;"vtss_ts_adjtimer_set;@;[ ;0;[{;{	;o;;o;	;
@
;iq3;"$const vtss_inst_t              ;@;o;;o;	;
@
;iê3;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i≥3;"$const i32                      ;@;o;;o;	;
@
;i“3;"adj;@;[ ;0;0{;{;{	;o;;o;	;
@
;i÷4;"vtss_rc ;@;o;;o;	;
@
;iﬁ4;"vtss_ts_adjtimer_get;@;[ ;0;[{;{	;o;;o;	;
@
;iÛ4;"$const vtss_inst_t              ;@;o;;o;	;
@
;i5;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i55;"+i32                            *const ;@;o;;o;	;
@
;i[5;"adj;@;[ ;0;0{;{;{	;o;;o;	;
@
;i˚6;"vtss_rc ;@;o;;o;	;
@
;i7;" vtss_ts_domain_adjtimer_set;@;[ ;0;[{;{	;o;;o;	;
@
;i7;"$const vtss_inst_t              ;@;o;;o;	;
@
;i>7;"	inst;@;[ ;0{;{	;o;;o;	;
@
;ih7;"$const u32                      ;@;o;;o;	;
@
;iá7;"domain;@;[ ;0{;{	;o;;o;	;
@
;i≥7;"$const i32                      ;@;o;;o;	;
@
;i“7;"adj;@;[ ;0;0{;{;{	;o;;o;	;
@
;iq9;"vtss_rc ;@;o;;o;	;
@
;iy9;" vtss_ts_domain_adjtimer_get;@;[ ;0;[{;{	;o;;o;	;
@
;iï9;"$const vtss_inst_t              ;@;o;;o;	;
@
;i¥9;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iﬁ9;"$const u32                      ;@;o;;o;	;
@
;i˝9;"domain;@;[ ;0{;{	;o;;o;	;
@
;i):;"+i32                            *const ;@;o;;o;	;
@
;iO:;"adj;@;[ ;0;0{;{;{	;o;;o;	;
@
;i¶;;"vtss_rc ;@;o;;o;	;
@
;iÆ;;"vtss_ts_freq_offset_get;@;[ ;0;[{;{	;o;;o;	;
@
;i∆;;"!const vtss_inst_t           ;@;o;;o;	;
@
;i‚;;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i<;"(i32                         *const ;@;o;;o;	;
@
;i+<;"adj;@;[ ;0;0{;o;;o;	;
@
;i2<;"ä#if defined(VTSS_ARCH_OCELOT) || defined(VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5) || defined(VTSS_ARCH_LAN966X) /* TBD_henrikb */
;@{
;o;;o;	;
@
;i4=;"typedef;@:struct_type_declare{:struct_members[	{:member{;{	;o;;o;	;
@
;ib=;"
BOOL ;@;o;;o;	;
@
;ig=;"one_pps_out;@;[ ;0{;{;{	;o;;o;	;
@
;iô=;"
BOOL ;@;o;;o;	;
@
;iû=;"one_pps_in;@;[ ;0{;{;{	;o;;o;	;
@
;iœ=;"
BOOL ;@;o;;o;	;
@
;i‘=;"	save;@;[ ;0{;{;{	;o;;o;	;
@
;i >;"
BOOL ;@;o;;o;	;
@
;i%>;"	load;@;[ ;0:typedef_nameo;;o;	;
@
;it>;"vtss_ts_alt_clock_mode_t;@;[ ;0{;{;{	;o;;o;	;
@
;iì?;"vtss_rc ;@;o;;o;	;
@
;iõ?;" vtss_ts_alt_clock_saved_get;@;[ ;0;[{;{	;o;;o;	;
@
;i∑?;"!const vtss_inst_t           ;@;o;;o;	;
@
;i”?;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i˝?;"!u64    *const               ;@;o;;o;	;
@
;i@;"
saved;@;[ ;0;0{;o;;o;	;
@
;i"@;"##if defined(VTSS_ARCH_OCELOT)
;@{;{;{	;o;;o;	;
@
;iA;"vtss_rc ;@;o;;o;	;
@
;i%A;"*vtss_ts_alt_clock_saved_timeofday_get;@;[ ;0;[{;{	;o;;o;	;
@
;iKA;"const vtss_inst_t     ;@;o;;o;	;
@
;iaA;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iãA;"%vtss_timestamp_t  *const        ;@;o;;o;	;
@
;i´A;"ts;@;[ ;0;0{;o;;o;	;
@
;i∞A;"#endif

;@{;{;{	;o;;o;	;
@
;iÉB;"vtss_rc ;@;o;;o;	;
@
;iãB;"vtss_ts_alt_clock_mode_get;@;[ ;0;[{;{	;o;;o;	;
@
;i¶B;"$const vtss_inst_t              ;@;o;;o;	;
@
;i≈B;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iÓB;"+vtss_ts_alt_clock_mode_t       *const ;@;o;;o;	;
@
;iC;"alt_clock_mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;iAD;"vtss_rc ;@;o;;o;	;
@
;iID;"vtss_ts_alt_clock_mode_set;@;[ ;0;[{;{	;o;;o;	;
@
;idD;"$const vtss_inst_t              ;@;o;;o;	;
@
;iÉD;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i¨D;"+const vtss_ts_alt_clock_mode_t *const ;@;o;;o;	;
@
;i“D;"alt_clock_mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;iºE;"vtss_rc ;@;o;;o;	;
@
;iƒE;"#vtss_ts_timeofday_next_pps_set;@;[ ;0;[{;{	;o;;o;	;
@
;i„E;"const vtss_inst_t       ;@;o;;o;	;
@
;i˚E;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i(F;"$const vtss_timestamp_t  *const ;@;o;;o;	;
@
;iGF;"ts;@;[ ;0;0{;o;;o;	;
@
;iLF;"#endif

;@{
;o;;o;	;
@
;iïF;"typedef;@:enum_type_declare{;o;;o;	;
@
;iùF;"	enum;@:
enums[
{:	enum{:enum_nameo;;o;	;
@
;i©F;"+VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_DISABLE;@;0{;!{;"o;;o;	;
@
;i’F;"*VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT;@;0{;!{;"o;;o;	;
@
;i G;")VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_INPUT;@;0{;!{;"o;;o;	;
@
;i*G;"0VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT_INPUT;@;0{;!{;"o;;o;	;
@
;i[G;" VTSS_TS_EXT_CLOCK_MODE_MAX
;@;0;o;;o;	;
@
;ixG;"%vtss_ts_ext_clock_one_pps_mode_t;@;[ ;0{;o;;o;	;
@
;iõG;"#define TS_EXT_CLOCK_MODE_ONE_PPS_DISABLE      VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_DISABLE      /**< Backward compatibility */
;@{;o;;o;	;
@
;iH;"#define TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT       VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT       /**< Backward compatibility */
;@{;o;;o;	;
@
;ièH;"#define TS_EXT_CLOCK_MODE_ONE_PPS_INPUT        VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_INPUT        /**< Backward compatibility */
;@{;o;;o;	;
@
;i	I;"#define TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT_INPUT VTSS_TS_EXT_CLOCK_MODE_ONE_PPS_OUTPUT_INPUT /**< Backward compatibility */
;@{;o;;o;	;
@
;iÉI;"{#define TS_EXT_CLOCK_MODE_MAX                  VTSS_TS_EXT_CLOCK_MODE_MAX                  /**< Backward compatibility */

;@{
;o;;o;	;
@
;i1J;"typedef;@;{;[{;{;{	;o;;o;	;
@
;i_J;"(vtss_ts_ext_clock_one_pps_mode_t   ;@;o;;o;	;
@
;iÇJ;"one_pps_mode;@;[ ;0{;{;{	;o;;o;	;
@
;iôK;"
BOOL ;@;o;;o;	;
@
;iûK;"enable;@;[ ;0{;{;{	;o;;o;	;
@
;i1L;"
u32  ;@;o;;o;	;
@
;i6L;"	freq;@;[ ;0;o;;o;	;
@
;iÄL;"vtss_ts_ext_clock_mode_t;@;[ ;0{;{;{	;o;;o;	;
@
;iÎM;"vtss_rc ;@;o;;o;	;
@
;iÛM;"$vtss_ts_external_clock_mode_get;@;[ ;0;[{;{	;o;;o;	;
@
;iN;"!const vtss_inst_t           ;@;o;;o;	;
@
;i/N;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i]N;"(vtss_ts_ext_clock_mode_t    *const ;@;o;;o;	;
@
;iÄN;"ext_clock_mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;i·O;"vtss_rc ;@;o;;o;	;
@
;iÈO;"$vtss_ts_external_clock_mode_set;@;[ ;0;[{;{	;o;;o;	;
@
;i	P;"$const vtss_inst_t              ;@;o;;o;	;
@
;i(P;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iVP;"+const vtss_ts_ext_clock_mode_t *const ;@;o;;o;	;
@
;i|P;"ext_clock_mode;@;[ ;0;0{;o;;o;	;
@
;iéP;"ñ#if defined(VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5) || defined(VTSS_ARCH_LAN966X) || defined(VTSS_ARCH_LUTON26) || defined(VTSS_ARCH_OCELOT)
;@{
;o;;o;	;
@
;iÇQ;"typedef;@;{;o;;o;	;
@
;iäQ;"	enum;@; [{;!{;"o;;o;	;
@
;iñQ;"(VTSS_TS_EXT_IO_MODE_ONE_PPS_DISABLE;@;0{;!{;"o;;o;	;
@
;i⁄Q;"'VTSS_TS_EXT_IO_MODE_ONE_PPS_OUTPUT;@;0{;!{;"o;;o;	;
@
;i1R;"(VTSS_TS_EXT_IO_MODE_WAVEFORM_OUTPUT;@;0{;!{;"o;;o;	;
@
;içR;"%VTSS_TS_EXT_IO_MODE_ONE_PPS_LOAD;@;0{;!{;"o;;o;	;
@
;i˛R;"%VTSS_TS_EXT_IO_MODE_ONE_PPS_SAVE;@;0{;!{;"o;;o;	;
@
;ioS;"VTSS_TS_EXT_IO_MODE_MAX
;@;0;o;;o;	;
@
;iâS;"vtss_ts_ext_io_pin_cfg_t;@;[ ;0{;o;;o;	;
@
;i§S;"o#define TS_EXT_IO_MODE_ONE_PPS_DISABLE VTSS_TS_EXT_IO_MODE_ONE_PPS_DISABLE /**< Backward compatibility */
;@{;o;;o;	;
@
;iT;"o#define TS_EXT_IO_MODE_ONE_PPS_OUTPUT  VTSS_TS_EXT_IO_MODE_ONE_PPS_OUTPUT  /**< Backward compatibility */
;@{;o;;o;	;
@
;ixT;"o#define TS_EXT_IO_MODE_WAVEFORM_OUTPUT VTSS_TS_EXT_IO_MODE_WAVEFORM_OUTPUT /**< Backward compatibility */
;@{;o;;o;	;
@
;i‚T;"o#define TS_EXT_IO_MODE_ONE_PPS_LOAD    VTSS_TS_EXT_IO_MODE_ONE_PPS_LOAD    /**< Backward compatibility */
;@{;o;;o;	;
@
;iLU;"o#define TS_EXT_IO_MODE_ONE_PPS_SAVE    VTSS_TS_EXT_IO_MODE_ONE_PPS_SAVE    /**< Backward compatibility */
;@{;o;;o;	;
@
;i∂U;"p#define TS_EXT_IO_MODE_MAX             VTSS_TS_EXT_IO_MODE_MAX             /**< Backward compatibility */

;@{
;o;;o;	;
@
;iPV;"typedef;@;{;[{;{;{	;o;;o;	;
@
;i{V;"!vtss_ts_ext_io_pin_cfg_t    ;@;o;;o;	;
@
;ióV;"pin;@;[ ;0{;{;{	;o;;o;	;
@
;i◊V;"!u32                         ;@;o;;o;	;
@
;iÛV;"domain;@;[ ;0{;{;{	;o;;o;	;
@
;i2W;"!u32                         ;@;o;;o;	;
@
;iNW;"	freq;@;[ ;0;o;;o;	;
@
;i¥W;"vtss_ts_ext_io_mode_t;@;[ ;0{;{;{	;o;;o;	;
@
;iÎX;"vtss_rc ;@;o;;o;	;
@
;iÛX;"!vtss_ts_external_io_mode_get;@;[ ;0;[{;{	;o;;o;	;
@
;iY;"!const vtss_inst_t           ;@;o;;o;	;
@
;i,Y;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iWY;"!const u32                   ;@;o;;o;	;
@
;isY;"io;@;[ ;0{;{	;o;;o;	;
@
;iúY;"(vtss_ts_ext_io_mode_t       *const ;@;o;;o;	;
@
;iøY;"ext_io_mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;iÌZ;"vtss_rc ;@;o;;o;	;
@
;iıZ;"!vtss_ts_external_io_mode_set;@;[ ;0;[{;{	;o;;o;	;
@
;i[;"$const vtss_inst_t              ;@;o;;o;	;
@
;i1[;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i\[;"$const u32                      ;@;o;;o;	;
@
;i{[;"io;@;[ ;0{;{	;o;;o;	;
@
;i§[;"+const vtss_ts_ext_io_mode_t    *const ;@;o;;o;	;
@
;i [;"ext_io_mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;i>];"vtss_rc ;@;o;;o;	;
@
;iF];" vtss_ts_saved_timeofday_get;@;[ ;0;[	{;{	;o;;o;	;
@
;ib];"%const vtss_inst_t               ;@;o;;o;	;
@
;iÇ];"	inst;@;[ ;0{;{	;o;;o;	;
@
;i¨];"%const u32                       ;@;o;;o;	;
@
;iÃ];"io;@;[ ;0{;{	;o;;o;	;
@
;iÙ];",vtss_timestamp_t                *const ;@;o;;o;	;
@
;i^;"ts;@;[ ;0{;{	;o;;o;	;
@
;iC^;",u64                             *const ;@;o;;o;	;
@
;ij^;"tc;@;[ ;0;0{;{;{	;o;;o;	;
@
;i›_;"vtss_rc ;@;o;;o;	;
@
;iÂ_;")vtss_ts_output_clock_edge_offset_get;@;[ ;0;[{;{	;o;;o;	;
@
;i
`;"const vtss_inst_t ;@;o;;o;	;
@
;i`;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iO`;"const u32         ;@;o;;o;	;
@
;ia`;"io;@;[ ;0{;{	;o;;o;	;
@
;ií`;"u32               *const ;@;o;;o;	;
@
;i´`;"offset;@;[ ;0;0{;o;;o;	;
@
;i¥`;"#endif

;@{;{;{	;o;;o;	;
@
;iôa;"vtss_rc ;@;o;;o;	;
@
;i°a;"%vtss_ts_external_clock_saved_get;@;[ ;0;[{;{	;o;;o;	;
@
;i¬a;"%const vtss_inst_t               ;@;o;;o;	;
@
;i‚a;"	inst;@;[ ;0{;{	;o;;o;	;
@
;ib;",u32                             *const ;@;o;;o;	;
@
;i8b;"
saved;@;[ ;0;0{;{;{	;o;;o;	;
@
;i(c;"vtss_rc ;@;o;;o;	;
@
;i0c;" vtss_ts_ingress_latency_set;@;[ ;0;[{;{	;o;;o;	;
@
;iLc;"$const vtss_inst_t              ;@;o;;o;	;
@
;ikc;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iïc;"$const vtss_port_no_t           ;@;o;;o;	;
@
;i¥c;"port_no;@;[ ;0{;{	;o;;o;	;
@
;i·c;"2const vtss_timeinterval_t             *const ;@;o;;o;	;
@
;id;"ingress_latency;@;[ ;0;0{;{;{	;o;;o;	;
@
;ie;"vtss_rc ;@;o;;o;	;
@
;ie;" vtss_ts_ingress_latency_get;@;[ ;0;[{;{	;o;;o;	;
@
;i,e;"$const vtss_inst_t              ;@;o;;o;	;
@
;iKe;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iue;"$const vtss_port_no_t           ;@;o;;o;	;
@
;iîe;"port_no;@;[ ;0{;{	;o;;o;	;
@
;i¡e;"+vtss_timeinterval_t            *const ;@;o;;o;	;
@
;iÁe;"ingress_latency;@;[ ;0;0{;{;{	;o;;o;	;
@
;i›f;"vtss_rc ;@;o;;o;	;
@
;iÂf;"vtss_ts_p2p_delay_set;@;[ ;0;[{;{	;o;;o;	;
@
;i˚f;")const vtss_inst_t                   ;@;o;;o;	;
@
;ig;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iCg;")const vtss_port_no_t                ;@;o;;o;	;
@
;igg;"port_no;@;[ ;0{;{	;o;;o;	;
@
;iég;"0const vtss_timeinterval_t           *const ;@;o;;o;	;
@
;iπg;"p2p_delay;@;[ ;0;0{;{;{	;o;;o;	;
@
;i©h;"vtss_rc ;@;o;;o;	;
@
;i±h;"vtss_ts_p2p_delay_get;@;[ ;0;[{;{	;o;;o;	;
@
;i«h;"$const vtss_inst_t              ;@;o;;o;	;
@
;iÊh;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i
i;"$const vtss_port_no_t           ;@;o;;o;	;
@
;i)i;"port_no;@;[ ;0{;{	;o;;o;	;
@
;iPi;"+vtss_timeinterval_t            *const ;@;o;;o;	;
@
;ivi;"p2p_delay;@;[ ;0;0{;{;{	;o;;o;	;
@
;i^j;"vtss_rc ;@;o;;o;	;
@
;ifj;"vtss_ts_egress_latency_set;@;[ ;0;[{;{	;o;;o;	;
@
;iÅj;""const vtss_inst_t            ;@;o;;o;	;
@
;iûj;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i«j;""const vtss_port_no_t         ;@;o;;o;	;
@
;i‰j;"port_no;@;[ ;0{;{	;o;;o;	;
@
;ik;")const vtss_timeinterval_t    *const ;@;o;;o;	;
@
;i4k;"egress_latency;@;[ ;0;0{;{;{	;o;;o;	;
@
;i,l;"vtss_rc ;@;o;;o;	;
@
;i4l;"vtss_ts_egress_latency_get;@;[ ;0;[{;{	;o;;o;	;
@
;iOl;""const vtss_inst_t            ;@;o;;o;	;
@
;ill;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iïl;""const vtss_port_no_t         ;@;o;;o;	;
@
;i≤l;"port_no;@;[ ;0{;{	;o;;o;	;
@
;iﬁl;")vtss_timeinterval_t          *const ;@;o;;o;	;
@
;im;"egress_latency;@;[ ;0;0{;{;{	;o;;o;	;
@
;i3n;"vtss_rc ;@;o;;o;	;
@
;i;n;" vtss_ts_delay_asymmetry_set;@;[ ;0;[{;{	;o;;o;	;
@
;iWn;"!const vtss_inst_t           ;@;o;;o;	;
@
;isn;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iún;""const vtss_port_no_t         ;@;o;;o;	;
@
;iπn;"port_no;@;[ ;0{;{	;o;;o;	;
@
;iÂn;")const vtss_timeinterval_t    *const ;@;o;;o;	;
@
;i	o;"delay_asymmetry;@;[ ;0;0{;{;{	;o;;o;	;
@
;ip;"vtss_rc ;@;o;;o;	;
@
;ip;" vtss_ts_delay_asymmetry_get;@;[ ;0;[{;{	;o;;o;	;
@
;i(p;"!const vtss_inst_t           ;@;o;;o;	;
@
;iDp;"	inst;@;[ ;0{;{	;o;;o;	;
@
;imp;""const vtss_port_no_t         ;@;o;;o;	;
@
;iäp;"port_no;@;[ ;0{;{	;o;;o;	;
@
;i∂p;")vtss_timeinterval_t          *const ;@;o;;o;	;
@
;i⁄p;"delay_asymmetry;@;[ ;0;0{
;o;;o;	;
@
;i2q;"typedef;@;{;o;;o;	;
@
;i:q;"	enum;@; [	{;!{;"o;;o;	;
@
;iFq;"VTSS_TS_MODE_NONE;@;0{;!{;"o;;o;	;
@
;i]q;"VTSS_TS_MODE_EXTERNAL;@;0{;!{;"o;;o;	;
@
;ixq;"VTSS_TS_MODE_INTERNAL;@;0{;!{;"o;;o;	;
@
;iìq;"VTSS_TX_MODE_MAX
;@;0;o;;o;	;
@
;i¶q;"vtss_ts_mode_t;@;[ ;0{;o;;o;	;
@
;i∑q;"S#define TS_MODE_NONE     VTSS_TS_MODE_NONE     /**< Backward compatibility */
;@{;o;;o;	;
@
;ir;"S#define TS_MODE_EXTERNAL VTSS_TS_MODE_EXTERNAL /**< Backward compatibility */
;@{;o;;o;	;
@
;iSr;"S#define TS_MODE_INTERNAL VTSS_TS_MODE_INTERNAL /**< Backward compatibility */
;@{;o;;o;	;
@
;i°r;"T#define TX_MODE_MAX      VTSS_TX_MODE_MAX      /**< Backward compatibility */

;@{
;o;;o;	;
@
;is;"typedef;@;{;[	{;{;{	;o;;o;	;
@
;i@s;"vtss_ts_mode_t ;@;o;;o;	;
@
;iOs;"	mode;@;[ ;0{;o;;o;	;
@
;i®s;"`#if defined(VTSS_ARCH_JAGUAR_2) || defined(VTSS_ARCH_SPARX5) || defined(VTSS_ARCH_LAN966X)
;@{;{;{	;o;;o;	;
@
;it;"u32            ;@;o;;o;	;
@
;it;"domain;@;[ ;0{;o;;o;	;
@
;i[t;"#endif
;@;o;;o;	;
@
;idt;"vtss_ts_operation_mode_t;@;[ ;0{;{;{	;o;;o;	;
@
;iôv;"vtss_rc ;@;o;;o;	;
@
;i°v;"vtss_ts_operation_mode_set;@;[ ;0;[{;{	;o;;o;	;
@
;iºv;"$const vtss_inst_t              ;@;o;;o;	;
@
;i€v;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iw;"$const vtss_port_no_t           ;@;o;;o;	;
@
;i#w;"port_no;@;[ ;0{;{	;o;;o;	;
@
;iOw;"+const vtss_ts_operation_mode_t *const ;@;o;;o;	;
@
;iuw;"	mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;iéx;"vtss_rc ;@;o;;o;	;
@
;iñx;"vtss_ts_operation_mode_get;@;[ ;0;[{;{	;o;;o;	;
@
;i±x;"$const vtss_inst_t              ;@;o;;o;	;
@
;i–x;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i˘x;"$const vtss_port_no_t           ;@;o;;o;	;
@
;iy;"port_no;@;[ ;0{;{	;o;;o;	;
@
;iDy;"+vtss_ts_operation_mode_t       *const ;@;o;;o;	;
@
;ijy;"	mode;@;[ ;0;0{
;o;;o;	;
@
;i€y;"typedef;@;{;o;;o;	;
@
;i„y;"	enum;@; [{;!{;"o;;o;	;
@
;iÔy;"VTSS_TS_INTERNAL_FMT_NONE;@;0{;!{;"o;;o;	;
@
;iz;",VTSS_TS_INTERNAL_FMT_RESERVED_LEN_30BIT;@;0{;!{;"o;;o;	;
@
;izz;",VTSS_TS_INTERNAL_FMT_RESERVED_LEN_32BIT;@;0{;!{;"o;;o;	;
@
;iÙz;"0VTSS_TS_INTERNAL_FMT_SUB_ADD_LEN_44BIT_CF62;@;0{;!{;"o;;o;	;
@
;iè{;"3VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_3_0;@;0{;!{;"o;;o;	;
@
;i-|;"1VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_0;@;0{;!{;"o;;o;	;
@
;i«|;"/VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF;@;0{;!{;"o;;o;	;
@
;iG};"VTSS_TS_INTERNAL_FMT_MAX
;@;0;o;;o;	;
@
;ib};"vtss_ts_internal_fmt_t;@;[ ;0{;o;;o;	;
@
;i{};"Ä#define TS_INTERNAL_FMT_NONE                      VTSS_TS_INTERNAL_FMT_NONE                      /**< Backward compatibility */
;@{;o;;o;	;
@
;i˚};"Ä#define TS_INTERNAL_FMT_RESERVED_LEN_30BIT        VTSS_TS_INTERNAL_FMT_RESERVED_LEN_30BIT        /**< Backward compatibility */
;@{;o;;o;	;
@
;i{~;"Ä#define TS_INTERNAL_FMT_RESERVED_LEN_32BIT        VTSS_TS_INTERNAL_FMT_RESERVED_LEN_32BIT        /**< Backward compatibility */
;@{;o;;o;	;
@
;i˚~;"Ä#define TS_INTERNAL_FMT_SUB_ADD_LEN_44BIT_CF62    VTSS_TS_INTERNAL_FMT_SUB_ADD_LEN_44BIT_CF62    /**< Backward compatibility */
;@{;o;;o;	;
@
;i{;"Ä#define TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_3_0 VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_3_0 /**< Backward compatibility */
;@{;o;;o;	;
@
;i˚;"Ä#define TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_0   VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF_0   /**< Backward compatibility */
;@{;o;;o;	;
@
;i{Ä;"Ä#define TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF     VTSS_TS_INTERNAL_FMT_RESERVED_LEN_48BIT_CF     /**< Backward compatibility */
;@{;o;;o;	;
@
;i˚Ä;"Å#define TX_INTERNAL_FMT_MAX                       VTSS_TS_INTERNAL_FMT_MAX                       /**< Backward compatibility */

;@{
;o;;o;	;
@
;iøÅ;"typedef;@;{;[{;{;{	;o;;o;	;
@
;iÏÅ;"vtss_ts_internal_fmt_t ;@;o;;o;	;
@
;iÇ;"int_fmt;@;[ ;0;o;;o;	;
@
;iNÇ;"vtss_ts_internal_mode_t;@;[ ;0{;{;{	;o;;o;	;
@
;iìÉ;"vtss_rc ;@;o;;o;	;
@
;iõÉ;"vtss_ts_internal_mode_set;@;[ ;0;[{;{	;o;;o;	;
@
;iµÉ;"$const vtss_inst_t              ;@;o;;o;	;
@
;i‘É;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i˝É;"*const vtss_ts_internal_mode_t *const ;@;o;;o;	;
@
;i"Ñ;"	mode;@;[ ;0;0{;{;{	;o;;o;	;
@
;iÖ;"vtss_rc ;@;o;;o;	;
@
;iÖ;"vtss_ts_internal_mode_get;@;[ ;0;[{;{	;o;;o;	;
@
;i&Ö;"$const vtss_inst_t              ;@;o;;o;	;
@
;iEÖ;"	inst;@;[ ;0{;{	;o;;o;	;
@
;imÖ;"+vtss_ts_internal_mode_t        *const ;@;o;;o;	;
@
;iìÖ;"	mode;@;[ ;0;0{
;o;;o;	;
@
;iæÖ;"typedef;@;{;[{;{;{	;o;;o;	;
@
;i‡Ö;"u32                 ;@;o;;o;	;
@
;iÙÖ;"
ts_id;@;[ ;0;o;;o;	;
@
;iÜ;"vtss_ts_id_t;@;[ ;0{
;o;;o;	;
@
;iLÜ;"typedef;@;{;[	{;{;{	;o;;o;	;
@
;iuÜ;"	u64 ;@;o;;o;	;
@
;iyÜ;"ts;@;[ ;0{;{;{	;o;;o;	;
@
;i’Ü;"	u32 ;@;o;;o;	;
@
;iŸÜ;"id;@;[ ;0{;{;{	;o;;o;	;
@
;iá;"void * ;@;o;;o;	;
@
;iá;"context;@;[ ;0{;{;{	;o;;o;	;
@
;iWá;"
BOOL ;@;o;;o;	;
@
;i\á;"ts_valid;@;[ ;0;o;;o;	;
@
;iøá;"vtss_ts_timestamp_t;@;[ ;0{;{;{	;o;;o;	;
@
;iià;"vtss_rc ;@;o;;o;	;
@
;iqà;"vtss_tx_timestamp_update;@;[ ;0;[{;{	;o;;o;	;
@
;iäà;"$const vtss_inst_t              ;@;o;;o;	;
@
;i©à;"	inst;@;[ ;0;0{;{;{	;o;;o;	;
@
;iŸâ;"vtss_rc ;@;o;;o;	;
@
;i·â;"vtss_rx_timestamp_get;@;[ ;0;[{;{	;o;;o;	;
@
;i˜â;"$const vtss_inst_t              ;@;o;;o;	;
@
;iä;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i:ä;"+const vtss_ts_id_t             *const ;@;o;;o;	;
@
;i`ä;"
ts_id;@;[ ;0{;{	;o;;o;	;
@
;iÖä;"+vtss_ts_timestamp_t            *const ;@;o;;o;	;
@
;i´ä;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;iÒå;"vtss_rc ;@;o;;o;	;
@
;i˘å;"_vtss_rx_timestamp_get;@;[ ;0;[{;{	;o;;o;	;
@
;iç;"$const vtss_inst_t              ;@;o;;o;	;
@
;i/ç;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iTç;"+const vtss_ts_id_t             *const ;@;o;;o;	;
@
;izç;"
ts_id;@;[ ;0{;{	;o;;o;	;
@
;i†ç;"+vtss_ts_timestamp_t            *const ;@;o;;o;	;
@
;i∆ç;"ts;@;[ ;0;0{;{;{	;o;;o;	;
@
;i|é;"vtss_rc ;@;o;;o;	;
@
;iÑé;"!vtss_rx_timestamp_id_release;@;[ ;0;[{;{	;o;;o;	;
@
;i°é;"$const vtss_inst_t              ;@;o;;o;	;
@
;i¿é;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iÎé;"+const vtss_ts_id_t             *const ;@;o;;o;	;
@
;iè;"
ts_id;@;[ ;0;0{;{;{	;o;;o;	;
@
;iXê;"vtss_rc ;@;o;;o;	;
@
;i`ê;"!vtss_rx_master_timestamp_get;@;[ ;0;[{;{	;o;;o;	;
@
;i}ê;"$const vtss_inst_t              ;@;o;;o;	;
@
;iúê;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i«ê;"$const vtss_port_no_t           ;@;o;;o;	;
@
;iÊê;"port_no;@;[ ;0{;{	;o;;o;	;
@
;ië;"+vtss_ts_timestamp_t            *const ;@;o;;o;	;
@
;i:ë;"ts;@;[ ;0;0{;o;;o;	;
@
;ilë;"typedef;@:typedef_fptr{	:return_typeo;;o;	;
@
;itë;"
void ;@:fptr_nameo;;o;	;
@
;i{ë;"!vtss_ts_timestamp_alloc_cb_t;@;[{;{	;o;;o;	;
@
;iôë;"void *;@;o;;o;	;
@
;iüë;"context;@;[ ;0{;{	;o;;o;	;
@
;i®ë;"	u32 ;@;o;;o;	;
@
;i¨ë;"port_no;@;[ ;0{;{	;o;;o;	;
@
;i‚ë;"vtss_ts_timestamp_t *;@;o;;o;	;
@
;i˜ë;"ts;@;[ ;0;0{
;o;;o;	;
@
;i í;"typedef;@;{;[{;{;{	;o;;o;	;
@
;iëí;"uint64_t ;@;o;;o;	;
@
;iöí;"port_mask;@;[ ;0{;{;{	;o;;o;	;
@
;iÙí;"void * ;@;o;;o;	;
@
;i˚í;"context;@;[ ;0{;{;{	;o;;o;	;
@
;iYì;""vtss_ts_timestamp_alloc_cb_t ;@;o;;o;	;
@
;ivì;"cb;@;[ ;0;o;;o;	;
@
;i|ì;"vtss_ts_timestamp_alloc_t;@;[ ;0{;{;{	;o;;o;	;
@
;i¶î;"vtss_rc ;@;o;;o;	;
@
;iÆî;" vtss_tx_timestamp_idx_alloc;@;[ ;0;[{;{	;o;;o;	;
@
;i î;"%const vtss_inst_t               ;@;o;;o;	;
@
;iÍî;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iï;",const vtss_ts_timestamp_alloc_t *const ;@;o;;o;	;
@
;i;ï;"alloc_parm;@;[ ;0{;{	;o;;o;	;
@
;ikï;",vtss_ts_id_t                    *const ;@;o;;o;	;
@
;iíï;"
ts_id;@;[ ;0;0{;{;{	;o;;o;	;
@
;iñ;"vtss_rc ;@;o;;o;	;
@
;i"ñ;"vtss_timestamp_age;@;[ ;0;[{;{	;o;;o;	;
@
;i5ñ;"$const vtss_inst_t              ;@;o;;o;	;
@
;iTñ;"	inst;@;[ ;0;0{;{;{	;o;;o;	;
@
;iQó;"vtss_rc ;@;o;;o;	;
@
;iYó;"vtss_ts_status_change;@;[ ;0;[{;{	;o;;o;	;
@
;ioó;"const vtss_inst_t      ;@;o;;o;	;
@
;iÜó;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i™ó;"const vtss_port_no_t   ;@;o;;o;	;
@
;i¡ó;"port_no;@;[ ;0;0{;o;;o;	;
@
;iÃó;"4#if defined (VTSS_FEATURE_DELAY_REQ_AUTO_RESP)
;@{
;o;;o;	;
@
;iEò;"typedef;@;{;[	{;{;{	;o;;o;	;
@
;iuò;"!BOOL                        ;@;o;;o;	;
@
;iëò;"ptp_port_individual;@;[ ;0{;{;{	;o;;o;	;
@
;iô;"!u16                         ;@;o;;o;	;
@
;i'ô;"ptp_port_msb;@;[ ;0{;{;{	;o;;o;	;
@
;irô;"!vtss_clock_identity         ;@;o;;o;	;
@
;iéô;"clock_identity;@;[ ;0{;{;{	;o;;o;	;
@
;i¡ô;"!vtss_ace_u8_t               ;@;o;;o;	;
@
;i›ô;"flag_field_update;@;[ ;0;o;;o;	;
@
;i!ö;"vtss_ts_autoresp_dom_cfg_t;@;[ ;0{;{;{	;o;;o;	;
@
;inõ;"vtss_rc ;@;o;;o;	;
@
;ivõ;"!vtss_ts_autoresp_dom_cfg_set;@;[ ;0;[{;{	;o;;o;	;
@
;iìõ;"(const vtss_inst_t                  ;@;o;;o;	;
@
;i∂õ;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i·õ;"(const u8                           ;@;o;;o;	;
@
;iú;"domain;@;[ ;0{;{	;o;;o;	;
@
;i1ú;"/const vtss_ts_autoresp_dom_cfg_t   *const ;@;o;;o;	;
@
;i[ú;"cfg;@;[ ;0;0{;{;{	;o;;o;	;
@
;iíù;"vtss_rc ;@;o;;o;	;
@
;iöù;"!vtss_ts_autoresp_dom_cfg_get;@;[ ;0;[{;{	;o;;o;	;
@
;i∑ù;"(const vtss_inst_t                  ;@;o;;o;	;
@
;i⁄ù;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iû;"(const u8                           ;@;o;;o;	;
@
;i(û;"domain;@;[ ;0{;{	;o;;o;	;
@
;iUû;"/vtss_ts_autoresp_dom_cfg_t         *const ;@;o;;o;	;
@
;iû;"cfg;@;[ ;0;0{;{;{	;o;;o;	;
@
;i†ü;"vtss_rc ;@;o;;o;	;
@
;i®ü;"vtss_ts_smac_set;@;[ ;0;[{;{	;o;;o;	;
@
;iπü;"const vtss_inst_t    ;@;o;;o;	;
@
;iŒü;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iÌü;"const vtss_port_no_t ;@;o;;o;	;
@
;i†;"port_no;@;[ ;0{;{	;o;;o;	;
@
;i$†;"const vtss_mac_t  *const ;@;o;;o;	;
@
;i=†;"	smac;@;[ ;0;0{;{;{	;o;;o;	;
@
;i_°;"vtss_rc ;@;o;;o;	;
@
;ig°;"vtss_ts_smac_get;@;[ ;0;[{;{	;o;;o;	;
@
;ix°;"const vtss_inst_t    ;@;o;;o;	;
@
;iç°;"	inst;@;[ ;0{;{	;o;;o;	;
@
;i¨°;"const vtss_port_no_t ;@;o;;o;	;
@
;i¡°;"port_no;@;[ ;0{;{	;o;;o;	;
@
;i„°;"vtss_mac_t  *const ;@;o;;o;	;
@
;iˆ°;"	smac;@;[ ;0;0{;o;;o;	;
@
;i˛°;"4#endif /* VTSS_FEATURE_DELAY_REQ_AUTO_RESP */

;@{;{;{	;o;;o;	;
@
;i=£;"vtss_rc ;@;o;;o;	;
@
;iE£;"vtss_ts_seq_cnt_get;@;[ ;0;[{;{	;o;;o;	;
@
;iY£;"&const vtss_inst_t                ;@;o;;o;	;
@
;iz£;"	inst;@;[ ;0{;{	;o;;o;	;
@
;iú£;"&const u32                        ;@;o;;o;	;
@
;iΩ£;"sec_cntr;@;[ ;0{;{	;o;;o;	;
@
;i„£;"&u16 *const                       ;@;o;;o;	;
@
;i§;"cnt_val;@;[ ;0;0{;o;;o;	;
@
;i§;"#ifdef __cplusplus
;@{;o;;o;	;
@
;i$§;"#endif
;@{;o;;o;	;
@
;i+§;")#endif /* VTSS_FEATURE_TIMESTAMP */
;@{;o;;o;	;
@
;iO§;" #endif // _VTSS_TS_API_H_

;@