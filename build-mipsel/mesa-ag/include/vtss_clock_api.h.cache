{:	root[{:ppo:Parslet::Slice:@positiono:Parslet::Position:@string"´// Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT


/**
 * \file
 * \brief Clock API.
 * \details This header file describes Vitesse DPLL API functions and
 * associated types.
 */

#ifndef _VTSS_CLOCK_API_H_
#define _VTSS_CLOCK_API_H_

#include <vtss/api/types.h>

#if defined(VTSS_FEATURE_CLOCK)
#ifdef __cplusplus
extern "C" {
#endif

// ***************************************************************************
//
//  DPLL interface
//
// ***************************************************************************

/**
 * \brief clock global enable state. Will switch off system clock for omega IP if false
 **/
typedef BOOL vtss_clock_global_enable_t;

/**
 * \brief parameter describing the DPLL instance.
 *  In ES6514 Instance A = 0, Instance B = 1.
 **/
typedef u8 vtss_clock_dpll_inst_t;

/**
 * \brief parameter describing the DPLL selection mode.
 **/
typedef enum
{
    VTSS_CLOCK_SELECTION_MODE_DISABLED,                 /**< Controller / DPLL is disabled */
    VTSS_CLOCK_SELECTION_MODE_MANUEL,                   /**< Manually select an input */
    VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_NONREVERTIVE,   /**< Automatic selection mode non revertive */
    VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_REVERTIVE,      /**< Automatic selection mode revertive */
    VTSS_CLOCK_SELECTION_MODE_FORCED_HOLDOVER,          /**< Manually selection mode forced to holdover */
    VTSS_CLOCK_SELECTION_MODE_FORCED_FREE_RUN,          /**< Manually selection mode forced to free-run */
    VTSS_CLOCK_SELECTION_MODE_FORCED_DCO,               /**< Selection mode Digitally Controlled Oscillator (DCO) */
} vtss_clock_selection_mode_t;

/**
 * \brief parameter setting up the DPLL selection mode.
 **/
typedef struct {
    vtss_clock_selection_mode_t mode;           /**< selection mode */
    u8                          clock_input;    /**< selected input id manual mode */
} vtss_clock_selection_conf_t;


/**
 * \brief parameter describing the DPLL selectior state.
 **/
typedef enum
{
    VTSS_CLOCK_SELECTOR_STATE_LOCKED,       /**< the dpll is locked to an input */
    VTSS_CLOCK_SELECTOR_STATE_HOLDOVER,     /**< the dpll is in holdover state */
    VTSS_CLOCK_SELECTOR_STATE_FREERUN,      /**< the dpll is in free-run state */
    VTSS_CLOCK_SELECTOR_STATE_DCO,          /**< the dpll is controlled by SW (DCO mode) */
    VTSS_CLOCK_SELECTOR_STATE_REF_FAILED,   /**< the selected reference failed */
    VTSS_CLOCK_SELECTOR_STATE_ACQUIRING,    /**< acquiring lock to the selected reference */
} vtss_clock_selector_state_t;

/**
 * \brief parameter describing the DPLL operation mode.
 **/
typedef enum
{
    VTSS_CLOCK_OPERATION_MODE_DISABLED,  /**< the dpll is DISABLED */
    VTSS_CLOCK_OPERATION_MODE_ENABLED,   /**< the dpll is ENABLED */
} vtss_clock_operation_mode_t;

//typedef enum
//{
//    VTSS_CLOCK_FILTER_BW_1MILLI_HZ, /**< the dpll filter bandwidth is 1 milli Hz */
//    VTSS_CLOCK_FILTER_BW_0_1_Hz,    /**< the dpll filter bandwidth is 0.1 Hz */
//    VTSS_CLOCK_FILTER_BW_5_HZ,      /**< the dpll filter bandwidth is 5 Hz */
//} vtss_clock_filter_bw_t;


/**
 * \brief parameter for setting up the phase slope limiter.
 */
typedef struct vtss_clock_psl_conf_t {
    u32                         limit_ppb;            /**< maximum phase slope in ppb [1..524000], 0 Disables the feature */
    BOOL                        phase_build_out_ena;  /**< If true, limited phase information is dismissed */
    BOOL                        ho_based;             /**< If true, slope limit is with respect to frequency offset stored in holdover stack*/
} vtss_clock_psl_conf_t;
  
/**
 * \brief parameter for setting the dpll configuration.
 */
typedef struct vtss_clock_dpll_conf_t {
    vtss_clock_operation_mode_t mode;       /**< clock operation mode. Enable / Disable */
    u16                         holdoff;    /**< holdoff time in ms (0 => holdoff disabled); the actual holdoff is in steps of 1 ms; i.e. values are trunkated to 1 ms multipla HW: 16 bit*/
    u32                         holdover;   /**< holdover time in ms [0..84600]       HW:17 bit*/
    u16                         wtr;        /**< wait-to-restore time in sec [0..720] HW:10 bit*/
} vtss_clock_dpll_conf_t;

/**
 * \brief parameter for setting the holdover stack configuration.
 */
typedef struct vtss_clock_ho_stack_conf_t {
    u32  ho_post_filtering_bw;    /**< holdover stack post filtering bandwidth im mHz [23 ... 1.46e9] es6514: Bugzilla #15547 [741 ... 1.46e9]*/
    u8   ho_qual_time_conf;       /**< holdover qulification time configuration. time in s = 2^ho_qual_time_conf conf. range: [0..11] => time: [1..2048]s */
} vtss_clock_ho_stack_conf_t;

#define VTSS_CLOCK_HO_STACK_SIZE 12 /**< Size of the holdover stack */
/**
 * \brief parameter for getting the holdover stack content.
 */
typedef struct vtss_clock_ho_stack_content_t {
    u64     stack_value[VTSS_CLOCK_HO_STACK_SIZE];        /**< HO-stack read data got all 12 stack levels (HO values in scaled PPB's) */
    u8      ho_sel;                 /**< Select ho-value to take in hold-over state. */
    u8      ho_min_fill_lvl;        /**< Minimum fill level before ho-stack considered full */
    BOOL    ho_filled;              /**< TRUE if stack is full */
} vtss_clock_ho_stack_content_t;

/**
 * \brief parameter for setting the priority for dpll source selection
 */
typedef struct vtss_clock_priority_selector_t {
    u8   priority;          /**< Priority - 0 is highest */
    BOOL enable;            /**< Enable for the respective priority */
} vtss_clock_priority_selector_t;

/**
 * \brief parameter for defining a ratio when selecting a frequency that is a rational number
 */
typedef struct vtss_clock_ratio_t {
    u32  num;               /**< numerator of a rational value */
    u32  den;               /**< denominator of a rational value */
} vtss_clock_ratio_t;

/**
 * \brief parameter for selecting the type of the clock input
 */
typedef enum
{
    VTSS_CLOCK_INPUT_TYPE_DPLL,     /**< a dpll output is selected as output */
    VTSS_CLOCK_INPUT_TYPE_IN,       /**< a input signal is directly selected as output */
    VTSS_CLOCK_INPUT_TYPE_PURE_DCO, /**< output is running purely on LC-PLL plus optional DCO */
} vtss_clock_input_type_t;

/**
 * \brief parameter for setting the clock output selector.
 */
typedef struct vtss_clock_input_selector_t {
    vtss_clock_input_type_t input_type;     /**< Defines if it is clock input or a DPLL outpus that drives the clock output */
    u8                      input_inst;     /**< defines the clock input or DPLL instance */
} vtss_clock_input_selector_t;

/**
 * \brief parameter for returning the dpll state.
 */
typedef struct vtss_clock_dpll_state_t {
    BOOL pll_freq_lock;     /**< PLL is stabilized to the selected frequency */
    BOOL pll_phase_lock;    /**< PLL is phase locked to incoming clock */
    BOOL pll_losx;          /**< PLL the currently selected reference input fails */
    BOOL pll_lol;           /**< PLL loss of lock */
    BOOL pll_dig_hold_vld;  /**< PLL Hold-over stack is filled with enough samples*/
} vtss_clock_dpll_state_t;

/**
 * \brief parameter for returning the clock input state.
 */
typedef struct vtss_clock_input_state_t {
    BOOL los;    /**< External Loss Of Signal */
    BOOL pfm;    /**< Precise frequency out of range */
    BOOL cfm;    /**< Coarse frequency out of range */
    BOOL scm;    /**< Single Cycle missed */
    BOOL lol;    /**< Loss of Lock */
} vtss_clock_input_state_t;

/**
 * \brief parameter for setting the alarm enables which control the input selection
 */
typedef struct vtss_clock_input_alarm_ena_t {
  BOOL los;   /**< Set to TRUE when Loss Of Signal alarm should influence the source selection */
  BOOL pfm;   /**< Set to TRUE when Precise frequency monitor alarm should influence the source selection */
  BOOL cfm;   /**< Set to TRUE when Coarse frequency monitor alarm should influence the source selection */
  BOOL scm;   /**< Set to TRUE when Single Cycle monitor alarm should influence the source selection */
  BOOL gst;   /**< Set to TRUE when Guard Soak timer alarm should influence the source selection */
  BOOL lol;   /**< Set to TRUE when Loss of Lock alarm should influence the source selection */
} vtss_clock_input_alarm_ena_t;

/**
 * \brief parameter for setting input selection parameters
 */
typedef struct vtss_clock_input_conf_t {
  BOOL                         los_active_high; /**< Set to TRUE when Loss Of Signal input is active high.*/
  vtss_clock_input_alarm_ena_t alarm_ena;       /**< Collection of alarm enables */
} vtss_clock_input_conf_t;

/**
 * \brief parameter for setting up the Coarse Frequency Monitor (CFM)
 */
typedef struct vtss_clock_cfm_conf_t {
  u32 cfm_set_ppb;      /**< Maximum frequency offset in ppb detected by the CFM before CFM alarm is issued. [0..200000] */
  u32 cfm_clr_ppb;      /**< Minimum frequency offset in ppb detected by the CFM before CFM alarm is cleared. [0..200000] */
} vtss_clock_cfm_conf_t;

/**
 * \brief parameter for setting up the Precise Frequency Monitor (PFM)
 */
typedef struct vtss_clock_pfm_conf_t {
  u32 pfm_set_ppb;      /**< Maximum frequency offset in ppb detected by the PFM before PFM alarm is issued. [0..200000] */
  u32 pfm_clr_ppb;      /**< Minimum frequency offset in ppb detected by the PFM before PFM alarm is cleared. [0..200000] */
} vtss_clock_pfm_conf_t;

/**
 * \brief parameter for setting up the GST
 */
typedef struct vtss_clock_gst_conf_t {
  u32 disqualification_time_us; /**< Disqualification time in micro seconds [1 us .. 1500s] */
  u32 qualification_time_us;    /**< Qualification time in micro seconds    [1 us .. 1500s] */
                                /**< 1/255 <= (diqualification_time_us/qualification_time_us) <= 255 */
  BOOL los;   /**< Set to TRUE when Loss Of Signal alarm should be source for GST */
  BOOL pfm;   /**< Set to TRUE when Precise frequency monitor alarm should be source for GST */
  BOOL cfm;   /**< Set to TRUE when Coarse frequency monitor alarm should be source for GST */
  BOOL scm;   /**< Set to TRUE when Single Cycle monitor alarm should be source for GST */
  BOOL lol;   /**< Set to TRUE when Loss of Lock alarm should be source for GST */
} vtss_clock_gst_conf_t;

// ***************************************************************************
//
//  Direct register access functions to be used for testing
//
// ***************************************************************************

/**
 * \brief Directly read from a HW register
 * \param inst [IN]         Handle to an API instance.
 * \param addr [IN]         Address
 * \param value [OUT]       Read value
 *
 * \return Return code.
 */
vtss_rc vtss_clock_rd(const vtss_inst_t  inst,
                      const u32          addr,
                      u32                *const value);

/**
 * \brief Directly write to a HW register
 * \param inst [IN]         Handle to an API instance.
 * \param addr [IN]         Address
 * \param value [IN]        Write value
 *
 * \return Return code.
 */
vtss_rc vtss_clock_wr(const vtss_inst_t  inst,
                      const u32          addr,
                      const u32          value);

/**
 * \brief Directly write to field(s) of a HW register (Read-Modify-Write)
 * \param inst [IN]         Handle to an API instance.
 * \param addr [IN]         Address
 * \param value [IN]        Write value
 * \param mask [IN]         Mask value, defines which bits can be changed
 *
 * \return Return code.
 */
vtss_rc vtss_clock_wrm(const vtss_inst_t  inst,
                       const u32          addr,
                       const u32          value,
                       const u32          mask);

// ***************************************************************************
//
//  Configuration API
//
// ***************************************************************************


/**
 * \brief Set global enable state
 * \param inst [IN]        Handle to an API instance.
 * \param ena [IN]         Enable/Disable flag
 *
 * \return Return code.
 */
vtss_rc vtss_clock_global_enable_set(const vtss_inst_t                 inst,
                                     const vtss_clock_global_enable_t  ena);

/**
 * \brief Get global enable state
 * \param inst [IN]        Handle to an API instance.
 * \param ena [OUT]        Enable/Disable flag
 *
 * \return Return code.
 */
vtss_rc vtss_clock_global_enable_get(const vtss_inst_t                inst,
                                     vtss_clock_global_enable_t       *ena);

/**
 * \brief Global SW Reset for the clock. Resets logic but not the configuration
 * \param inst [IN]        Handle to an API instance.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_global_sw_reset(const vtss_inst_t                 inst);

/**
 * \brief Shut down the clock HW. Called before a sw reset. Sets the Internal core clock back to default
 * \param inst [IN]        Handle to an API instance.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_shutdown(const vtss_inst_t                 inst);

/**
 * \brief Set Clock selection mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         Mode of clock selection and selected Clock input in manual mode [0..x].
 *
 * \return Return code.
 */
vtss_rc vtss_clock_selection_mode_set(const vtss_inst_t                 inst,
                                      const vtss_clock_dpll_inst_t      dpll,
                                      const vtss_clock_selection_conf_t *const conf);

/**
 * \brief Get Clock selection mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [OUT]        Mode of clock selection and selected Clock input in manual mode [0..x].
 *
 * \return Return code.
 */
vtss_rc vtss_clock_selection_mode_get(const vtss_inst_t             inst,
                                      const vtss_clock_dpll_inst_t  dpll,
                                      vtss_clock_selection_conf_t   *const conf);

/**
 * \brief Set Clock operation mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         Mode of clock operation.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_operation_conf_set(const vtss_inst_t                 inst,
                                      const vtss_clock_dpll_inst_t      dpll,
                                      const vtss_clock_dpll_conf_t      *const conf);

/**
 * \brief Get Clock operation mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [OUT]        Mode of clock operation.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_operation_conf_get(const vtss_inst_t             inst,
                                      const vtss_clock_dpll_inst_t  dpll,
                                      vtss_clock_dpll_conf_t        *const conf);

/**
 * \brief Set Holdover stack configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         configuration values
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_conf_set(const vtss_inst_t                 inst,
                                     const vtss_clock_dpll_inst_t      dpll,
                                     const vtss_clock_ho_stack_conf_t  *const conf);

/**
 * \brief Get Holdover stack configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         configuration values
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_conf_get(const vtss_inst_t                 inst,
                                     const vtss_clock_dpll_inst_t      dpll,
                                     vtss_clock_ho_stack_conf_t        *const conf);

/**
 * \brief Get Holdover stack content (for debug purpose)
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param cont [IN]         Ho stack content
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_content_get(const vtss_inst_t                 inst,
                                        const vtss_clock_dpll_inst_t      dpll,
                                        vtss_clock_ho_stack_content_t     *const cont);
/**
 * \brief Set Clock dpll frequency adjustment in DCO mode (directly influence the controller).
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param offset [IN]       Clock ratio frequency offset in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_dco_frequency_offset_set(const vtss_inst_t               inst,
                                            const vtss_clock_dpll_inst_t    dpll,
                                            const i64                       offset);

/**
 * \brief Get Clock dpll frequency adjustment in DCO mode (directly influence the controller).
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param offset [OUT]      Clock ratio frequency offset in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_dco_frequency_offset_get(const vtss_inst_t               inst,
                                            const vtss_clock_dpll_inst_t    dpll,
                                            i64                             *const offset);

/**
 * \brief Set Output Filter Bandwidth.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param bw_100uhz [IN]    Filtering bandwidth in untis of 100uHz the lowest limit is 300 uHz
 *                          A value of 0 disables the filter (Power down).
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_bw_set(const vtss_inst_t                  inst,
                                        const u8                           clock_output,
                                        const u32                          bw_100uhz);

/**
 * \brief Get Output Filter Bandwidth.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param bw_100uhz [OUT]   Filtering bandwidth in untis of 100uHz
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_bw_get(const vtss_inst_t                  inst,
                                        const u8                           clock_output,
                                        u32                                *bw_100uhz);

/**
 * \brief Trigger Output Filter to immediately lock to current frequency offset without low-pass filtering
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_lock_fast_set(const vtss_inst_t                  inst,
                                               const u8                           clock_output);

/**
 * \brief Check if fast lock has completed.
 * \param inst [IN]             Handle to an API instance.
 * \param clock_output [IN]     Clock output port number
 * \param lock_completed [OUT]  fast lock has completed
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_lock_fast_get(const vtss_inst_t                  inst,
                                               const u8                           clock_output,
                                               BOOL                               *lock_completed);
/**
 * \brief Set Output Filter Phase Slope Limiter (PSL) configuration
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param conf [IN]         configuration values
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_psl_conf_set(const vtss_inst_t                  inst,
                                       const u8                           clock_output,
                                       const vtss_clock_psl_conf_t        *const conf);

/**
 * \brief Get Output Filter Phase Slope Limiter (PSL) configuration
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param conf [OUT]        Filtering bandwidth in untis of 100uHz
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_psl_conf_get(const vtss_inst_t                  inst,
                                       const u8                           clock_output,
                                       vtss_clock_psl_conf_t              *const conf);

/**
 * \brief Set Clock dpll frequency adjustment (influence the respective output filter).
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param adj [IN]          Clock ratio frequency offset in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_frequency_set(const vtss_inst_t               inst,
                                     const u8                        clock_output,
                                     const i64                       adj);

/**
 * \brief Get Clock dpll frequency adjustment (influence the respective output filter).
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param adj [OUT]         Clock ratio frequency offset in units of scaled ppb (parts pr billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_frequency_get(const vtss_inst_t               inst,
                                     const u8                        clock_output,
                                     i64                             *const adj);

/**
 * \brief Set Clock dpll phase adjustment.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port mask, i.e. setting bit x enables phase adjustment on output x
 * \param adj [IN]          Clock phase offset in units of scaled ns i.e. ns*2**-16.
 *                          ratio > 0 => clock phase is advanced.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_phase_set(const vtss_inst_t               inst,
                                 const u8                        clock_output,
                                 const i32                       adj);

/**
 * \brief Get Clock dpll phase adjustment.
 * \param inst [IN]         Handle to an API instance.
 * \param adj_ongoing [OUT] TRUE if the phase adjust is ongoing, FALSE otherwise.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_phase_get(const vtss_inst_t               inst,
                                 BOOL                            *const adj_ongoing);

/**
 * \brief Set Clock input priority.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         configuration values, Priority - 0 is highest priority 
 *
 * \return Return code.
 */
vtss_rc vtss_clock_priority_set(const vtss_inst_t                     inst,
                                const vtss_clock_dpll_inst_t          dpll,
                                const u8                              clock_input,
                                const vtss_clock_priority_selector_t  *const conf);

/**
 * \brief Get Clock input priority.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param clock_input [IN]  Clock input port number
 * \param conf [OUT]        configuration values, Priority - 0 is highest priority 
 *
 * \return Return code.
 */
vtss_rc vtss_clock_priority_get(const vtss_inst_t               inst,
                                const vtss_clock_dpll_inst_t    dpll,
                                const u8                        clock_input,
                                vtss_clock_priority_selector_t  *const conf);

/**
 * \brief Set Clock input frequency.
 * \param inst [IN]                   Handle to an API instance.
 * \param clock_input [IN]            Clock input port number
 * \param freq_khz [IN]               frequency in KHz, the frequency is rounded to the closest multiple of 8 KHz.
 *                                    freq_khz < 8 => clock input qualifier is disabled
 * \param use_internal_clock_src [IN] If TRUE, select an internally provided clock as source
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_set(const vtss_inst_t               inst,
                                       const u8                        clock_input,
                                       const u32                       freq_khz,
                                       const BOOL                      use_internal_clock_src);

/**
 * \brief Get Clock input frequency.
 * \param inst [IN]                    Handle to an API instance.
 * \param clock_input [IN]             Clock input port number
 * \param freq_khz [OUT]               frequency in KHz, freq_khz < 8 => clock input qualifier is disabled
 * \param use_internal_clock_src [OUT] An internally provided clock is used as source, if TRUE
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_get(const vtss_inst_t               inst,
                                       const u8                        clock_input,
                                       u32                             *const freq_khz,
                                       BOOL                            *const use_internal_clock_src);

/**
 * \brief Set Clock input frequency with ratio.
 * \param inst [IN]                   Handle to an API instance.
 * \param clock_input [IN]            Clock input port number
 * \param freq_khz [IN]               frequency in KHz, the frequency is rounded to the closest multiple of 8 KHz.
 *                                    freq_khz < 8 => clock input qualifier is disabled
 * \param ratio [IN]                  A ratio the freq_khz will be mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 * \param use_internal_clock_src [IN] If TRUE, select an internally provided clock as source
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_ratio_set(const vtss_inst_t               inst,
                                             const u8                        clock_input,
                                             const u32                       freq_khz,
                                             const vtss_clock_ratio_t        *const ratio,
                                             const BOOL                      use_internal_clock_src);

/**
 * \brief Get Clock input frequency with ratio.
 * \param inst [IN]                    Handle to an API instance.
 * \param clock_input [IN]             Clock input port number
 * \param freq_khz [OUT]               frequency in KHz, freq_khz < 8 => clock input qualifier is disabled
 * \param ratio [OUT]                  A ratio the freq_khz was mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 * \param use_internal_clock_src [OUT] An internally provided clock is used as source, if TRUE
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_ratio_get(const vtss_inst_t               inst,
                                             const u8                        clock_input,
                                             u32                             *const freq_khz,
                                             vtss_clock_ratio_t              *const ratio,
                                             BOOL                            *const use_internal_clock_src);

/**
 * \brief Set Clock output frequency.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param freq_khz [IN]     frequency in KHz.
 *                          freq_khz = 0 disables the clock
 * \param par_freq_khz [IN] parallel frequency in KHz. With parallel frequency the clock output of the
 *                          DF2F for the parallel data towards the core is ment.
 *                          Maximum parallel frequency is 400 MHz, minimum parallel frequency is 31.25 MHz.
 *                          Higher frequencies provide better jitter performance.
 *                          par_freq_khz = 0 disables the clock
 *
 *                          Note: Only one of the clocks can be active. Either freq_khz or par_freq_khz must be 0.
 *                          For selected frequencies there is a possibility that both clocks can be used.
 *                          The possible combinations can be looked up in DS1009-DPLL-Freq-Calc.xlsm and implemented on request.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_set(const vtss_inst_t               inst,
                                        const u8                        clock_output,
                                        const u32                       freq_khz,
                                        const u32                       par_freq_khz);

/**
 * \brief Get Clock output frequency.
 * \param inst [IN]          Handle to an API instance.
 * \param clock_output [IN]  Clock output port number
 * \param freq_khz [OUT]     frequency in KHz, freq_khz = 0, clock is disbaled
 * \param par_freq_khz [OUT] parallel frequency in KHz, par_freq_khz = 0, clock is disbaled
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_get(const vtss_inst_t               inst,
                                        const u8                        clock_output,
                                        u32                             *const freq_khz,
                                        u32                             *const par_freq_khz);

/**
 * \brief Set Clock output frequency.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param freq_khz [IN]     frequency in KHz.
 *                          freq_khz = 0 disables the clock
 * \param par_freq_khz [IN] parallel frequency in KHz. With parallel frequency the clock output of the
 *                          DF2F for the parallel data towards the core is ment.
 *                          Maximum parallel frequency is 400 MHz, minimum parallel frequency is 31.25 MHz.
 *                          Higher frequencies provide better jitter performance.
 *                          par_freq_khz = 0 disables the clock
 *
 *                          Note: Only one of the clocks can be active. Either freq_khz or par_freq_khz must be 0.
 *                          For selected frequencies there is a possibility that both clocks can be used.
 *                          The possible combinations can be looked up in DS1009-DPLL-Freq-Calc.xlsm and implemented on request.
 * \param ratio [IN]        A ratio the freq_khz will be mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_ratio_set(const vtss_inst_t               inst,
                                              const u8                        clock_output,
                                              const u32                       freq_khz,
                                              const u32                       par_freq_khz,
                                              const vtss_clock_ratio_t        *const ratio);

/**
 * \brief Get Clock output frequency.
 * \param inst [IN]          Handle to an API instance.
 * \param clock_output [IN]  Clock output port number
 * \param freq_khz [OUT]     frequency in KHz, freq_khz = 0, clock is disbaled
 * \param par_freq_khz [OUT] parallel frequency in KHz, par_freq_khz = 0, clock is disbaled
 * \param ratio [OUT]        A ratio the freq_khz was mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_ratio_get(const vtss_inst_t               inst,
                                              const u8                        clock_output,
                                              u32                             *const freq_khz,
                                              u32                             *const par_freq_khz,
                                              vtss_clock_ratio_t              *const ratio);

/**
 * \brief Set Clock output Voltage level.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param level_mv [IN]     Output Voltage in mV range [300..1275], 25 mV steps [Output level of es6514 is limited due to bug in a coil in the OB]
 *                          
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_level_set(const vtss_inst_t               inst,
                                    const u8                        clock_output,
                                    const u16                       level_mv);

/**
 * \brief Get Clock output Voltage level.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param level_mv [OUT]    Output Voltage in mV range [300..1275], 25 mV steps
 *                          
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_level_get(const vtss_inst_t               inst,
                                    const u8                        clock_output,
                                    u16                             *const level_mv);

/**
 * \brief Set Clock output selector.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param input [IN]     input selector.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_selector_set(const vtss_inst_t               inst,
                                       const u8                        clock_output,
                                       const vtss_clock_input_selector_t *const input);

/**
 * \brief Get Clock output selector.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param input [OUT]       input selector.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_selector_get(const vtss_inst_t               inst,
                                       const u8                        clock_output,
                                       vtss_clock_input_selector_t     *const input);

/**
 * \brief Set Clock input alarm configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Alarm enable for various qualifier arlarms and LOS active level
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_alarm_conf_set(const vtss_inst_t               inst,
                                        const u8                        clock_input,
                                        const vtss_clock_input_conf_t   *const conf);

/**
 * \brief Get Clock input alarm configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [OUT]        Alarm enable for various qualifier arlarms and LOS active level
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_alarm_conf_get(const vtss_inst_t               inst,
                                        const u8                        clock_input,
                                        vtss_clock_input_conf_t         *const conf);

/**
 * \brief Set Clock input Coarse Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Coarse Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_cfm_conf_set(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      const vtss_clock_cfm_conf_t  *const conf);

/**
 * \brief Get Clock input Coarse Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Coarse Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_cfm_conf_get(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      vtss_clock_cfm_conf_t        *const conf);

/**
 * \brief Set Clock input Precise Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Precise Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_pfm_conf_set(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      const vtss_clock_pfm_conf_t  *const conf);

/**
 * \brief Get Clock input Precise Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Precise Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_pfm_conf_get(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      vtss_clock_pfm_conf_t        *const conf);
/**
 * \brief Set Clock input guard soak timer configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Guard Soak Timer Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_gst_conf_set(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      const vtss_clock_gst_conf_t  *const conf);

/**
 * \brief Get Clock input guard soak timer configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [OUT]        Guard Soak Timer Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_gst_conf_get(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      vtss_clock_gst_conf_t        *const conf);

// ***************************************************************************
//
//  Status API
//
// ***************************************************************************

/**
 * \brief get Clock selector state.
 * \param inst [IN]             Handle to an API instance.
 * \param dpll [IN]             DPLL instance number [0..x].
 * \param selector_state [OUT]  selector state
 * \param clock_input [OUT]     Clock input port number - if in locked state
 *
 * \return Return code.
 */
vtss_rc vtss_clock_selector_state_get(const vtss_inst_t             inst,
                                      const vtss_clock_dpll_inst_t  dpll,
                                      vtss_clock_selector_state_t   *const selector_state,
                                      u8                            *const clock_input);

/**
 * \brief get Clock pll state.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param pll_state [OUT]   pll state
 *
 * \return Return code.
 */
vtss_rc vtss_clock_dpll_state_get(const vtss_inst_t             inst,
                                  const vtss_clock_dpll_inst_t  dpll,
                                  vtss_clock_dpll_state_t       *const pll_state);

/**
 * \brief get Clock frequency offset stored in ho stack
 * \param inst [IN]       Handle to an API instance.
 * \param dpll [IN]       DPLL instance number [0..x].
 * \param offset [OUT]    Current frequency offset stored in the holdover stack in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_frequency_offset_get(const vtss_inst_t             inst,
                                                 const vtss_clock_dpll_inst_t  dpll,
                                                 i64                           *const offset);

/**
 * \brief get Clock input state.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param input_state [OUT] input state
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_state_get(const vtss_inst_t            inst,
                                  const u8                      clock_input,
                                  vtss_clock_input_state_t      *const input_state);

// ***************************************************************************
//
//  Event (interrupt) handling API
//
// ***************************************************************************

/**
 * \brief Define event (interrupt) types related to the Vitesse Synce Clock inputs.
 **/
#define VTSS_CLOCK_INPUT_LOS_EV     (1 << 0)  /**< External Loss Of Signal event */
#define VTSS_CLOCK_INPUT_PFM_EV     (1 << 1)  /**< Precise frequency monitor event */
#define VTSS_CLOCK_INPUT_CFM_EV     (1 << 2)  /**< Coarse frequency monitor event */
#define VTSS_CLOCK_INPUT_SCM_EV     (1 << 3)  /**< Single Cycle monitor event */
#define VTSS_CLOCK_INPUT_GST_EV     (1 << 4)  /**< Guard Soak timer event */
#define VTSS_CLOCK_INPUT_LOL_EV     (1 << 5)  /**< Loss of Lock event */
typedef u32 vtss_clock_input_event_type_t; /**< Int events: Single event or 'OR' multiple events above */

/**
 * \brief Clock input event polling function called by interrupt or periodicly
 *
 * \param inst        [IN]  Target instance reference.
 * \param clock_input [IN]  Clock input port number
 * \param ev_mask     [OUT] Event type mask of active events
 *
 * \note The \e ev_mask parameter can be either a single event_type or
 * multiple event types. If invoked by a
 * processor interrupt signal, the type of event to check for may be
 * narrowed in to specific events.
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_input_event_poll(const vtss_inst_t               inst,
                                    const u8                        clock_input,
                                    vtss_clock_input_event_type_t   *const ev_mask);

/**
 * \brief Enable clock input event generation for a specific event type
 *
 * \param inst        [IN]  Target instance reference.
 * \param clock_input [IN]  Clock input port number
 * \param ev_mask     [IN]  Event type(s) to control (mask)
 * \param enable      [IN]  Enable or disable events
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_input_event_enable(const vtss_inst_t                     inst,
                                      const u8                              clock_input,
                                      const vtss_clock_input_event_type_t   ev_mask,
                                      const BOOL                            enable);

/**
 * \brief Define event (interrupt) types related to the Vitesse Synce Clock dpll's.
 *
 **/
//    VTSS_CLOCK_DPLL_FREQ_LOCK_EV =      (1 << 0), /**< Loss Of Frequency lock event */
//    VTSS_CLOCK_DPLL_PH_LOCK_EV   =      (1 << 1), /**< Loss Of Phase lock event */
//    VTSS_CLOCK_DPLL_LOSX         =      (1 << 2), /**< PLL the currently selected reference input fails event */
//    VTSS_CLOCK_DPLL_LOL          =      (1 << 3), /**< PLL loss of lock event */
#define VTSS_CLOCK_DPLL_STATE_CHANGE_EV   (1 << 0) /**< State change event in EEC FSM */
typedef u32 vtss_clock_dpll_event_type_t; /**< Int events: Currently only Single event */

/**
 * \brief Clock dpll event polling function called by interrupt or periodicly
 *
 * \param inst        [IN]  Target instance reference.
 * \param dpll        [IN]  DPLL instance number [0..x].
 * \param ev_mask     [OUT] Event type mask of active events
 *
 * \note The \e ev_mask parameter can be either a single event_type or
 * multiple event types. If invoked by a
 * processor interrupt signal, the type of event to check for may be
 * narrowed in to specific events.
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_dpll_event_poll(const vtss_inst_t              inst,
                                   const vtss_clock_dpll_inst_t   dpll,
                                   vtss_clock_dpll_event_type_t   *const ev_mask);

/**
 * \brief Enable clock dpll event generation for a specific event type
 *
 * \param inst        [IN]  Target instance reference.
 * \param dpll        [IN]  DPLL instance number [0..x].
 * \param ev_mask     [IN]  Event type(s) to control (mask)
 * \param enable      [IN]  Enable or disable events
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_dpll_event_enable(const vtss_inst_t                  inst,
                                     const vtss_clock_dpll_inst_t       dpll,
                                     const vtss_clock_dpll_event_type_t ev_mask,
                                     const BOOL                         enable);

#ifdef __cplusplus
}
#endif
#endif /* VTSS_FEATURE_OMEGA */
#endif // _VTSS_CLOCK_API_H_


// ***************************************************************************
//
//  End of file.
//
// ***************************************************************************
:@byteposiï:	@str" #ifndef _VTSS_CLOCK_API_H_
:@line_cacheo:Parslet::Source::LineCache:@line_endse:!Parslet::Source::RangeSearch[iPipiqiriviiiÕiêiîiïi
i%i&iBiCiciviiiiÚiÝiðióiBiCiGii¤iÍiÎiÒii2i7iZi[i_iii©i«i	ibiÉi,iiiwiiiiÓiØiéi0ii¥i¦i§i«iäiéiöiøiKiiïiK	i	iú	i
i
i
iV
i[
ih
ij
i°
iõ
iii$i(i~iÐi i<i=i>iBi~ii©i&ii#i<i?iCi{ii§ii¿i!iiii¢iäièii¥iBi`iai¨i¬ièiìii¤iüi[ii¾i¿iÃi
ii>iziÁiãiäièiFiJini°iôi
iiiMiQi^i`i°i
ikiiiiÆiÊi÷iviÓiòiói÷i)i-iVi¦iðiEiziÏiêiëiïi(i,iVii¿iöi#iIieifiji¾iÂiðiRi¿i+ii÷iW iw ix i| i· i» iä iQ!i¥!iÀ!iÁ!iÅ!i"i"i6"i²"i/#iH#iI#iM#i#i#i¿#i;$i¸$iÑ$iÒ$iÖ$i%i%i,%i%iê%iR&i§&i'if'iÁ'i(i-(i.(i}(i(i¼(i¿(i)i)i)i>)iu)i)iÀ)iÃ)iÛ)iß)i*i=*iu*iv*iz*i¤*iÛ*iÿ*i'+i*+iB+iF+iu+i¤+iÕ+iÖ+iÚ+i$,i[,i,i§,iñ,iô,i-i-i@-ip-i¡-iÒ-iÓ-i".i%.i;.i>.i.i.i.i.iµ.ië.i/i/i5/i9/i/iÓ/iÔ/iØ/iú/i00i_0ib0iz0i~0iÊ0i1i1i1il1i¢1i¥1i½1iÁ1i2i2i2i{2i±2i´2iÌ2iÐ2i3i3i3i>3iu3i®3i4i4i-4i14i4iÍ4i#5i$5i(5iL5i5i¼5i 6i#6i;6i?6i6iÓ6i%7i&7i*7iN7i7i¾7ió7iö7i8i8i`8i®8i9i9i	9i-9id9i9iÒ9iÕ9ií9iñ9i;:i:i×:iØ:iÜ:i;i?;ix;i©;i¬;iÄ;iÈ;i<ib<i·<i¸<i¼<iè<i=iX=i=i=i¤=i¨=iõ=iB>i>i>i>iÕ>i?iE?ir?iu?i?i?iá?i1@i@i@iì@i#Ai\AiÑAiBiBi(Bi,Bi~BiÐBi%Ci&Ci*CiCiÀCiùCinDiªDi­DiÅDiÉDiEimEiÉEiÊEiÎEiõEi,FiaFiÀFiGiGi&Gi*Gi{GiÔGi+Hi,Hi0HiWHiHiÃHiIi	Ii!Ii%IivIiÏIi'Ji(Ji,JiJiÎJiKiKiKi"KizKiÛKiÜKiàKiLiGLiLi¸Li»LiÓLi×Li/MiMióMi÷Mi;NirNi§NiØNiÛNióNi÷NiGOiOi÷OiøOiüOi@PiwPi¬PiïPiòPi
QiQi^Qi¶QiRiRiRikRi¢Ri×RiLSiSiSi£Si§SiòSiETiTiTiTiíTi$UiYUiÍUi	ViVi$Vi(VisViÆViWiWiWiHWiWiëWi@XiXiXiXi¡XièXi7Yi~YiYiYi®YiåYi7Zi:ZiRZiVZiZióZiôZiøZi[iS[i[iÀ[i\i\i/\i3\i\iË\i]ir]is]iw]i]iÒ]i^i?^i^i^i®^i²^iø^i>_i_iÙ_iÚ_iÞ_i`iD`i`iõ`iMaiªai­aiÅaiÉaibijbi»bicici ciEciciÆci1dididi«di¯diüdiPei¨eifififiDfifiÃfi6gigihi|hihihihiîhiHiiiiúii`jiajiejiji×jikikilinliqlililiàli:mimiómi`nianieniniÂni÷ni%oiaoiÈoipipi×piqiqiqi÷qixri{riririåri;sisiäsiåsiésitiGti}tiÌti(ui+uiCuiGuiuiëuiDvi¢vi£vi§viÍviwi9wigwi£wi
xi[xiÇxiyiYyi\yiÏyi9ziºziA{iD{i\{i`{i´{i|ih|iÄ|i!}i"}i&}iL}i}iº}i	~ie~ié~iì~iii\i¸iizi×iØiÜii=irii"i%i=iAiiÝi,i-i1i[iiÇii4i7iOiSiiïiEiFiJioi¦iÛiiii#ipiÅiii"iGi~i³ißiâiúiþiKi iöi÷iûi*iaiiñiôiii^i³i	i
ii=iti¨iiii#iqiÆiii!iciiÎiii-i1iziÊiii ibiiÍiii,i0iyiÉiiiibiiÍiii-i1iziÊiii iciiÎiii.i2i{iËii iZiiÅiiii iii¹i
iiiIii´iðióiiiXi¨iùiúiIiLi[i^i­i®i²iÖiiNi}iÊiÍiåiéi3i}iØi1i2i6iUiiÅiëiîii
iPiiéiêiîi&i[iii!i9i=iiçiF iG iK il i£ i× iÿ i¡i¡i¡id¡i±¡i¢i¢iV¢iY¢i|¢i¢iÎ¢iÏ¢iÓ¢i'£i,£i£iÖ£i+¤i|¤iÉ¤i¥i|¥i}¥i¥iÐ¥iÓ¥i
¦i>¦i{¦i~¦iÅ¦iî¦i3§iV§iY§iq§iv§iÀ§i¨if¨ig¨ik¨i³¨i¶¨ií¨i!©i]©i©i©i­©i²©iªi]ªi²ªi«i«i«i`«ic«ih«iÁ«i¬i¬iÜ¬i5­i­i­i­iâ­iå­i®iU®i®i®iÜ®i¯iJ¯im¯ip¯i¯i¯iÕ¯i°ip°iq°iu°i¼°i¿°iö°i/±ik±i ±i£±i»±iÀ±i²i\²i­²iþ²iÿ²i³i³i³i;³iX³iY³iZ³i©³i¬³i½³iÀ³i´:@last_line_endi´{;o;;o;	;
@
;i
;"!#define _VTSS_CLOCK_API_H_

;@{;o;;o;	;
@
;i&;""#include <vtss/api/types.h>

;@{;o;;o;	;
@
;iC;"%#if defined(VTSS_FEATURE_CLOCK)
;@{;o;;o;	;
@
;ic;"#ifdef __cplusplus
;@{:keywordo;;o;	;
@
;iv;"extern;@:stringo;;o;	;
@
;i};""C";@; [^{;o;;o;	;
@
;i;"#endif

;@{
;o;;o;	;
@
;i¤;"typedef;@:type_aliaso;;o;	;
@
;i¬;"
BOOL ;@:typedef_nameo;;o;	;
@
;i±;"vtss_clock_global_enable_t;@:
array[ :cap0{
;o;;o;	;
@
;i7;"typedef;@;o;;o;	;
@
;i?;"u8 ;@;o;;o;	;
@
;iB;"vtss_clock_dpll_inst_t;@;[ ;0{
;o;;o;	;
@
;i;"typedef;@:enum_type_declare{;o;;o;	;
@
;i¤;"	enum;@:
enums[{:	enum{:enum_nameo;;o;	;
@
;i¯;"'VTSS_CLOCK_SELECTION_MODE_DISABLED;@;0{;{;o;;o;	;
@
;i;"%VTSS_CLOCK_SELECTION_MODE_MANUEL;@;0{;{;o;;o;	;
@
;if;"5VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_NONREVERTIVE;@;0{;{;o;;o;	;
@
;iÍ;"2VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_REVERTIVE;@;0{;{;o;;o;	;
@
;i0;".VTSS_CLOCK_SELECTION_MODE_FORCED_HOLDOVER;@;0{;{;o;;o;	;
@
;i;".VTSS_CLOCK_SELECTION_MODE_FORCED_FREE_RUN;@;0{;{;o;;o;	;
@
;i;")VTSS_CLOCK_SELECTION_MODE_FORCED_DCO;@;0;o;;o;	;
@
;iy;" vtss_clock_selection_mode_t;@;[ ;0{
;o;;o;	;
@
;iØ;"typedef;@:struct_type_declare{:struct_members[{:member{:normal{	:	typeo;;o;	;
@
;ií;"!vtss_clock_selection_mode_t ;@:	nameo;;o;	;
@
;i	;"	mode;@;[ ;0{;{;{	; o;;o;	;
@
;i4;"!u8                          ;@;!o;;o;	;
@
;iP;"clock_input;@;[ ;0;o;;o;	;
@
;i;" vtss_clock_selection_conf_t;@;[ ;0{
;o;;o;	;
@
;ié;"typedef;@;{;o;;o;	;
@
;iñ;"	enum;@;[{;{;o;;o;	;
@
;iü;"%VTSS_CLOCK_SELECTOR_STATE_LOCKED;@;0{;{;o;;o;	;
@
;iO;"'VTSS_CLOCK_SELECTOR_STATE_HOLDOVER;@;0{;{;o;;o;	;
@
;i¡;"&VTSS_CLOCK_SELECTOR_STATE_FREERUN;@;0{;{;o;;o;	;
@
;ió;""VTSS_CLOCK_SELECTOR_STATE_DCO;@;0{;{;o;;o;	;
@
;iO	;")VTSS_CLOCK_SELECTOR_STATE_REF_FAILED;@;0{;{;o;;o;	;
@
;i¡	;"(VTSS_CLOCK_SELECTOR_STATE_ACQUIRING;@;0;o;;o;	;
@
;iü	;" vtss_clock_selector_state_t;@;[ ;0{
;o;;o;	;
@
;i[
;"typedef;@;{;o;;o;	;
@
;ic
;"	enum;@;[{;{;o;;o;	;
@
;in
;"'VTSS_CLOCK_OPERATION_MODE_DISABLED;@;0{;{;o;;o;	;
@
;i´
;"&VTSS_CLOCK_OPERATION_MODE_ENABLED;@;0;o;;o;	;
@
;i÷
;" vtss_clock_operation_mode_t;@;[ ;0{
;o;;o;	;
@
;i;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i­;"!u32                         ;@;!o;;o;	;
@
;iÉ;"limit_ppb;@;[ ;0{;{;{	; o;;o;	;
@
;i*;"!BOOL                        ;@;!o;;o;	;
@
;iF;"phase_build_out_ena;@;[ ;0{;{;{	; o;;o;	;
@
;i;"!BOOL                        ;@;!o;;o;	;
@
;i´;"ho_based;@;[ ;0;o;;o;	;
@
;i%;"vtss_clock_psl_conf_t;@;[ ;0{
;o;;o;	;
@
;i;"typedef;@;{;[	{;{;{	; o;;o;	;
@
;i«;"!vtss_clock_operation_mode_t ;@;!o;;o;	;
@
;iÇ;"	mode;@;[ ;0{;{;{	; o;;o;	;
@
;i;"!u16                         ;@;!o;;o;	;
@
;i";"holdoff;@;[ ;0{;{;{	; o;;o;	;
@
;iÃ;"!u32                         ;@;!o;;o;	;
@
;iß;"holdover;@;[ ;0{;{;{	; o;;o;	;
@
;i%;"!u16                         ;@;!o;;o;	;
@
;iA;"wtr;@;[ ;0;o;;o;	;
@
;i;"vtss_clock_dpll_conf_t;@;[ ;0{
;o;;o;	;
@
;iè;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i;"
u32  ;@;!o;;o;	;
@
;i;"ho_post_filtering_bw;@;[ ;0{;{;{	; o;;o;	;
@
;i©;"
u8   ;@;!o;;o;	;
@
;i®;"ho_qual_time_conf;@;[ ;0;o;;o;	;
@
;iD;"vtss_clock_ho_stack_conf_t;@;[ ;0{;o;;o;	;
@
;ia;"L#define VTSS_CLOCK_HO_STACK_SIZE 12 /**< Size of the holdover stack */
;@{
;o;;o;	;
@
;iì;"typedef;@;{;[	{;{;{	; o;;o;	;
@
;i;"u64     ;@;!o;;o;	;
@
;i';"stack_value;@;[{:	expro;;o;	;
@
;i3;"VTSS_CLOCK_HO_STACK_SIZE;@;0{;{;{	; o;;o;	;
@
;i¨;"u8      ;@;!o;;o;	;
@
;i°;"ho_sel;@;[ ;0{;{;{	; o;;o;	;
@
;i ;"u8      ;@;!o;;o;	;
@
;i;"ho_min_fill_lvl;@;[ ;0{;{;{	; o;;o;	;
@
;i_;"BOOL    ;@;!o;;o;	;
@
;ig;"ho_filled;@;[ ;0;o;;o;	;
@
;i;""vtss_clock_ho_stack_content_t;@;[ ;0{
;o;;o;	;
@
;i;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iB;"
u8   ;@;!o;;o;	;
@
;iG;"priority;@;[ ;0{;{;{	; o;;o;	;
@
;i~;"
BOOL ;@;!o;;o;	;
@
;i;"enable;@;[ ;0;o;;o;	;
@
;iÃ;"#vtss_clock_priority_selector_t;@;[ ;0{
;o;;o;	;
@
;iJ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;ir;"
u32  ;@;!o;;o;	;
@
;iw;"num;@;[ ;0{;{;{	; o;;o;	;
@
;i´;"
u32  ;@;!o;;o;	;
@
;i¹;"den;@;[ ;0;o;;o;	;
@
;iö;"vtss_clock_ratio_t;@;[ ;0{
;o;;o;	;
@
;iQ;"typedef;@;{;o;;o;	;
@
;iY;"	enum;@;[{;{;o;;o;	;
@
;id;"VTSS_CLOCK_INPUT_TYPE_DPLL;@;0{;{;o;;o;	;
@
;i´;"VTSS_CLOCK_INPUT_TYPE_IN;@;0{;{;o;;o;	;
@
;i;"#VTSS_CLOCK_INPUT_TYPE_PURE_DCO;@;0;o;;o;	;
@
;im;"vtss_clock_input_type_t;@;[ ;0{
;o;;o;	;
@
;iÊ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iû;"vtss_clock_input_type_t ;@;!o;;o;	;
@
;i;"input_type;@;[ ;0{;{;{	; o;;o;	;
@
;iz;"u8                      ;@;!o;;o;	;
@
;i;"input_inst;@;[ ;0;o;;o;	;
@
;iÕ;" vtss_clock_input_selector_t;@;[ ;0{
;o;;o;	;
@
;i-;"typedef;@;{;[
{;{;{	; o;;o;	;
@
;iZ;"
BOOL ;@;!o;;o;	;
@
;i_;"pll_freq_lock;@;[ ;0{;{;{	; o;;o;	;
@
;iª;"
BOOL ;@;!o;;o;	;
@
;i¯;"pll_phase_lock;@;[ ;0{;{;{	; o;;o;	;
@
;iô;"
BOOL ;@;!o;;o;	;
@
;iù;"pll_losx;@;[ ;0{;{;{	; o;;o;	;
@
;iI;"
BOOL ;@;!o;;o;	;
@
;iN;"pll_lol;@;[ ;0{;{;{	; o;;o;	;
@
;i~;"
BOOL ;@;!o;;o;	;
@
;i;"pll_dig_hold_vld;@;[ ;0;o;;o;	;
@
;iÑ;"vtss_clock_dpll_state_t;@;[ ;0{
;o;;o;	;
@
;i,;"typedef;@;{;[
{;{;{	; o;;o;	;
@
;iZ;"
BOOL ;@;!o;;o;	;
@
;i_;"los;@;[ ;0{;{;{	; o;;o;	;
@
;i;"
BOOL ;@;!o;;o;	;
@
;i;"pfm;@;[ ;0{;{;{	; o;;o;	;
@
;iÃ;"
BOOL ;@;!o;;o;	;
@
;iÈ;"cfm;@;[ ;0{;{;{	; o;;o;	;
@
;iú;"
BOOL ;@;!o;;o;	;
@
;iÿ;"scm;@;[ ;0{;{;{	; o;;o;	;
@
;i';"
BOOL ;@;!o;;o;	;
@
;i,;"lol;@;[ ;0;o;;o;	;
@
;iK;"vtss_clock_input_state_t;@;[ ;0{
;o;;o;	;
@
;iÂ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iò;"
BOOL ;@;!o;;o;	;
@
;i÷;"los;@;[ ;0{;{;{	; o;;o;	;
@
;iT;"
BOOL ;@;!o;;o;	;
@
;iY;"pfm;@;[ ;0{;{;{	; o;;o;	;
@
;iÁ;"
BOOL ;@;!o;;o;	;
@
;iÆ;"cfm;@;[ ;0{;{;{	; o;;o;	;
@
;i-;"
BOOL ;@;!o;;o;	;
@
;i2;"scm;@;[ ;0{;{;{	; o;;o;	;
@
;i;"
BOOL ;@;!o;;o;	;
@
;i;"gst;@;[ ;0{;{;{	; o;;o;	;
@
;iù;"
BOOL ;@;!o;;o;	;
@
;iþ;"lol;@;[ ;0;o;;o;	;
@
;iY ;"!vtss_clock_input_alarm_ena_t;@;[ ;0{
;o;;o;	;
@
;i» ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iæ ;""BOOL                         ;@;!o;;o;	;
@
;i!;"los_active_high;@;[ ;0{;{;{	; o;;o;	;
@
;iS!;""vtss_clock_input_alarm_ena_t ;@;!o;;o;	;
@
;ip!;"alarm_ena;@;[ ;0;o;;o;	;
@
;i§!;"vtss_clock_input_conf_t;@;[ ;0{
;o;;o;	;
@
;i";"typedef;@;{;[{;{;{	; o;;o;	;
@
;i8";"	u32 ;@;!o;;o;	;
@
;i<";"cfm_set_ppb;@;[ ;0{;{;{	; o;;o;	;
@
;i´";"	u32 ;@;!o;;o;	;
@
;i¸";"cfm_clr_ppb;@;[ ;0;o;;o;	;
@
;i1#;"vtss_clock_cfm_conf_t;@;[ ;0{
;o;;o;	;
@
;i#;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iÁ#;"	u32 ;@;!o;;o;	;
@
;iÅ#;"pfm_set_ppb;@;[ ;0{;{;{	; o;;o;	;
@
;i=$;"	u32 ;@;!o;;o;	;
@
;iA$;"pfm_clr_ppb;@;[ ;0;o;;o;	;
@
;iº$;"vtss_clock_pfm_conf_t;@;[ ;0{
;o;;o;	;
@
;i%;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i.%;"	u32 ;@;!o;;o;	;
@
;i2%;"disqualification_time_us;@;[ ;0{;{;{	; o;;o;	;
@
;i%;"	u32 ;@;!o;;o;	;
@
;i%;"qualification_time_us;@;[ ;0{;{;{	; o;;o;	;
@
;iT&;"
BOOL ;@;!o;;o;	;
@
;iY&;"los;@;[ ;0{;{;{	; o;;o;	;
@
;i©&;"
BOOL ;@;!o;;o;	;
@
;i®&;"pfm;@;[ ;0{;{;{	; o;;o;	;
@
;i	';"
BOOL ;@;!o;;o;	;
@
;i';"cfm;@;[ ;0{;{;{	; o;;o;	;
@
;ih';"
BOOL ;@;!o;;o;	;
@
;im';"scm;@;[ ;0{;{;{	; o;;o;	;
@
;iÃ';"
BOOL ;@;!o;;o;	;
@
;iÈ';"lol;@;[ ;0;o;;o;	;
@
;i(;"vtss_clock_gst_conf_t;@;[ ;0{:func_proto{;{	; o;;o;	;
@
;iß);"vtss_rc ;@;!o;;o;	;
@
;iç);"vtss_clock_rd;@;[ ;0:	args[{;{	; o;;o;	;
@
;iõ);"const vtss_inst_t  ;@;!o;;o;	;
@
;i*;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i$*;"const u32          ;@;!o;;o;	;
@
;i7*;"	addr;@;[ ;0{;{	; o;;o;	;
@
;iS*;"u32                *const ;@;!o;;o;	;
@
;im*;"
value;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iF+;"vtss_rc ;@;!o;;o;	;
@
;iN+;"vtss_clock_wr;@;[ ;0;$[{;{	; o;;o;	;
@
;i\+;"const vtss_inst_t  ;@;!o;;o;	;
@
;io+;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i+;"const u32          ;@;!o;;o;	;
@
;i+;"	addr;@;[ ;0{;{	; o;;o;	;
@
;iº+;"const u32          ;@;!o;;o;	;
@
;iÍ+;"
value;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i-;"vtss_rc ;@;!o;;o;	;
@
;i-;"vtss_clock_wrm;@;[ ;0;$[	{;{	; o;;o;	;
@
;i'-;"const vtss_inst_t  ;@;!o;;o;	;
@
;i:-;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iW-;"const u32          ;@;!o;;o;	;
@
;ij-;"	addr;@;[ ;0{;{	; o;;o;	;
@
;i-;"const u32          ;@;!o;;o;	;
@
;i-;"
value;@;[ ;0{;{	; o;;o;	;
@
;i¸-;"const u32          ;@;!o;;o;	;
@
;iË-;"	mask;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i9/;"vtss_rc ;@;!o;;o;	;
@
;iA/;"!vtss_clock_global_enable_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i^/;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i/;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i«/;"'const vtss_clock_global_enable_t  ;@;!o;;o;	;
@
;iÍ/;"ena;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i~0;"vtss_rc ;@;!o;;o;	;
@
;i0;"!vtss_clock_global_enable_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i£0;"&const vtss_inst_t                ;@;!o;;o;	;
@
;iÄ0;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iï0;"'vtss_clock_global_enable_t       *;@;!o;;o;	;
@
;i1;"ena;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÁ1;"vtss_rc ;@;!o;;o;	;
@
;iÉ1;"vtss_clock_global_sw_reset;@;[ ;0;$[{;{	; o;;o;	;
@
;iä1;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i2;"	inst;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÐ2;"vtss_rc ;@;!o;;o;	;
@
;iØ2;"vtss_clock_shutdown;@;[ ;0;$[{;{	; o;;o;	;
@
;iì2;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i3;"	inst;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i14;"vtss_rc ;@;!o;;o;	;
@
;i94;""vtss_clock_selection_mode_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iW4;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iy4;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¥4;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;iÇ4;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;ió4;".const vtss_clock_selection_conf_t *const ;@;!o;;o;	;
@
;i5;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i?6;"vtss_rc ;@;!o;;o;	;
@
;iG6;""vtss_clock_selection_mode_get;@;[ ;0;$[{;{	; o;;o;	;
@
;ie6;"#const vtss_inst_t             ;@;!o;;o;	;
@
;i6;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¯6;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;iÍ6;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iù6;"*vtss_clock_selection_conf_t   *const ;@;!o;;o;	;
@
;i7;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i8;"vtss_rc ;@;!o;;o;	;
@
;i8;""vtss_clock_operation_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i88;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iZ8;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i8;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i¨8;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iÔ8;".const vtss_clock_dpll_conf_t      *const ;@;!o;;o;	;
@
;iý8;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iñ9;"vtss_rc ;@;!o;;o;	;
@
;iù9;""vtss_clock_operation_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i:;"#const vtss_inst_t             ;@;!o;;o;	;
@
;i5:;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ia:;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;i:;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i«:;"*vtss_clock_dpll_conf_t        *const ;@;!o;;o;	;
@
;iÐ:;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÈ;;"vtss_rc ;@;!o;;o;	;
@
;iÐ;;"!vtss_clock_ho_stack_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;ií;;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i<;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i:<;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i\<;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i<;".const vtss_clock_ho_stack_conf_t  *const ;@;!o;;o;	;
@
;i°<;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i¨=;"vtss_rc ;@;!o;;o;	;
@
;i°=;"!vtss_clock_ho_stack_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iÍ=;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iï=;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i>;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i<>;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;ig>;".vtss_clock_ho_stack_conf_t        *const ;@;!o;;o;	;
@
;i>;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i?;"vtss_rc ;@;!o;;o;	;
@
;i?;"$vtss_clock_ho_stack_content_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i¹?;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iÛ?;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i	@;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i+@;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iY@;".vtss_clock_ho_stack_content_t     *const ;@;!o;;o;	;
@
;i@;"	cont;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i,B;"vtss_rc ;@;!o;;o;	;
@
;i4B;"(vtss_clock_dco_frequency_offset_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iXB;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ixB;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iªB;"%const vtss_clock_dpll_inst_t    ;@;!o;;o;	;
@
;iÊB;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iüB;"%const i64                       ;@;!o;;o;	;
@
;iC;"offset;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÉD;"vtss_rc ;@;!o;;o;	;
@
;iÑD;"(vtss_clock_dco_frequency_offset_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iõD;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iE;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iGE;"%const vtss_clock_dpll_inst_t    ;@;!o;;o;	;
@
;igE;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iE;",i64                             *const ;@;!o;;o;	;
@
;iÀE;"offset;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i*G;"vtss_rc ;@;!o;;o;	;
@
;i2G;"$vtss_clock_output_filter_bw_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iRG;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;iuG;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i£G;"(const u8                           ;@;!o;;o;	;
@
;iÆG;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iüG;"(const u32                          ;@;!o;;o;	;
@
;iH;"bw_100uhz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i%I;"vtss_rc ;@;!o;;o;	;
@
;i-I;"$vtss_clock_output_filter_bw_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iMI;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;ipI;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iI;"(const u8                           ;@;!o;;o;	;
@
;iÁI;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i÷I;")u32                                *;@;!o;;o;	;
@
;iJ;"bw_100uhz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i"K;"vtss_rc ;@;!o;;o;	;
@
;i*K;"+vtss_clock_output_filter_lock_fast_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iQK;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;itK;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i©K;"(const u8                           ;@;!o;;o;	;
@
;iÌK;"clock_output;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i×L;"vtss_rc ;@;!o;;o;	;
@
;ißL;"+vtss_clock_output_filter_lock_fast_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iM;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;i)M;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i^M;"(const u8                           ;@;!o;;o;	;
@
;iM;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i¾M;")BOOL                               *;@;!o;;o;	;
@
;iâM;"lock_completed;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i÷N;"vtss_rc ;@;!o;;o;	;
@
;iÿN;"#vtss_clock_output_psl_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iO;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;iAO;"	inst;@;[ ;0{;{	; o;;o;	;
@
;inO;"(const u8                           ;@;!o;;o;	;
@
;iO;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÆO;"/const vtss_clock_psl_conf_t        *const ;@;!o;;o;	;
@
;iðO;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iQ;"vtss_rc ;@;!o;;o;	;
@
;iQ;"#vtss_clock_output_psl_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i5Q;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;iXQ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iQ;"(const u8                           ;@;!o;;o;	;
@
;i¨Q;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÝQ;"/vtss_clock_psl_conf_t              *const ;@;!o;;o;	;
@
;iR;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i§S;"vtss_rc ;@;!o;;o;	;
@
;i¯S;"!vtss_clock_adj_frequency_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iÌS;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iìS;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iT;"%const u8                        ;@;!o;;o;	;
@
;i7T;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;ijT;"%const i64                       ;@;!o;;o;	;
@
;iT;"adj;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i(V;"vtss_rc ;@;!o;;o;	;
@
;i0V;"!vtss_clock_adj_frequency_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iMV;"%const vtss_inst_t               ;@;!o;;o;	;
@
;imV;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iV;"%const u8                        ;@;!o;;o;	;
@
;i¸V;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iëV;",i64                             *const ;@;!o;;o;	;
@
;iW;"adj;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i¡X;"vtss_rc ;@;!o;;o;	;
@
;i©X;"vtss_clock_adj_phase_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iÂX;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iâX;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i	Y;"%const u8                        ;@;!o;;o;	;
@
;i)Y;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iXY;"%const i32                       ;@;!o;;o;	;
@
;ixY;"adj;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iVZ;"vtss_rc ;@;!o;;o;	;
@
;i^Z;"vtss_clock_adj_phase_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iwZ;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iZ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¾Z;",BOOL                            *const ;@;!o;;o;	;
@
;iåZ;"adj_ongoing;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i3\;"vtss_rc ;@;!o;;o;	;
@
;i;\;"vtss_clock_priority_set;@;[ ;0;$[	{;{	; o;;o;	;
@
;iS\;"+const vtss_inst_t                     ;@;!o;;o;	;
@
;iy\;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i\;"+const vtss_clock_dpll_inst_t          ;@;!o;;o;	;
@
;iÅ\;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;ië\;"+const u8                              ;@;!o;;o;	;
@
;i];"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i>];"2const vtss_clock_priority_selector_t  *const ;@;!o;;o;	;
@
;ik];"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i²^;"vtss_rc ;@;!o;;o;	;
@
;iº^;"vtss_clock_priority_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;iÒ^;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iò^;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i_;"%const vtss_clock_dpll_inst_t    ;@;!o;;o;	;
@
;i8_;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i^_;"%const u8                        ;@;!o;;o;	;
@
;i~_;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i«_;",vtss_clock_priority_selector_t  *const ;@;!o;;o;	;
@
;iÒ_;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÉa;"vtss_rc ;@;!o;;o;	;
@
;iÑa;"#vtss_clock_input_frequency_set;@;[ ;0;$[	{;{	; o;;o;	;
@
;iða;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ib;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i=b;"%const u8                        ;@;!o;;o;	;
@
;i]b;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;ib;"%const u32                       ;@;!o;;o;	;
@
;i±b;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iâb;"%const BOOL                      ;@;!o;;o;	;
@
;ic;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i¯d;"vtss_rc ;@;!o;;o;	;
@
;i·d;"#vtss_clock_input_frequency_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;iÖd;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iöd;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i#e;"%const u8                        ;@;!o;;o;	;
@
;iCe;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iwe;",u32                             *const ;@;!o;;o;	;
@
;ie;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iÏe;",BOOL                            *const ;@;!o;;o;	;
@
;iöe;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;ih;"vtss_rc ;@;!o;;o;	;
@
;i£h;")vtss_clock_input_frequency_ratio_set;@;[ ;0;$[
{;{	; o;;o;	;
@
;iÈh;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ièh;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ii;"%const u8                        ;@;!o;;o;	;
@
;i;i;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iui;"%const u32                       ;@;!o;;o;	;
@
;ii;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iÌi;",const vtss_clock_ratio_t        *const ;@;!o;;o;	;
@
;iói;"
ratio;@;[ ;0{;{	; o;;o;	;
@
;i'j;"%const BOOL                      ;@;!o;;o;	;
@
;iGj;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;il;"vtss_rc ;@;!o;;o;	;
@
;il;")vtss_clock_input_frequency_ratio_get;@;[ ;0;$[
{;{	; o;;o;	;
@
;iºl;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iÚl;"	inst;@;[ ;0{;{	; o;;o;	;
@
;im;"%const u8                        ;@;!o;;o;	;
@
;i-m;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;igm;",u32                             *const ;@;!o;;o;	;
@
;im;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iÅm;",vtss_clock_ratio_t              *const ;@;!o;;o;	;
@
;iìm;"
ratio;@;[ ;0{;{	; o;;o;	;
@
;i n;",BOOL                            *const ;@;!o;;o;	;
@
;iGn;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;ir;"vtss_rc ;@;!o;;o;	;
@
;ir;"$vtss_clock_output_frequency_set;@;[ ;0;$[	{;{	; o;;o;	;
@
;i¿r;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ißr;"	inst;@;[ ;0{;{	; o;;o;	;
@
;is;"%const u8                        ;@;!o;;o;	;
@
;i-s;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;ics;"%const u32                       ;@;!o;;o;	;
@
;is;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iµs;"%const u32                       ;@;!o;;o;	;
@
;iÕs;"par_freq_khz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iGu;"vtss_rc ;@;!o;;o;	;
@
;iOu;"$vtss_clock_output_frequency_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;iou;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iu;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i½u;"%const u8                        ;@;!o;;o;	;
@
;iÝu;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iv;",u32                             *const ;@;!o;;o;	;
@
;i:v;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;ilv;",u32                             *const ;@;!o;;o;	;
@
;iv;"par_freq_khz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i`{;"vtss_rc ;@;!o;;o;	;
@
;ih{;"*vtss_clock_output_frequency_ratio_set;@;[ ;0;$[
{;{	; o;;o;	;
@
;i{;"%const vtss_inst_t               ;@;!o;;o;	;
@
;i®{;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iâ{;"%const u8                        ;@;!o;;o;	;
@
;i|;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i>|;"%const u32                       ;@;!o;;o;	;
@
;i^|;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;i|;"%const u32                       ;@;!o;;o;	;
@
;i¶|;"par_freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iò|;",const vtss_clock_ratio_t        *const ;@;!o;;o;	;
@
;i};"
ratio;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i;"vtss_rc ;@;!o;;o;	;
@
;i;"*vtss_clock_output_frequency_ratio_get;@;[ ;0;$[
{;{	; o;;o;	;
@
;i6;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iV;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i;"%const u8                        ;@;!o;;o;	;
@
;iª;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iæ;",u32                             *const ;@;!o;;o;	;
@
;i;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iE;",u32                             *const ;@;!o;;o;	;
@
;il;"par_freq_khz;@;[ ;0{;{	; o;;o;	;
@
;i¨;",vtss_clock_ratio_t              *const ;@;!o;;o;	;
@
;iÏ;"
ratio;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iA;"vtss_rc ;@;!o;;o;	;
@
;iI;" vtss_clock_output_level_set;@;[ ;0;$[{;{	; o;;o;	;
@
;ie;"%const vtss_inst_t               ;@;!o;;o;	;
@
;i;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¯;"%const u8                        ;@;!o;;o;	;
@
;iÏ;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i;"%const u16                       ;@;!o;;o;	;
@
;i!;"level_mv;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iS;"vtss_rc ;@;!o;;o;	;
@
;i[;" vtss_clock_output_level_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iw;"%const vtss_inst_t               ;@;!o;;o;	;
@
;i;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÁ;"%const u8                        ;@;!o;;o;	;
@
;iá;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i;",u16                             *const ;@;!o;;o;	;
@
;i:;"level_mv;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i#;"vtss_rc ;@;!o;;o;	;
@
;i+;"#vtss_clock_output_selector_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iJ;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ij;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i;"%const u8                        ;@;!o;;o;	;
@
;i·;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iì;".const vtss_clock_input_selector_t *const ;@;!o;;o;	;
@
;i;"
input;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iþ;"vtss_rc ;@;!o;;o;	;
@
;i;"#vtss_clock_output_selector_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i%;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iE;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ir;"%const u8                        ;@;!o;;o;	;
@
;i;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÇ;",vtss_clock_input_selector_t     *const ;@;!o;;o;	;
@
;iî;"
input;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i;"vtss_rc ;@;!o;;o;	;
@
;i;"$vtss_clock_input_alarm_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i8;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iX;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i;"%const u8                        ;@;!o;;o;	;
@
;i¦;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÛ;",const vtss_clock_input_conf_t   *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i#;"vtss_rc ;@;!o;;o;	;
@
;i+;"$vtss_clock_input_alarm_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iK;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ik;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i;"%const u8                        ;@;!o;;o;	;
@
;i¹;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iî;",vtss_clock_input_conf_t         *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i1;"vtss_rc ;@;!o;;o;	;
@
;i9;""vtss_clock_input_cfm_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iW;""const vtss_inst_t            ;@;!o;;o;	;
@
;it;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i ;""const u8                     ;@;!o;;o;	;
@
;i½;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;ið;")const vtss_clock_cfm_conf_t  *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i0;"vtss_rc ;@;!o;;o;	;
@
;i8;""vtss_clock_input_cfm_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iV;""const vtss_inst_t            ;@;!o;;o;	;
@
;is;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i;""const u8                     ;@;!o;;o;	;
@
;i¼;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iï;")vtss_clock_cfm_conf_t        *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i1;"vtss_rc ;@;!o;;o;	;
@
;i9;""vtss_clock_input_pfm_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iW;""const vtss_inst_t            ;@;!o;;o;	;
@
;it;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i ;""const u8                     ;@;!o;;o;	;
@
;i½;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;ið;")const vtss_clock_pfm_conf_t  *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i2;"vtss_rc ;@;!o;;o;	;
@
;i:;""vtss_clock_input_pfm_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iX;""const vtss_inst_t            ;@;!o;;o;	;
@
;iu;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¡;""const u8                     ;@;!o;;o;	;
@
;i¾;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iñ;")vtss_clock_pfm_conf_t        *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i ;"vtss_rc ;@;!o;;o;	;
@
;i(;""vtss_clock_input_gst_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iF;""const vtss_inst_t            ;@;!o;;o;	;
@
;ic;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i;""const u8                     ;@;!o;;o;	;
@
;i¬;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iß;")const vtss_clock_gst_conf_t  *const ;@;!o;;o;	;
@
;i;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i;"vtss_rc ;@;!o;;o;	;
@
;i;""vtss_clock_input_gst_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i5;""const vtss_inst_t            ;@;!o;;o;	;
@
;iR;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i~;""const u8                     ;@;!o;;o;	;
@
;i;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÎ;")vtss_clock_gst_conf_t        *const ;@;!o;;o;	;
@
;iò;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;ié;"vtss_rc ;@;!o;;o;	;
@
;iñ;""vtss_clock_selector_state_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;i;"#const vtss_inst_t             ;@;!o;;o;	;
@
;i-;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iY;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;iw;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i£;"*vtss_clock_selector_state_t   *const ;@;!o;;o;	;
@
;iÈ;"selector_state;@;[ ;0{;{	; o;;o;	;
@
;iþ;"*u8                            *const ;@;!o;;o;	;
@
;i#;"clock_input;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i
;"vtss_rc ;@;!o;;o;	;
@
;i;"vtss_clock_dpll_state_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i,;"#const vtss_inst_t             ;@;!o;;o;	;
@
;iJ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ir;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;i;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i¸;"*vtss_clock_dpll_state_t       *const ;@;!o;;o;	;
@
;iÝ;"pll_state;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i=;"vtss_rc ;@;!o;;o;	;
@
;iE;"-vtss_clock_ho_stack_frequency_offset_get;@;[ ;0;$[{;{	; o;;o;	;
@
;in;"#const vtss_inst_t             ;@;!o;;o;	;
@
;i;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÃ;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;iá;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i ;"*i64                           *const ;@;!o;;o;	;
@
;i= ;"offset;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i¡;"vtss_rc ;@;!o;;o;	;
@
;i&¡;"vtss_clock_input_state_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iA¡;""const vtss_inst_t            ;@;!o;;o;	;
@
;i^¡;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¡;"#const u8                      ;@;!o;;o;	;
@
;i¤¡;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÓ¡;"*vtss_clock_input_state_t      *const ;@;!o;;o;	;
@
;iø¡;"input_state;@;[ ;0;0{;o;;o;	;
@
;i,£;"Y#define VTSS_CLOCK_INPUT_LOS_EV     (1 << 0)  /**< External Loss Of Signal event */
;@{;o;;o;	;
@
;i£;"[#define VTSS_CLOCK_INPUT_PFM_EV     (1 << 1)  /**< Precise frequency monitor event */
;@{;o;;o;	;
@
;iÖ£;"Z#define VTSS_CLOCK_INPUT_CFM_EV     (1 << 2)  /**< Coarse frequency monitor event */
;@{;o;;o;	;
@
;i+¤;"V#define VTSS_CLOCK_INPUT_SCM_EV     (1 << 3)  /**< Single Cycle monitor event */
;@{;o;;o;	;
@
;i|¤;"R#define VTSS_CLOCK_INPUT_GST_EV     (1 << 4)  /**< Guard Soak timer event */
;@{;o;;o;	;
@
;iÉ¤;"N#define VTSS_CLOCK_INPUT_LOL_EV     (1 << 5)  /**< Loss of Lock event */
;@{
;o;;o;	;
@
;i¥;"typedef;@;o;;o;	;
@
;i¥;"	u32 ;@;o;;o;	;
@
;i¥;""vtss_clock_input_event_type_t;@;[ ;0{;#{;{	; o;;o;	;
@
;iv§;"vtss_rc ;@;!o;;o;	;
@
;i~§;" vtss_clock_input_event_poll;@;[ ;0;$[{;{	; o;;o;	;
@
;i§;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iº§;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iä§;"%const u8                        ;@;!o;;o;	;
@
;i¨;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i5¨;",vtss_clock_input_event_type_t   *const ;@;!o;;o;	;
@
;i\¨;"ev_mask;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i²©;"vtss_rc ;@;!o;;o;	;
@
;iº©;""vtss_clock_input_event_enable;@;[ ;0;$[	{;{	; o;;o;	;
@
;iØ©;"+const vtss_inst_t                     ;@;!o;;o;	;
@
;iþ©;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i*ª;"+const u8                              ;@;!o;;o;	;
@
;iPª;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iª;"+const vtss_clock_input_event_type_t   ;@;!o;;o;	;
@
;i©ª;"ev_mask;@;[ ;0{;{	; o;;o;	;
@
;iØª;"+const BOOL                            ;@;!o;;o;	;
@
;iþª;"enable;@;[ ;0;0{;o;;o;	;
@
;iÜ¬;"^#define VTSS_CLOCK_DPLL_STATE_CHANGE_EV   (1 << 0) /**< State change event in EEC FSM */
;@{
;o;;o;	;
@
;i5­;"typedef;@;o;;o;	;
@
;i=­;"	u32 ;@;o;;o;	;
@
;iA­;"!vtss_clock_dpll_event_type_t;@;[ ;0{;#{;{	; o;;o;	;
@
;i¯;"vtss_rc ;@;!o;;o;	;
@
;i¯;"vtss_clock_dpll_event_poll;@;[ ;0;$[{;{	; o;;o;	;
@
;i°¯;"$const vtss_inst_t              ;@;!o;;o;	;
@
;iÏ¯;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iø¯;"$const vtss_clock_dpll_inst_t   ;@;!o;;o;	;
@
;i°;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i@°;"+vtss_clock_dpll_event_type_t   *const ;@;!o;;o;	;
@
;if°;"ev_mask;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÀ±;"vtss_rc ;@;!o;;o;	;
@
;iÈ±;"!vtss_clock_dpll_event_enable;@;[ ;0;$[	{;{	; o;;o;	;
@
;iå±;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;i²;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i3²;"(const vtss_clock_dpll_inst_t       ;@;!o;;o;	;
@
;iV²;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i²;"(const vtss_clock_dpll_event_type_t ;@;!o;;o;	;
@
;i¤²;"ev_mask;@;[ ;0{;{	; o;;o;	;
@
;iÒ²;"(const BOOL                         ;@;!o;;o;	;
@
;iõ²;"enable;@;[ ;0;0{;o;;o;	;
@
;iÿ²;"#ifdef __cplusplus
;@{;o;;o;	;
@
;i³;"#endif
;@{;o;;o;	;
@
;i³;"%#endif /* VTSS_FEATURE_OMEGA */
;@{;o;;o;	;
@
;i;³;"$#endif // _VTSS_CLOCK_API_H_


;@