{:	root[{:ppo:Parslet::Slice:@positiono:Parslet::Position:@string"¥// Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT


/**
 * \file
 * \brief Clock API.
 * \details This header file describes Vitesse DPLL API functions and
 * associated types.
 */

#ifndef _VTSS_CLOCK_API_H_
#define _VTSS_CLOCK_API_H_

#include <vtss/api/types.h>

#if defined(VTSS_FEATURE_CLOCK)
#ifdef __cplusplus
extern "C" {
#endif

// ***************************************************************************
//
//  DPLL interface
//
// ***************************************************************************

/**
 * \brief clock global enable state. Will switch off system clock for omega IP if false
 **/
typedef BOOL vtss_clock_global_enable_t;

/**
 * \brief parameter describing the DPLL instance.
 *  In ES6514 Instance A = 0, Instance B = 1.
 **/
typedef u8 vtss_clock_dpll_inst_t;

/**
 * \brief parameter describing the DPLL selection mode.
 **/
typedef enum
{
    VTSS_CLOCK_SELECTION_MODE_DISABLED,                 /**< Controller / DPLL is disabled */
    VTSS_CLOCK_SELECTION_MODE_MANUEL,                   /**< Manually select an input */
    VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_NONREVERTIVE,   /**< Automatic selection mode non revertive */
    VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_REVERTIVE,      /**< Automatic selection mode revertive */
    VTSS_CLOCK_SELECTION_MODE_FORCED_HOLDOVER,          /**< Manually selection mode forced to holdover */
    VTSS_CLOCK_SELECTION_MODE_FORCED_FREE_RUN,          /**< Manually selection mode forced to free-run */
    VTSS_CLOCK_SELECTION_MODE_FORCED_DCO,               /**< Selection mode Digitally Controlled Oscillator (DCO) */
} vtss_clock_selection_mode_t;

/**
 * \brief parameter setting up the DPLL selection mode.
 **/
typedef struct {
    vtss_clock_selection_mode_t mode;           /**< selection mode */
    u8                          clock_input;    /**< selected input id manual mode */
} vtss_clock_selection_conf_t;


/**
 * \brief parameter describing the DPLL selectior state.
 **/
typedef enum
{
    VTSS_CLOCK_SELECTOR_STATE_LOCKED,       /**< the dpll is locked to an input */
    VTSS_CLOCK_SELECTOR_STATE_HOLDOVER,     /**< the dpll is in holdover state */
    VTSS_CLOCK_SELECTOR_STATE_FREERUN,      /**< the dpll is in free-run state */
    VTSS_CLOCK_SELECTOR_STATE_DCO,          /**< the dpll is controlled by SW (DCO mode) */
    VTSS_CLOCK_SELECTOR_STATE_REF_FAILED,   /**< the selected reference failed */
    VTSS_CLOCK_SELECTOR_STATE_ACQUIRING,    /**< acquiring lock to the selected reference */
} vtss_clock_selector_state_t;

/**
 * \brief parameter describing the DPLL operation mode.
 **/
typedef enum
{
    VTSS_CLOCK_OPERATION_MODE_DISABLED,  /**< the dpll is DISABLED */
    VTSS_CLOCK_OPERATION_MODE_ENABLED,   /**< the dpll is ENABLED */
} vtss_clock_operation_mode_t;

//typedef enum
//{
//    VTSS_CLOCK_FILTER_BW_1MILLI_HZ, /**< the dpll filter bandwidth is 1 milli Hz */
//    VTSS_CLOCK_FILTER_BW_0_1_Hz,    /**< the dpll filter bandwidth is 0.1 Hz */
//    VTSS_CLOCK_FILTER_BW_5_HZ,      /**< the dpll filter bandwidth is 5 Hz */
//} vtss_clock_filter_bw_t;


/**
 * \brief parameter for setting up the phase slope limiter.
 */
typedef struct vtss_clock_psl_conf_t {
    u32                         limit_ppb;            /**< maximum phase slope in ppb [1..524000], 0 Disables the feature */
    BOOL                        phase_build_out_ena;  /**< If true, limited phase information is dismissed */
    BOOL                        ho_based;             /**< If true, slope limit is with respect to frequency offset stored in holdover stack*/
} vtss_clock_psl_conf_t;
  
/**
 * \brief parameter for setting the dpll configuration.
 */
typedef struct vtss_clock_dpll_conf_t {
    vtss_clock_operation_mode_t mode;       /**< clock operation mode. Enable / Disable */
    u16                         holdoff;    /**< holdoff time in ms (0 => holdoff disabled); the actual holdoff is in steps of 1 ms; i.e. values are trunkated to 1 ms multipla HW: 16 bit*/
    u32                         holdover;   /**< holdover time in ms [0..84600]       HW:17 bit*/
    u16                         wtr;        /**< wait-to-restore time in sec [0..720] HW:10 bit*/
} vtss_clock_dpll_conf_t;

/**
 * \brief parameter for setting the holdover stack configuration.
 */
typedef struct vtss_clock_ho_stack_conf_t {
    u32  ho_post_filtering_bw;    /**< holdover stack post filtering bandwidth im mHz [23 ... 1.46e9] es6514: Bugzilla #15547 [741 ... 1.46e9]*/
    u8   ho_qual_time_conf;       /**< holdover qulification time configuration. time in s = 2^ho_qual_time_conf conf. range: [0..11] => time: [1..2048]s */
} vtss_clock_ho_stack_conf_t;

#define VTSS_CLOCK_HO_STACK_SIZE 12 /**< Size of the holdover stack */
/**
 * \brief parameter for getting the holdover stack content.
 */
typedef struct vtss_clock_ho_stack_content_t {
    u64     stack_value[VTSS_CLOCK_HO_STACK_SIZE];        /**< HO-stack read data got all 12 stack levels (HO values in scaled PPB's) */
    u8      ho_sel;                 /**< Select ho-value to take in hold-over state. */
    u8      ho_min_fill_lvl;        /**< Minimum fill level before ho-stack considered full */
    BOOL    ho_filled;              /**< TRUE if stack is full */
} vtss_clock_ho_stack_content_t;

/**
 * \brief parameter for setting the priority for dpll source selection
 */
typedef struct vtss_clock_priority_selector_t {
    u8   priority;          /**< Priority - 0 is highest */
    BOOL enable;            /**< Enable for the respective priority */
} vtss_clock_priority_selector_t;

/**
 * \brief parameter for defining a ratio when selecting a frequency that is a rational number
 */
typedef struct vtss_clock_ratio_t {
    u32  num;               /**< numerator of a rational value */
    u32  den;               /**< denominator of a rational value */
} vtss_clock_ratio_t;

/**
 * \brief parameter for selecting the type of the clock input
 */
typedef enum
{
    VTSS_CLOCK_INPUT_TYPE_DPLL,     /**< a dpll output is selected as output */
    VTSS_CLOCK_INPUT_TYPE_IN,       /**< a input signal is directly selected as output */
    VTSS_CLOCK_INPUT_TYPE_PURE_DCO, /**< output is running purely on LC-PLL plus optional DCO */
} vtss_clock_input_type_t;

/**
 * \brief parameter for setting the clock output selector.
 */
typedef struct vtss_clock_input_selector_t {
    vtss_clock_input_type_t input_type;     /**< Defines if it is clock input or a DPLL outpus that drives the clock output */
    u8                      input_inst;     /**< defines the clock input or DPLL instance */
} vtss_clock_input_selector_t;

/**
 * \brief parameter for returning the dpll state.
 */
typedef struct vtss_clock_dpll_state_t {
    BOOL pll_freq_lock;     /**< PLL is stabilized to the selected frequency */
    BOOL pll_phase_lock;    /**< PLL is phase locked to incoming clock */
    BOOL pll_losx;          /**< PLL the currently selected reference input fails */
    BOOL pll_lol;           /**< PLL loss of lock */
    BOOL pll_dig_hold_vld;  /**< PLL Hold-over stack is filled with enough samples*/
} vtss_clock_dpll_state_t;

/**
 * \brief parameter for returning the clock input state.
 */
typedef struct vtss_clock_input_state_t {
    BOOL los;    /**< External Loss Of Signal */
    BOOL pfm;    /**< Precise frequency out of range */
    BOOL cfm;    /**< Coarse frequency out of range */
    BOOL scm;    /**< Single Cycle missed */
    BOOL lol;    /**< Loss of Lock */
} vtss_clock_input_state_t;

/**
 * \brief parameter for setting the alarm enables which control the input selection
 */
typedef struct vtss_clock_input_alarm_ena_t {
  BOOL los;   /**< Set to TRUE when Loss Of Signal alarm should influence the source selection */
  BOOL pfm;   /**< Set to TRUE when Precise frequency monitor alarm should influence the source selection */
  BOOL cfm;   /**< Set to TRUE when Coarse frequency monitor alarm should influence the source selection */
  BOOL scm;   /**< Set to TRUE when Single Cycle monitor alarm should influence the source selection */
  BOOL gst;   /**< Set to TRUE when Guard Soak timer alarm should influence the source selection */
  BOOL lol;   /**< Set to TRUE when Loss of Lock alarm should influence the source selection */
} vtss_clock_input_alarm_ena_t;

/**
 * \brief parameter for setting input selection parameters
 */
typedef struct vtss_clock_input_conf_t {
  BOOL                         los_active_high; /**< Set to TRUE when Loss Of Signal input is active high.*/
  vtss_clock_input_alarm_ena_t alarm_ena;       /**< Collection of alarm enables */
} vtss_clock_input_conf_t;

/**
 * \brief parameter for setting up the Coarse Frequency Monitor (CFM)
 */
typedef struct vtss_clock_cfm_conf_t {
  u32 cfm_set_ppb;      /**< Maximum frequency offset in ppb detected by the CFM before CFM alarm is issued. [0..200000] */
  u32 cfm_clr_ppb;      /**< Minimum frequency offset in ppb detected by the CFM before CFM alarm is cleared. [0..200000] */
} vtss_clock_cfm_conf_t;

/**
 * \brief parameter for setting up the Precise Frequency Monitor (PFM)
 */
typedef struct vtss_clock_pfm_conf_t {
  u32 pfm_set_ppb;      /**< Maximum frequency offset in ppb detected by the PFM before PFM alarm is issued. [0..200000] */
  u32 pfm_clr_ppb;      /**< Minimum frequency offset in ppb detected by the PFM before PFM alarm is cleared. [0..200000] */
} vtss_clock_pfm_conf_t;

/**
 * \brief parameter for setting up the GST
 */
typedef struct vtss_clock_gst_conf_t {
  u32 disqualification_time_us; /**< Disqualification time in micro seconds [1 us .. 1500s] */
  u32 qualification_time_us;    /**< Qualification time in micro seconds    [1 us .. 1500s] */
                                /**< 1/255 <= (diqualification_time_us/qualification_time_us) <= 255 */
  BOOL los;   /**< Set to TRUE when Loss Of Signal alarm should be source for GST */
  BOOL pfm;   /**< Set to TRUE when Precise frequency monitor alarm should be source for GST */
  BOOL cfm;   /**< Set to TRUE when Coarse frequency monitor alarm should be source for GST */
  BOOL scm;   /**< Set to TRUE when Single Cycle monitor alarm should be source for GST */
  BOOL lol;   /**< Set to TRUE when Loss of Lock alarm should be source for GST */
} vtss_clock_gst_conf_t;

// ***************************************************************************
//
//  Direct register access functions to be used for testing
//
// ***************************************************************************

/**
 * \brief Directly read from a HW register
 * \param inst [IN]         Handle to an API instance.
 * \param addr [IN]         Address
 * \param value [OUT]       Read value
 *
 * \return Return code.
 */
vtss_rc vtss_clock_rd(const vtss_inst_t  inst,
                      const u32          addr,
                      u32                *const value);

/**
 * \brief Directly write to a HW register
 * \param inst [IN]         Handle to an API instance.
 * \param addr [IN]         Address
 * \param value [IN]        Write value
 *
 * \return Return code.
 */
vtss_rc vtss_clock_wr(const vtss_inst_t  inst,
                      const u32          addr,
                      const u32          value);

/**
 * \brief Directly write to field(s) of a HW register (Read-Modify-Write)
 * \param inst [IN]         Handle to an API instance.
 * \param addr [IN]         Address
 * \param value [IN]        Write value
 * \param mask [IN]         Mask value, defines which bits can be changed
 *
 * \return Return code.
 */
vtss_rc vtss_clock_wrm(const vtss_inst_t  inst,
                       const u32          addr,
                       const u32          value,
                       const u32          mask);

// ***************************************************************************
//
//  Configuration API
//
// ***************************************************************************


/**
 * \brief Set global enable state
 * \param inst [IN]        Handle to an API instance.
 * \param ena [IN]         Enable/Disable flag
 *
 * \return Return code.
 */
vtss_rc vtss_clock_global_enable_set(const vtss_inst_t                 inst,
                                     const vtss_clock_global_enable_t  ena);

/**
 * \brief Get global enable state
 * \param inst [IN]        Handle to an API instance.
 * \param ena [OUT]        Enable/Disable flag
 *
 * \return Return code.
 */
vtss_rc vtss_clock_global_enable_get(const vtss_inst_t                inst,
                                     vtss_clock_global_enable_t       *ena);

/**
 * \brief Global SW Reset for the clock. Resets logic but not the configuration
 * \param inst [IN]        Handle to an API instance.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_global_sw_reset(const vtss_inst_t                 inst);

/**
 * \brief Shut down the clock HW. Called before a sw reset. Sets the Internal core clock back to default
 * \param inst [IN]        Handle to an API instance.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_shutdown(const vtss_inst_t                 inst);

/**
 * \brief Set Clock selection mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         Mode of clock selection and selected Clock input in manual mode [0..x].
 *
 * \return Return code.
 */
vtss_rc vtss_clock_selection_mode_set(const vtss_inst_t                 inst,
                                      const vtss_clock_dpll_inst_t      dpll,
                                      const vtss_clock_selection_conf_t *const conf);

/**
 * \brief Get Clock selection mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [OUT]        Mode of clock selection and selected Clock input in manual mode [0..x].
 *
 * \return Return code.
 */
vtss_rc vtss_clock_selection_mode_get(const vtss_inst_t             inst,
                                      const vtss_clock_dpll_inst_t  dpll,
                                      vtss_clock_selection_conf_t   *const conf);

/**
 * \brief Set Clock operation mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         Mode of clock operation.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_operation_conf_set(const vtss_inst_t                 inst,
                                      const vtss_clock_dpll_inst_t      dpll,
                                      const vtss_clock_dpll_conf_t      *const conf);

/**
 * \brief Get Clock operation mode.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [OUT]        Mode of clock operation.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_operation_conf_get(const vtss_inst_t             inst,
                                      const vtss_clock_dpll_inst_t  dpll,
                                      vtss_clock_dpll_conf_t        *const conf);

/**
 * \brief Set Holdover stack configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         configuration values
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_conf_set(const vtss_inst_t                 inst,
                                     const vtss_clock_dpll_inst_t      dpll,
                                     const vtss_clock_ho_stack_conf_t  *const conf);

/**
 * \brief Get Holdover stack configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param conf [IN]         configuration values
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_conf_get(const vtss_inst_t                 inst,
                                     const vtss_clock_dpll_inst_t      dpll,
                                     vtss_clock_ho_stack_conf_t        *const conf);

/**
 * \brief Get Holdover stack content (for debug purpose)
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param cont [IN]         Ho stack content
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_content_get(const vtss_inst_t                 inst,
                                        const vtss_clock_dpll_inst_t      dpll,
                                        vtss_clock_ho_stack_content_t     *const cont);
/**
 * \brief Set Clock dpll frequency adjustment in DCO mode (directly influence the controller).
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param offset [IN]       Clock ratio frequency offset in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_dco_frequency_offset_set(const vtss_inst_t               inst,
                                            const vtss_clock_dpll_inst_t    dpll,
                                            const i64                       offset);

/**
 * \brief Get Clock dpll frequency adjustment in DCO mode (directly influence the controller).
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param offset [OUT]      Clock ratio frequency offset in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_dco_frequency_offset_get(const vtss_inst_t               inst,
                                            const vtss_clock_dpll_inst_t    dpll,
                                            i64                             *const offset);

/**
 * \brief Set Output Filter Bandwidth.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param bw_100uhz [IN]    Filtering bandwidth in untis of 100uHz the lowest limit is 300 uHz
 *                          A value of 0 disables the filter (Power down).
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_bw_set(const vtss_inst_t                  inst,
                                        const u8                           clock_output,
                                        const u32                          bw_100uhz);

/**
 * \brief Get Output Filter Bandwidth.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param bw_100uhz [OUT]   Filtering bandwidth in untis of 100uHz
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_bw_get(const vtss_inst_t                  inst,
                                        const u8                           clock_output,
                                        u32                                *bw_100uhz);

/**
 * \brief Trigger Output Filter to immediately lock to current frequency offset without low-pass filtering
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_lock_fast_set(const vtss_inst_t                  inst,
                                               const u8                           clock_output);

/**
 * \brief Check if fast lock has completed.
 * \param inst [IN]             Handle to an API instance.
 * \param clock_output [IN]     Clock output port number
 * \param lock_completed [OUT]  fast lock has completed
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_filter_lock_fast_get(const vtss_inst_t                  inst,
                                               const u8                           clock_output,
                                               BOOL                               *lock_completed);
/**
 * \brief Set Output Filter Phase Slope Limiter (PSL) configuration
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param conf [IN]         configuration values
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_psl_conf_set(const vtss_inst_t                  inst,
                                       const u8                           clock_output,
                                       const vtss_clock_psl_conf_t        *const conf);

/**
 * \brief Get Output Filter Phase Slope Limiter (PSL) configuration
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param conf [OUT]        Filtering bandwidth in untis of 100uHz
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_psl_conf_get(const vtss_inst_t                  inst,
                                       const u8                           clock_output,
                                       vtss_clock_psl_conf_t              *const conf);

/**
 * \brief Set Clock dpll frequency adjustment (influence the respective output filter).
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param adj [IN]          Clock ratio frequency offset in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_frequency_set(const vtss_inst_t               inst,
                                     const u8                        clock_output,
                                     const i64                       adj);

/**
 * \brief Get Clock dpll frequency adjustment (influence the respective output filter).
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param adj [OUT]         Clock ratio frequency offset in units of scaled ppb (parts pr billion) i.e. ppb*2**-16.
 *                          ratio > 0 => clock runs faster.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_frequency_get(const vtss_inst_t               inst,
                                     const u8                        clock_output,
                                     i64                             *const adj);

/**
 * \brief Set Clock dpll phase adjustment.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port mask, i.e. setting bit x enables phase adjustment on output x
 * \param adj [IN]          Clock phase offset in units of scaled ns i.e. ns*2**-16.
 *                          ratio > 0 => clock phase is advanced.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_phase_set(const vtss_inst_t               inst,
                                 const u8                        clock_output,
                                 const i32                       adj);

/**
 * \brief Get Clock dpll phase adjustment.
 * \param inst [IN]         Handle to an API instance.
 * \param adj_ongoing [OUT] TRUE if the phase adjust is ongoing, FALSE otherwise.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_adj_phase_get(const vtss_inst_t               inst,
                                 BOOL                            *const adj_ongoing);

/**
 * \brief Set Clock input priority.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         configuration values, Priority - 0 is highest priority 
 *
 * \return Return code.
 */
vtss_rc vtss_clock_priority_set(const vtss_inst_t                     inst,
                                const vtss_clock_dpll_inst_t          dpll,
                                const u8                              clock_input,
                                const vtss_clock_priority_selector_t  *const conf);

/**
 * \brief Get Clock input priority.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param clock_input [IN]  Clock input port number
 * \param conf [OUT]        configuration values, Priority - 0 is highest priority 
 *
 * \return Return code.
 */
vtss_rc vtss_clock_priority_get(const vtss_inst_t               inst,
                                const vtss_clock_dpll_inst_t    dpll,
                                const u8                        clock_input,
                                vtss_clock_priority_selector_t  *const conf);

/**
 * \brief Set Clock input frequency.
 * \param inst [IN]                   Handle to an API instance.
 * \param clock_input [IN]            Clock input port number
 * \param freq_khz [IN]               frequency in KHz, the frequency is rounded to the closest multiple of 8 KHz.
 *                                    freq_khz < 8 => clock input qualifier is disabled
 * \param use_internal_clock_src [IN] If TRUE, select an internally provided clock as source
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_set(const vtss_inst_t               inst,
                                       const u8                        clock_input,
                                       const u32                       freq_khz,
                                       const BOOL                      use_internal_clock_src);

/**
 * \brief Get Clock input frequency.
 * \param inst [IN]                    Handle to an API instance.
 * \param clock_input [IN]             Clock input port number
 * \param freq_khz [OUT]               frequency in KHz, freq_khz < 8 => clock input qualifier is disabled
 * \param use_internal_clock_src [OUT] An internally provided clock is used as source, if TRUE
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_get(const vtss_inst_t               inst,
                                       const u8                        clock_input,
                                       u32                             *const freq_khz,
                                       BOOL                            *const use_internal_clock_src);

/**
 * \brief Set Clock input frequency with ratio.
 * \param inst [IN]                   Handle to an API instance.
 * \param clock_input [IN]            Clock input port number
 * \param freq_khz [IN]               frequency in KHz, the frequency is rounded to the closest multiple of 8 KHz.
 *                                    freq_khz < 8 => clock input qualifier is disabled
 * \param ratio [IN]                  A ratio the freq_khz will be mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 * \param use_internal_clock_src [IN] If TRUE, select an internally provided clock as source
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_ratio_set(const vtss_inst_t               inst,
                                             const u8                        clock_input,
                                             const u32                       freq_khz,
                                             const vtss_clock_ratio_t        *const ratio,
                                             const BOOL                      use_internal_clock_src);

/**
 * \brief Get Clock input frequency with ratio.
 * \param inst [IN]                    Handle to an API instance.
 * \param clock_input [IN]             Clock input port number
 * \param freq_khz [OUT]               frequency in KHz, freq_khz < 8 => clock input qualifier is disabled
 * \param ratio [OUT]                  A ratio the freq_khz was mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 * \param use_internal_clock_src [OUT] An internally provided clock is used as source, if TRUE
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_frequency_ratio_get(const vtss_inst_t               inst,
                                             const u8                        clock_input,
                                             u32                             *const freq_khz,
                                             vtss_clock_ratio_t              *const ratio,
                                             BOOL                            *const use_internal_clock_src);

/**
 * \brief Set Clock output frequency.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param freq_khz [IN]     frequency in KHz.
 *                          freq_khz = 0 disables the clock
 * \param par_freq_khz [IN] parallel frequency in KHz. With parallel frequency the clock output of the
 *                          DF2F for the parallel data towards the core is ment.
 *                          Maximum parallel frequency is 400 MHz, minimum parallel frequency is 31.25 MHz.
 *                          Higher frequencies provide better jitter performance.
 *                          par_freq_khz = 0 disables the clock
 *
 *                          Note: Only one of the clocks can be active. Either freq_khz or par_freq_khz must be 0.
 *                          For selected frequencies there is a possibility that both clocks can be used.
 *                          The possible combinations can be looked up in DS1009-DPLL-Freq-Calc.xlsm and implemented on request.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_set(const vtss_inst_t               inst,
                                        const u8                        clock_output,
                                        const u32                       freq_khz,
                                        const u32                       par_freq_khz);

/**
 * \brief Get Clock output frequency.
 * \param inst [IN]          Handle to an API instance.
 * \param clock_output [IN]  Clock output port number
 * \param freq_khz [OUT]     frequency in KHz, freq_khz = 0, clock is disbaled
 * \param par_freq_khz [OUT] parallel frequency in KHz, par_freq_khz = 0, clock is disbaled
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_get(const vtss_inst_t               inst,
                                        const u8                        clock_output,
                                        u32                             *const freq_khz,
                                        u32                             *const par_freq_khz);

/**
 * \brief Set Clock output frequency.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param freq_khz [IN]     frequency in KHz.
 *                          freq_khz = 0 disables the clock
 * \param par_freq_khz [IN] parallel frequency in KHz. With parallel frequency the clock output of the
 *                          DF2F for the parallel data towards the core is ment.
 *                          Maximum parallel frequency is 400 MHz, minimum parallel frequency is 31.25 MHz.
 *                          Higher frequencies provide better jitter performance.
 *                          par_freq_khz = 0 disables the clock
 *
 *                          Note: Only one of the clocks can be active. Either freq_khz or par_freq_khz must be 0.
 *                          For selected frequencies there is a possibility that both clocks can be used.
 *                          The possible combinations can be looked up in DS1009-DPLL-Freq-Calc.xlsm and implemented on request.
 * \param ratio [IN]        A ratio the freq_khz will be mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_ratio_set(const vtss_inst_t               inst,
                                              const u8                        clock_output,
                                              const u32                       freq_khz,
                                              const u32                       par_freq_khz,
                                              const vtss_clock_ratio_t        *const ratio);

/**
 * \brief Get Clock output frequency.
 * \param inst [IN]          Handle to an API instance.
 * \param clock_output [IN]  Clock output port number
 * \param freq_khz [OUT]     frequency in KHz, freq_khz = 0, clock is disbaled
 * \param par_freq_khz [OUT] parallel frequency in KHz, par_freq_khz = 0, clock is disbaled
 * \param ratio [OUT]        A ratio the freq_khz was mutiplied with.e.g. 66/64. I order to allow rational values for the frequency
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_frequency_ratio_get(const vtss_inst_t               inst,
                                              const u8                        clock_output,
                                              u32                             *const freq_khz,
                                              u32                             *const par_freq_khz,
                                              vtss_clock_ratio_t              *const ratio);

/**
 * \brief Set Clock output Voltage level.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param level_mv [IN]     Output Voltage in mV range [300..1275], 25 mV steps [Output level of es6514 is limited due to bug in a coil in the OB]
 *                          
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_level_set(const vtss_inst_t               inst,
                                    const u8                        clock_output,
                                    const u16                       level_mv);

/**
 * \brief Get Clock output Voltage level.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param level_mv [OUT]    Output Voltage in mV range [300..1275], 25 mV steps
 *                          
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_level_get(const vtss_inst_t               inst,
                                    const u8                        clock_output,
                                    u16                             *const level_mv);

/**
 * \brief Set Clock output selector.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param input [IN]     input selector.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_selector_set(const vtss_inst_t               inst,
                                       const u8                        clock_output,
                                       const vtss_clock_input_selector_t *const input);

/**
 * \brief Get Clock output selector.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_output [IN] Clock output port number
 * \param input [OUT]       input selector.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_output_selector_get(const vtss_inst_t               inst,
                                       const u8                        clock_output,
                                       vtss_clock_input_selector_t     *const input);

/**
 * \brief Set Clock input alarm configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Alarm enable for various qualifier arlarms and LOS active level
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_alarm_conf_set(const vtss_inst_t               inst,
                                        const u8                        clock_input,
                                        const vtss_clock_input_conf_t   *const conf);

/**
 * \brief Get Clock input alarm configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [OUT]        Alarm enable for various qualifier arlarms and LOS active level
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_alarm_conf_get(const vtss_inst_t               inst,
                                        const u8                        clock_input,
                                        vtss_clock_input_conf_t         *const conf);

/**
 * \brief Set Clock input Coarse Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Coarse Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_cfm_conf_set(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      const vtss_clock_cfm_conf_t  *const conf);

/**
 * \brief Get Clock input Coarse Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Coarse Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_cfm_conf_get(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      vtss_clock_cfm_conf_t        *const conf);

/**
 * \brief Set Clock input Precise Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Precise Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_pfm_conf_set(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      const vtss_clock_pfm_conf_t  *const conf);

/**
 * \brief Get Clock input Precise Frequency Monitor configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Precise Frequency Monitor Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_pfm_conf_get(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      vtss_clock_pfm_conf_t        *const conf);
/**
 * \brief Set Clock input guard soak timer configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [IN]         Guard Soak Timer Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_gst_conf_set(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      const vtss_clock_gst_conf_t  *const conf);

/**
 * \brief Get Clock input guard soak timer configuration.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param conf [OUT]        Guard Soak Timer Configurations
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_gst_conf_get(const vtss_inst_t            inst,
                                      const u8                     clock_input,
                                      vtss_clock_gst_conf_t        *const conf);

// ***************************************************************************
//
//  Status API
//
// ***************************************************************************

/**
 * \brief get Clock selector state.
 * \param inst [IN]             Handle to an API instance.
 * \param dpll [IN]             DPLL instance number [0..x].
 * \param selector_state [OUT]  selector state
 * \param clock_input [OUT]     Clock input port number - if in locked state
 *
 * \return Return code.
 */
vtss_rc vtss_clock_selector_state_get(const vtss_inst_t             inst,
                                      const vtss_clock_dpll_inst_t  dpll,
                                      vtss_clock_selector_state_t   *const selector_state,
                                      u8                            *const clock_input);

/**
 * \brief get Clock pll state.
 * \param inst [IN]         Handle to an API instance.
 * \param dpll [IN]         DPLL instance number [0..x].
 * \param pll_state [OUT]   pll state
 *
 * \return Return code.
 */
vtss_rc vtss_clock_dpll_state_get(const vtss_inst_t             inst,
                                  const vtss_clock_dpll_inst_t  dpll,
                                  vtss_clock_dpll_state_t       *const pll_state);

/**
 * \brief get Clock frequency offset stored in ho stack
 * \param inst [IN]       Handle to an API instance.
 * \param dpll [IN]       DPLL instance number [0..x].
 * \param offset [OUT]    Current frequency offset stored in the holdover stack in units of scaled ppb (parts per billion) i.e. ppb*2**-16.
 *
 * \return Return code.
 */
vtss_rc vtss_clock_ho_stack_frequency_offset_get(const vtss_inst_t             inst,
                                                 const vtss_clock_dpll_inst_t  dpll,
                                                 i64                           *const offset);

/**
 * \brief get Clock input state.
 * \param inst [IN]         Handle to an API instance.
 * \param clock_input [IN]  Clock input port number
 * \param input_state [OUT] input state
 *
 * \return Return code.
 */
vtss_rc vtss_clock_input_state_get(const vtss_inst_t            inst,
                                  const u8                      clock_input,
                                  vtss_clock_input_state_t      *const input_state);

// ***************************************************************************
//
//  Event (interrupt) handling API
//
// ***************************************************************************

/**
 * \brief Define event (interrupt) types related to the Vitesse Synce Clock inputs.
 **/
#define VTSS_CLOCK_INPUT_LOS_EV     (1 << 0)  /**< External Loss Of Signal event */
#define VTSS_CLOCK_INPUT_PFM_EV     (1 << 1)  /**< Precise frequency monitor event */
#define VTSS_CLOCK_INPUT_CFM_EV     (1 << 2)  /**< Coarse frequency monitor event */
#define VTSS_CLOCK_INPUT_SCM_EV     (1 << 3)  /**< Single Cycle monitor event */
#define VTSS_CLOCK_INPUT_GST_EV     (1 << 4)  /**< Guard Soak timer event */
#define VTSS_CLOCK_INPUT_LOL_EV     (1 << 5)  /**< Loss of Lock event */
typedef u32 vtss_clock_input_event_type_t; /**< Int events: Single event or 'OR' multiple events above */

/**
 * \brief Clock input event polling function called by interrupt or periodicly
 *
 * \param inst        [IN]  Target instance reference.
 * \param clock_input [IN]  Clock input port number
 * \param ev_mask     [OUT] Event type mask of active events
 *
 * \note The \e ev_mask parameter can be either a single event_type or
 * multiple event types. If invoked by a
 * processor interrupt signal, the type of event to check for may be
 * narrowed in to specific events.
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_input_event_poll(const vtss_inst_t               inst,
                                    const u8                        clock_input,
                                    vtss_clock_input_event_type_t   *const ev_mask);

/**
 * \brief Enable clock input event generation for a specific event type
 *
 * \param inst        [IN]  Target instance reference.
 * \param clock_input [IN]  Clock input port number
 * \param ev_mask     [IN]  Event type(s) to control (mask)
 * \param enable      [IN]  Enable or disable events
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_input_event_enable(const vtss_inst_t                     inst,
                                      const u8                              clock_input,
                                      const vtss_clock_input_event_type_t   ev_mask,
                                      const BOOL                            enable);

/**
 * \brief Define event (interrupt) types related to the Vitesse Synce Clock dpll's.
 *
 **/
//    VTSS_CLOCK_DPLL_FREQ_LOCK_EV =      (1 << 0), /**< Loss Of Frequency lock event */
//    VTSS_CLOCK_DPLL_PH_LOCK_EV   =      (1 << 1), /**< Loss Of Phase lock event */
//    VTSS_CLOCK_DPLL_LOSX         =      (1 << 2), /**< PLL the currently selected reference input fails event */
//    VTSS_CLOCK_DPLL_LOL          =      (1 << 3), /**< PLL loss of lock event */
#define VTSS_CLOCK_DPLL_STATE_CHANGE_EV   (1 << 0) /**< State change event in EEC FSM */
typedef u32 vtss_clock_dpll_event_type_t; /**< Int events: Currently only Single event */

/**
 * \brief Clock dpll event polling function called by interrupt or periodicly
 *
 * \param inst        [IN]  Target instance reference.
 * \param dpll        [IN]  DPLL instance number [0..x].
 * \param ev_mask     [OUT] Event type mask of active events
 *
 * \note The \e ev_mask parameter can be either a single event_type or
 * multiple event types. If invoked by a
 * processor interrupt signal, the type of event to check for may be
 * narrowed in to specific events.
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_dpll_event_poll(const vtss_inst_t              inst,
                                   const vtss_clock_dpll_inst_t   dpll,
                                   vtss_clock_dpll_event_type_t   *const ev_mask);

/**
 * \brief Enable clock dpll event generation for a specific event type
 *
 * \param inst        [IN]  Target instance reference.
 * \param dpll        [IN]  DPLL instance number [0..x].
 * \param ev_mask     [IN]  Event type(s) to control (mask)
 * \param enable      [IN]  Enable or disable events
 *
 * \return Return code.
 **/
vtss_rc vtss_clock_dpll_event_enable(const vtss_inst_t                  inst,
                                     const vtss_clock_dpll_inst_t       dpll,
                                     const vtss_clock_dpll_event_type_t ev_mask,
                                     const BOOL                         enable);

#ifdef __cplusplus
}
#endif
#endif /* VTSS_FEATURE_OMEGA */
#endif // _VTSS_CLOCK_API_H_


// ***************************************************************************
//
//  End of file.
//
// ***************************************************************************
:@byteposiÔ:	@str" #ifndef _VTSS_CLOCK_API_H_
:@line_cacheo:Parslet::Source::LineCache:@line_endse:!Parslet::Source::RangeSearch[iPipiqiriviièi’iÍiÓiÔi
i%i&iBiCiciviÉiäiãi⁄i›iiÛiBiCiGiüi§iÕiŒi“ii2i7iZi[i_ióiúi©i´i	ibi…i,ióiiwiñióiõi”iÿiÈi0iÜi•i¶ißi´i‰iÈiˆi¯iKiùiÔiK	iù	i˙	i
i
i
iV
i[
ih
ij
i∞
iı
iii$i(i~i–i i<i=i>iBi~iÇi©i&iîi#i<i?iCi{iißiiøi!iÉiùiûi¢i‰iËii•iBi`iai®i¨iËiÏii§i¸i[iùiæiøi√i
ii>izi¡i„i‰iËiFiJini∞iÙi
iiiMiQi^i`i∞i
ikiÜiáiãi∆i i˜ivi”iÚiÛi˜i)i-iVi¶iiEiziœiÍiÎiÔi(i,iViáiøiˆi#iIieifijiæi¬iiRiøi+iìi˜iW iw ix i| i∑ iª i‰ iQ!i•!i¿!i¡!i≈!i"i"i6"i≤"i/#iH#iI#iM#iî#iò#iø#i;$i∏$i—$i“$i÷$i%i%i,%iã%iÍ%iR&iß&i'if'i¡'i(i-(i.(i}(iÄ(iº(iø(i)i)i)i>)iu)iô)i¿)i√)i€)iﬂ)i*i=*iu*iv*iz*i§*i€*iˇ*i'+i*+iB+iF+iu+i§+i’+i÷+i⁄+i$,i[,i,iß,iÒ,iÙ,i-i-i@-ip-i°-i“-i”-i".i%.i;.i>.iç.ié.iè.iì.iµ.iÎ.i/i/i5/i9/iÜ/i”/i‘/iÿ/i˙/i00i_0ib0iz0i~0i 0i1i1i1il1i¢1i•1iΩ1i¡1i2i2i2i{2i±2i¥2iÃ2i–2i3i3i3i>3iu3iÆ3i4i4i-4i14i4iÕ4i#5i$5i(5iL5iÉ5iº5i 6i#6i;6i?6iâ6i”6i%7i&7i*7iN7iÖ7iæ7iÛ7iˆ7i8i8i`8iÆ8i9i9i	9i-9id9iù9i“9i’9iÌ9iÒ9i;:iÖ:i◊:iÿ:i‹:i;i?;ix;i©;i¨;iƒ;i»;i<ib<i∑<i∏<iº<iË<i=iX=iâ=iå=i§=i®=iı=iB>ió>iò>iú>i’>i?iE?ir?iu?iç?ië?i·?i1@iâ@iç@iÏ@i#Ai\Ai—AiBiBi(Bi,Bi~Bi–Bi%Ci&Ci*CiâCi¿Ci˘CinDi™Di≠Di≈Di…DiEimEi…Ei EiŒEiıEi,FiaFi¿FiGiGi&Gi*Gi{Gi‘Gi+Hi,Hi0HiWHiéHi√HiIi	Ii!Ii%IivIiœIi'Ji(Ji,JióJiŒJiKiKiKi"KizKi€Ki‹Ki‡KiLiGLiÄLi∏LiªLi”Li◊Li/MièMiÛMi˜Mi;NirNißNiÿNi€NiÛNi˜NiGOiüOi˜Oi¯Oi¸Oi@PiwPi¨PiÔPiÚPi
QiQi^Qi∂QiRiRiRikRi¢Ri◊RiLSiàSiãSi£SißSiÚSiETiêTiëTiïTiÌTi$UiYUiÕUi	ViVi$Vi(VisVi∆ViWiWiWiHWiWiÎWi@XiÇXiÖXiùXi°XiËXi7Yi~YiYiÉYiÆYiÂYi7Zi:ZiRZiVZiùZiÛZiÙZi¯Zi[iS[iå[i¿[i\i\i/\i3\i\iÀ\i]ir]is]iw]iõ]i“]i^i?^iì^iñ^iÆ^i≤^i¯^i>_iã_iŸ_i⁄_iﬁ_i`iD`iÇ`iı`iMai™ai≠ai≈ai…aibijbiªbicici ciEciáci∆ci1diêdiìdi´diØdi¸diPei®eifififiDfiÖfi√fi6giégihi|hihióhiõhiÓhiHiiüii˙ii`jiajiejiïji◊jikiÅkilinliqliâliçli‡li:miòmiÛmi`nianieniãni¬ni˜ni%oiaoi»oipiÖpi◊piqiqiçqi˜qixri{riìrióriÂri;siçsi‰siÂsiÈsitiGti}tiÃti(ui+uiCuiGuiïuiÎuiDvi¢vi£vißviÕviwi9wigwi£wi
xi[xi«xiyiYyi\yiœyi9zi∫ziA{iD{i\{i`{i¥{i|ih|iƒ|i!}i"}i&}iL}iÑ}i∫}i	~ie~iÈ~iÏ~iii\i∏iÄizÄi◊ÄiÿÄi‹ÄiÅi=ÅirÅiÇi"Çi%Çi=ÇiAÇiãÇi›Çi,Éi-Éi1Éi[ÉiíÉi«ÉiÑi4Ñi7ÑiOÑiSÑiùÑiÔÑiEÖiFÖiJÖioÖi¶Öi€ÖiÜiÜiÜi#ÜipÜi≈Üiáiái"áiGái~ái≥áiﬂái‚ái˙ái˛áiKài†àiˆài˜ài˚ài*âiaâiïâiÒâiÙâiäiäi^äi≥äi	ãi
ãiãi=ãitãi®ãiåiåiåi#åiqåi∆åiçiçi!çicçiöçiŒçiéiéi-éi1éizéi éièièi èibèiôèiÕèiêiêi,êi0êiyêi…êiëiëiëibëiôëiÕëiíiíi-íi1íizíi íiìiìi ìicìiöìiŒìiîiîi.îi2îi{îiÀîiïi ïiZïiëïi≈ïiñiñiñi ñiiñiπñi
óióióiIóiÄói¥óióiÛóiòiòiXòi®òi˘òi˙òiIôiLôi[ôi^ôi≠ôiÆôi≤ôi÷ôiöiNöi}öi öiÕöiÂöiÈöi3õi}õiÿõi1úi2úi6úiUúiåúi≈úiÎúiÓúiùi
ùiPùiñùiÈùiÍùiÓùi&ûi[ûiíûiüi!üi9üi=üiíüiÁüiF†iG†iK†il†i£†i◊†iˇ†i°i°i°id°i±°i¢i¢iV¢iY¢i|¢i¢iŒ¢iœ¢i”¢i'£i,£iÄ£i÷£i+§i|§i…§i•i|•i}•iÅ•i–•i”•i
¶i>¶i{¶i~¶i≈¶iÓ¶i3ßiVßiYßiqßivßi¿ßi®if®ig®ik®i≥®i∂®iÌ®i!©i]©ií©iï©i≠©i≤©i™i]™i≤™i´i´i´i`´ic´ih´i¡´i¨iâ¨i‹¨i5≠iè≠iê≠iî≠i‚≠iÂ≠iÆiUÆiíÆiïÆi‹ÆiØiJØimØipØiàØiçØi’Øi∞ip∞iq∞iu∞iº∞iø∞iˆ∞i/±ik±i†±i£±iª±i¿±i≤i\≤i≠≤i˛≤iˇ≤i≥i≥i≥i;≥iX≥iY≥iZ≥i©≥i¨≥iΩ≥i¿≥i¥:@last_line_endi¥{;o;;o;	;
@
;i
;"!#define _VTSS_CLOCK_API_H_

;@{;o;;o;	;
@
;i&;""#include <vtss/api/types.h>

;@{;o;;o;	;
@
;iC;"%#if defined(VTSS_FEATURE_CLOCK)
;@{;o;;o;	;
@
;ic;"#ifdef __cplusplus
;@{:keywordo;;o;	;
@
;iv;"extern;@:stringo;;o;	;
@
;i};""C";@; [^{;o;;o;	;
@
;iÉ;"#endif

;@{
;o;;o;	;
@
;i§;"typedef;@:type_aliaso;;o;	;
@
;i¨;"
BOOL ;@:typedef_nameo;;o;	;
@
;i±;"vtss_clock_global_enable_t;@:
array[ :cap0{
;o;;o;	;
@
;i7;"typedef;@;o;;o;	;
@
;i?;"u8 ;@;o;;o;	;
@
;iB;"vtss_clock_dpll_inst_t;@;[ ;0{
;o;;o;	;
@
;iú;"typedef;@:enum_type_declare{;o;;o;	;
@
;i§;"	enum;@:
enums[{:	enum{:enum_nameo;;o;	;
@
;iØ;"'VTSS_CLOCK_SELECTION_MODE_DISABLED;@;0{;{;o;;o;	;
@
;i;"%VTSS_CLOCK_SELECTION_MODE_MANUEL;@;0{;{;o;;o;	;
@
;if;"5VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_NONREVERTIVE;@;0{;{;o;;o;	;
@
;iÕ;"2VTSS_CLOCK_SELECTION_MODE_AUTOMATIC_REVERTIVE;@;0{;{;o;;o;	;
@
;i0;".VTSS_CLOCK_SELECTION_MODE_FORCED_HOLDOVER;@;0{;{;o;;o;	;
@
;iõ;".VTSS_CLOCK_SELECTION_MODE_FORCED_FREE_RUN;@;0{;{;o;;o;	;
@
;i;")VTSS_CLOCK_SELECTION_MODE_FORCED_DCO;@;0;o;;o;	;
@
;iy;" vtss_clock_selection_mode_t;@;[ ;0{
;o;;o;	;
@
;iÿ;"typedef;@:struct_type_declare{:struct_members[{:member{:normal{	:	typeo;;o;	;
@
;iÌ;"!vtss_clock_selection_mode_t ;@:	nameo;;o;	;
@
;i	;"	mode;@;[ ;0{;{;{	; o;;o;	;
@
;i4;"!u8                          ;@;!o;;o;	;
@
;iP;"clock_input;@;[ ;0;o;;o;	;
@
;ià;" vtss_clock_selection_conf_t;@;[ ;0{
;o;;o;	;
@
;iÈ;"typedef;@;{;o;;o;	;
@
;iÒ;"	enum;@;[{;{;o;;o;	;
@
;i¸;"%VTSS_CLOCK_SELECTOR_STATE_LOCKED;@;0{;{;o;;o;	;
@
;iO;"'VTSS_CLOCK_SELECTOR_STATE_HOLDOVER;@;0{;{;o;;o;	;
@
;i°;"&VTSS_CLOCK_SELECTOR_STATE_FREERUN;@;0{;{;o;;o;	;
@
;iÛ;""VTSS_CLOCK_SELECTOR_STATE_DCO;@;0{;{;o;;o;	;
@
;iO	;")VTSS_CLOCK_SELECTOR_STATE_REF_FAILED;@;0{;{;o;;o;	;
@
;i°	;"(VTSS_CLOCK_SELECTOR_STATE_ACQUIRING;@;0;o;;o;	;
@
;i¸	;" vtss_clock_selector_state_t;@;[ ;0{
;o;;o;	;
@
;i[
;"typedef;@;{;o;;o;	;
@
;ic
;"	enum;@;[{;{;o;;o;	;
@
;in
;"'VTSS_CLOCK_OPERATION_MODE_DISABLED;@;0{;{;o;;o;	;
@
;i¥
;"&VTSS_CLOCK_OPERATION_MODE_ENABLED;@;0;o;;o;	;
@
;i˜
;" vtss_clock_operation_mode_t;@;[ ;0{
;o;;o;	;
@
;iÇ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i≠;"!u32                         ;@;!o;;o;	;
@
;i…;"limit_ppb;@;[ ;0{;{;{	; o;;o;	;
@
;i*;"!BOOL                        ;@;!o;;o;	;
@
;iF;"phase_build_out_ena;@;[ ;0{;{;{	; o;;o;	;
@
;iò;"!BOOL                        ;@;!o;;o;	;
@
;i¥;"ho_based;@;[ ;0;o;;o;	;
@
;i%;"vtss_clock_psl_conf_t;@;[ ;0{
;o;;o;	;
@
;i;"typedef;@;{;[	{;{;{	; o;;o;	;
@
;i´;"!vtss_clock_operation_mode_t ;@;!o;;o;	;
@
;i«;"	mode;@;[ ;0{;{;{	; o;;o;	;
@
;i;"!u16                         ;@;!o;;o;	;
@
;i";"holdoff;@;[ ;0{;{;{	; o;;o;	;
@
;i√;"!u32                         ;@;!o;;o;	;
@
;iﬂ;"holdover;@;[ ;0{;{;{	; o;;o;	;
@
;i%;"!u16                         ;@;!o;;o;	;
@
;iA;"wtr;@;[ ;0;o;;o;	;
@
;iÖ;"vtss_clock_dpll_conf_t;@;[ ;0{
;o;;o;	;
@
;iË;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i;"
u32  ;@;!o;;o;	;
@
;i;"ho_post_filtering_bw;@;[ ;0{;{;{	; o;;o;	;
@
;i©;"
u8   ;@;!o;;o;	;
@
;iÆ;"ho_qual_time_conf;@;[ ;0;o;;o;	;
@
;iD;"vtss_clock_ho_stack_conf_t;@;[ ;0{;o;;o;	;
@
;ia;"L#define VTSS_CLOCK_HO_STACK_SIZE 12 /**< Size of the holdover stack */
;@{
;o;;o;	;
@
;iÏ;"typedef;@;{;[	{;{;{	; o;;o;	;
@
;i;"u64     ;@;!o;;o;	;
@
;i';"stack_value;@;[{:	expro;;o;	;
@
;i3;"VTSS_CLOCK_HO_STACK_SIZE;@;0{;{;{	; o;;o;	;
@
;i®;"u8      ;@;!o;;o;	;
@
;i∞;"ho_sel;@;[ ;0{;{;{	; o;;o;	;
@
;i ;"u8      ;@;!o;;o;	;
@
;i;"ho_min_fill_lvl;@;[ ;0{;{;{	; o;;o;	;
@
;i_;"BOOL    ;@;!o;;o;	;
@
;ig;"ho_filled;@;[ ;0;o;;o;	;
@
;iü;""vtss_clock_ho_stack_content_t;@;[ ;0{
;o;;o;	;
@
;i;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iB;"
u8   ;@;!o;;o;	;
@
;iG;"priority;@;[ ;0{;{;{	; o;;o;	;
@
;i~;"
BOOL ;@;!o;;o;	;
@
;iÉ;"enable;@;[ ;0;o;;o;	;
@
;i√;"#vtss_clock_priority_selector_t;@;[ ;0{
;o;;o;	;
@
;iJ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;ir;"
u32  ;@;!o;;o;	;
@
;iw;"num;@;[ ;0{;{;{	; o;;o;	;
@
;i¥;"
u32  ;@;!o;;o;	;
@
;iπ;"den;@;[ ;0;o;;o;	;
@
;iˆ;"vtss_clock_ratio_t;@;[ ;0{
;o;;o;	;
@
;iQ;"typedef;@;{;o;;o;	;
@
;iY;"	enum;@;[{;{;o;;o;	;
@
;id;"VTSS_CLOCK_INPUT_TYPE_DPLL;@;0{;{;o;;o;	;
@
;i¥;"VTSS_CLOCK_INPUT_TYPE_IN;@;0{;{;o;;o;	;
@
;i;"#VTSS_CLOCK_INPUT_TYPE_PURE_DCO;@;0;o;;o;	;
@
;im;"vtss_clock_input_type_t;@;[ ;0{
;o;;o;	;
@
;i ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i˚;"vtss_clock_input_type_t ;@;!o;;o;	;
@
;i;"input_type;@;[ ;0{;{;{	; o;;o;	;
@
;iz;"u8                      ;@;!o;;o;	;
@
;ií;"input_inst;@;[ ;0;o;;o;	;
@
;i’;" vtss_clock_input_selector_t;@;[ ;0{
;o;;o;	;
@
;i-;"typedef;@;{;[
{;{;{	; o;;o;	;
@
;iZ;"
BOOL ;@;!o;;o;	;
@
;i_;"pll_freq_lock;@;[ ;0{;{;{	; o;;o;	;
@
;i™;"
BOOL ;@;!o;;o;	;
@
;iØ;"pll_phase_lock;@;[ ;0{;{;{	; o;;o;	;
@
;iÙ;"
BOOL ;@;!o;;o;	;
@
;i˘;"pll_losx;@;[ ;0{;{;{	; o;;o;	;
@
;iI;"
BOOL ;@;!o;;o;	;
@
;iN;"pll_lol;@;[ ;0{;{;{	; o;;o;	;
@
;i~;"
BOOL ;@;!o;;o;	;
@
;iÉ;"pll_dig_hold_vld;@;[ ;0;o;;o;	;
@
;i—;"vtss_clock_dpll_state_t;@;[ ;0{
;o;;o;	;
@
;i,;"typedef;@;{;[
{;{;{	; o;;o;	;
@
;iZ;"
BOOL ;@;!o;;o;	;
@
;i_;"los;@;[ ;0{;{;{	; o;;o;	;
@
;iã;"
BOOL ;@;!o;;o;	;
@
;iê;"pfm;@;[ ;0{;{;{	; o;;o;	;
@
;i√;"
BOOL ;@;!o;;o;	;
@
;i»;"cfm;@;[ ;0{;{;{	; o;;o;	;
@
;i˙;"
BOOL ;@;!o;;o;	;
@
;iˇ;"scm;@;[ ;0{;{;{	; o;;o;	;
@
;i';"
BOOL ;@;!o;;o;	;
@
;i,;"lol;@;[ ;0;o;;o;	;
@
;iK;"vtss_clock_input_state_t;@;[ ;0{
;o;;o;	;
@
;i¬;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iÚ;"
BOOL ;@;!o;;o;	;
@
;i˜;"los;@;[ ;0{;{;{	; o;;o;	;
@
;iT;"
BOOL ;@;!o;;o;	;
@
;iY;"pfm;@;[ ;0{;{;{	; o;;o;	;
@
;i¡;"
BOOL ;@;!o;;o;	;
@
;i∆;"cfm;@;[ ;0{;{;{	; o;;o;	;
@
;i-;"
BOOL ;@;!o;;o;	;
@
;i2;"scm;@;[ ;0{;{;{	; o;;o;	;
@
;iï;"
BOOL ;@;!o;;o;	;
@
;iö;"gst;@;[ ;0{;{;{	; o;;o;	;
@
;i˘;"
BOOL ;@;!o;;o;	;
@
;i˛;"lol;@;[ ;0;o;;o;	;
@
;iY ;"!vtss_clock_input_alarm_ena_t;@;[ ;0{
;o;;o;	;
@
;iª ;"typedef;@;{;[{;{;{	; o;;o;	;
@
;iÊ ;""BOOL                         ;@;!o;;o;	;
@
;i!;"los_active_high;@;[ ;0{;{;{	; o;;o;	;
@
;iS!;""vtss_clock_input_alarm_ena_t ;@;!o;;o;	;
@
;ip!;"alarm_ena;@;[ ;0;o;;o;	;
@
;iß!;"vtss_clock_input_conf_t;@;[ ;0{
;o;;o;	;
@
;i";"typedef;@;{;[{;{;{	; o;;o;	;
@
;i8";"	u32 ;@;!o;;o;	;
@
;i<";"cfm_set_ppb;@;[ ;0{;{;{	; o;;o;	;
@
;i¥";"	u32 ;@;!o;;o;	;
@
;i∏";"cfm_clr_ppb;@;[ ;0;o;;o;	;
@
;i1#;"vtss_clock_cfm_conf_t;@;[ ;0{
;o;;o;	;
@
;iò#;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i¡#;"	u32 ;@;!o;;o;	;
@
;i≈#;"pfm_set_ppb;@;[ ;0{;{;{	; o;;o;	;
@
;i=$;"	u32 ;@;!o;;o;	;
@
;iA$;"pfm_clr_ppb;@;[ ;0;o;;o;	;
@
;i∫$;"vtss_clock_pfm_conf_t;@;[ ;0{
;o;;o;	;
@
;i%;"typedef;@;{;[{;{;{	; o;;o;	;
@
;i.%;"	u32 ;@;!o;;o;	;
@
;i2%;"disqualification_time_us;@;[ ;0{;{;{	; o;;o;	;
@
;iç%;"	u32 ;@;!o;;o;	;
@
;ië%;"qualification_time_us;@;[ ;0{;{;{	; o;;o;	;
@
;iT&;"
BOOL ;@;!o;;o;	;
@
;iY&;"los;@;[ ;0{;{;{	; o;;o;	;
@
;i©&;"
BOOL ;@;!o;;o;	;
@
;iÆ&;"pfm;@;[ ;0{;{;{	; o;;o;	;
@
;i	';"
BOOL ;@;!o;;o;	;
@
;i';"cfm;@;[ ;0{;{;{	; o;;o;	;
@
;ih';"
BOOL ;@;!o;;o;	;
@
;im';"scm;@;[ ;0{;{;{	; o;;o;	;
@
;i√';"
BOOL ;@;!o;;o;	;
@
;i»';"lol;@;[ ;0;o;;o;	;
@
;i(;"vtss_clock_gst_conf_t;@;[ ;0{:func_proto{;{	; o;;o;	;
@
;iﬂ);"vtss_rc ;@;!o;;o;	;
@
;iÁ);"vtss_clock_rd;@;[ ;0:	args[{;{	; o;;o;	;
@
;iı);"const vtss_inst_t  ;@;!o;;o;	;
@
;i*;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i$*;"const u32          ;@;!o;;o;	;
@
;i7*;"	addr;@;[ ;0{;{	; o;;o;	;
@
;iS*;"u32                *const ;@;!o;;o;	;
@
;im*;"
value;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iF+;"vtss_rc ;@;!o;;o;	;
@
;iN+;"vtss_clock_wr;@;[ ;0;$[{;{	; o;;o;	;
@
;i\+;"const vtss_inst_t  ;@;!o;;o;	;
@
;io+;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iã+;"const u32          ;@;!o;;o;	;
@
;iû+;"	addr;@;[ ;0{;{	; o;;o;	;
@
;i∫+;"const u32          ;@;!o;;o;	;
@
;iÕ+;"
value;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i-;"vtss_rc ;@;!o;;o;	;
@
;i-;"vtss_clock_wrm;@;[ ;0;$[	{;{	; o;;o;	;
@
;i'-;"const vtss_inst_t  ;@;!o;;o;	;
@
;i:-;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iW-;"const u32          ;@;!o;;o;	;
@
;ij-;"	addr;@;[ ;0{;{	; o;;o;	;
@
;iá-;"const u32          ;@;!o;;o;	;
@
;iö-;"
value;@;[ ;0{;{	; o;;o;	;
@
;i∏-;"const u32          ;@;!o;;o;	;
@
;iÀ-;"	mask;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i9/;"vtss_rc ;@;!o;;o;	;
@
;iA/;"!vtss_clock_global_enable_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i^/;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iÄ/;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i´/;"'const vtss_clock_global_enable_t  ;@;!o;;o;	;
@
;iÕ/;"ena;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i~0;"vtss_rc ;@;!o;;o;	;
@
;iÜ0;"!vtss_clock_global_enable_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i£0;"&const vtss_inst_t                ;@;!o;;o;	;
@
;iƒ0;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÔ0;"'vtss_clock_global_enable_t       *;@;!o;;o;	;
@
;i1;"ena;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i¡1;"vtss_rc ;@;!o;;o;	;
@
;i…1;"vtss_clock_global_sw_reset;@;[ ;0;$[{;{	; o;;o;	;
@
;i‰1;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i2;"	inst;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i–2;"vtss_rc ;@;!o;;o;	;
@
;iÿ2;"vtss_clock_shutdown;@;[ ;0;$[{;{	; o;;o;	;
@
;iÏ2;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i3;"	inst;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i14;"vtss_rc ;@;!o;;o;	;
@
;i94;""vtss_clock_selection_mode_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iW4;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iy4;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i•4;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i«4;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iÛ4;".const vtss_clock_selection_conf_t *const ;@;!o;;o;	;
@
;i5;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i?6;"vtss_rc ;@;!o;;o;	;
@
;iG6;""vtss_clock_selection_mode_get;@;[ ;0;$[{;{	; o;;o;	;
@
;ie6;"#const vtss_inst_t             ;@;!o;;o;	;
@
;iÉ6;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iØ6;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;iÕ6;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i˘6;"*vtss_clock_selection_conf_t   *const ;@;!o;;o;	;
@
;i7;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i8;"vtss_rc ;@;!o;;o;	;
@
;i8;""vtss_clock_operation_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i88;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iZ8;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÜ8;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i®8;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i‘8;".const vtss_clock_dpll_conf_t      *const ;@;!o;;o;	;
@
;i˝8;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÒ9;"vtss_rc ;@;!o;;o;	;
@
;i˘9;""vtss_clock_operation_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i:;"#const vtss_inst_t             ;@;!o;;o;	;
@
;i5:;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ia:;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;i:;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i´:;"*vtss_clock_dpll_conf_t        *const ;@;!o;;o;	;
@
;i–:;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i»;;"vtss_rc ;@;!o;;o;	;
@
;i–;;"!vtss_clock_ho_stack_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iÌ;;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i<;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i:<;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i\<;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iá<;".const vtss_clock_ho_stack_conf_t  *const ;@;!o;;o;	;
@
;i∞<;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i®=;"vtss_rc ;@;!o;;o;	;
@
;i∞=;"!vtss_clock_ho_stack_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iÕ=;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;iÔ=;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i>;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i<>;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;ig>;".vtss_clock_ho_stack_conf_t        *const ;@;!o;;o;	;
@
;iê>;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;ië?;"vtss_rc ;@;!o;;o;	;
@
;iô?;"$vtss_clock_ho_stack_content_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iπ?;"'const vtss_inst_t                 ;@;!o;;o;	;
@
;i€?;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i	@;"'const vtss_clock_dpll_inst_t      ;@;!o;;o;	;
@
;i+@;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iY@;".vtss_clock_ho_stack_content_t     *const ;@;!o;;o;	;
@
;iÇ@;"	cont;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i,B;"vtss_rc ;@;!o;;o;	;
@
;i4B;"(vtss_clock_dco_frequency_offset_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iXB;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ixB;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i™B;"%const vtss_clock_dpll_inst_t    ;@;!o;;o;	;
@
;i B;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i¸B;"%const i64                       ;@;!o;;o;	;
@
;iC;"offset;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i…D;"vtss_rc ;@;!o;;o;	;
@
;i—D;"(vtss_clock_dco_frequency_offset_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iıD;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iE;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iGE;"%const vtss_clock_dpll_inst_t    ;@;!o;;o;	;
@
;igE;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iôE;",i64                             *const ;@;!o;;o;	;
@
;i¿E;"offset;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i*G;"vtss_rc ;@;!o;;o;	;
@
;i2G;"$vtss_clock_output_filter_bw_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iRG;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;iuG;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i£G;"(const u8                           ;@;!o;;o;	;
@
;i∆G;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i¸G;"(const u32                          ;@;!o;;o;	;
@
;iH;"bw_100uhz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i%I;"vtss_rc ;@;!o;;o;	;
@
;i-I;"$vtss_clock_output_filter_bw_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iMI;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;ipI;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iûI;"(const u8                           ;@;!o;;o;	;
@
;i¡I;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i˜I;")u32                                *;@;!o;;o;	;
@
;iJ;"bw_100uhz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i"K;"vtss_rc ;@;!o;;o;	;
@
;i*K;"+vtss_clock_output_filter_lock_fast_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iQK;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;itK;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i©K;"(const u8                           ;@;!o;;o;	;
@
;iÃK;"clock_output;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i◊L;"vtss_rc ;@;!o;;o;	;
@
;iﬂL;"+vtss_clock_output_filter_lock_fast_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iM;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;i)M;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i^M;"(const u8                           ;@;!o;;o;	;
@
;iÅM;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iæM;")BOOL                               *;@;!o;;o;	;
@
;i‚M;"lock_completed;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i˜N;"vtss_rc ;@;!o;;o;	;
@
;iˇN;"#vtss_clock_output_psl_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iO;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;iAO;"	inst;@;[ ;0{;{	; o;;o;	;
@
;inO;"(const u8                           ;@;!o;;o;	;
@
;iëO;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i∆O;"/const vtss_clock_psl_conf_t        *const ;@;!o;;o;	;
@
;iO;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iQ;"vtss_rc ;@;!o;;o;	;
@
;iQ;"#vtss_clock_output_psl_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i5Q;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;iXQ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÖQ;"(const u8                           ;@;!o;;o;	;
@
;i®Q;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i›Q;"/vtss_clock_psl_conf_t              *const ;@;!o;;o;	;
@
;iR;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;ißS;"vtss_rc ;@;!o;;o;	;
@
;iØS;"!vtss_clock_adj_frequency_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iÃS;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iÏS;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iT;"%const u8                        ;@;!o;;o;	;
@
;i7T;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;ijT;"%const i64                       ;@;!o;;o;	;
@
;iäT;"adj;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i(V;"vtss_rc ;@;!o;;o;	;
@
;i0V;"!vtss_clock_adj_frequency_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iMV;"%const vtss_inst_t               ;@;!o;;o;	;
@
;imV;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iòV;"%const u8                        ;@;!o;;o;	;
@
;i∏V;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÎV;",i64                             *const ;@;!o;;o;	;
@
;iW;"adj;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i°X;"vtss_rc ;@;!o;;o;	;
@
;i©X;"vtss_clock_adj_phase_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i¬X;"%const vtss_inst_t               ;@;!o;;o;	;
@
;i‚X;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i	Y;"%const u8                        ;@;!o;;o;	;
@
;i)Y;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iXY;"%const i32                       ;@;!o;;o;	;
@
;ixY;"adj;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iVZ;"vtss_rc ;@;!o;;o;	;
@
;i^Z;"vtss_clock_adj_phase_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iwZ;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ióZ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iæZ;",BOOL                            *const ;@;!o;;o;	;
@
;iÂZ;"adj_ongoing;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i3\;"vtss_rc ;@;!o;;o;	;
@
;i;\;"vtss_clock_priority_set;@;[ ;0;$[	{;{	; o;;o;	;
@
;iS\;"+const vtss_inst_t                     ;@;!o;;o;	;
@
;iy\;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iü\;"+const vtss_clock_dpll_inst_t          ;@;!o;;o;	;
@
;i≈\;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iÎ\;"+const u8                              ;@;!o;;o;	;
@
;i];"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i>];"2const vtss_clock_priority_selector_t  *const ;@;!o;;o;	;
@
;ik];"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i≤^;"vtss_rc ;@;!o;;o;	;
@
;i∫^;"vtss_clock_priority_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;i“^;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iÚ^;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i_;"%const vtss_clock_dpll_inst_t    ;@;!o;;o;	;
@
;i8_;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i^_;"%const u8                        ;@;!o;;o;	;
@
;i~_;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i´_;",vtss_clock_priority_selector_t  *const ;@;!o;;o;	;
@
;i“_;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i…a;"vtss_rc ;@;!o;;o;	;
@
;i—a;"#vtss_clock_input_frequency_set;@;[ ;0;$[	{;{	; o;;o;	;
@
;ia;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ib;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i=b;"%const u8                        ;@;!o;;o;	;
@
;i]b;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iëb;"%const u32                       ;@;!o;;o;	;
@
;i±b;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;i‚b;"%const BOOL                      ;@;!o;;o;	;
@
;ic;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iØd;"vtss_rc ;@;!o;;o;	;
@
;i∑d;"#vtss_clock_input_frequency_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;i÷d;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iˆd;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i#e;"%const u8                        ;@;!o;;o;	;
@
;iCe;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iwe;",u32                             *const ;@;!o;;o;	;
@
;iûe;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iœe;",BOOL                            *const ;@;!o;;o;	;
@
;iˆe;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iõh;"vtss_rc ;@;!o;;o;	;
@
;i£h;")vtss_clock_input_frequency_ratio_set;@;[ ;0;$[
{;{	; o;;o;	;
@
;i»h;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iËh;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ii;"%const u8                        ;@;!o;;o;	;
@
;i;i;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iui;"%const u32                       ;@;!o;;o;	;
@
;iïi;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iÃi;",const vtss_clock_ratio_t        *const ;@;!o;;o;	;
@
;iÛi;"
ratio;@;[ ;0{;{	; o;;o;	;
@
;i'j;"%const BOOL                      ;@;!o;;o;	;
@
;iGj;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;içl;"vtss_rc ;@;!o;;o;	;
@
;iïl;")vtss_clock_input_frequency_ratio_get;@;[ ;0;$[
{;{	; o;;o;	;
@
;i∫l;"%const vtss_inst_t               ;@;!o;;o;	;
@
;i⁄l;"	inst;@;[ ;0{;{	; o;;o;	;
@
;im;"%const u8                        ;@;!o;;o;	;
@
;i-m;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;igm;",u32                             *const ;@;!o;;o;	;
@
;iém;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;i≈m;",vtss_clock_ratio_t              *const ;@;!o;;o;	;
@
;iÏm;"
ratio;@;[ ;0{;{	; o;;o;	;
@
;i n;",BOOL                            *const ;@;!o;;o;	;
@
;iGn;"use_internal_clock_src;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iór;"vtss_rc ;@;!o;;o;	;
@
;iür;"$vtss_clock_output_frequency_set;@;[ ;0;$[	{;{	; o;;o;	;
@
;iør;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iﬂr;"	inst;@;[ ;0{;{	; o;;o;	;
@
;is;"%const u8                        ;@;!o;;o;	;
@
;i-s;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;ics;"%const u32                       ;@;!o;;o;	;
@
;iÉs;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iµs;"%const u32                       ;@;!o;;o;	;
@
;i’s;"par_freq_khz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iGu;"vtss_rc ;@;!o;;o;	;
@
;iOu;"$vtss_clock_output_frequency_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;iou;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ièu;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iΩu;"%const u8                        ;@;!o;;o;	;
@
;i›u;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iv;",u32                             *const ;@;!o;;o;	;
@
;i:v;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;ilv;",u32                             *const ;@;!o;;o;	;
@
;iìv;"par_freq_khz;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i`{;"vtss_rc ;@;!o;;o;	;
@
;ih{;"*vtss_clock_output_frequency_ratio_set;@;[ ;0;$[
{;{	; o;;o;	;
@
;ié{;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iÆ{;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i‚{;"%const u8                        ;@;!o;;o;	;
@
;i|;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i>|;"%const u32                       ;@;!o;;o;	;
@
;i^|;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iñ|;"%const u32                       ;@;!o;;o;	;
@
;i∂|;"par_freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iÚ|;",const vtss_clock_ratio_t        *const ;@;!o;;o;	;
@
;i};"
ratio;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i;"vtss_rc ;@;!o;;o;	;
@
;i;"*vtss_clock_output_frequency_ratio_get;@;[ ;0;$[
{;{	; o;;o;	;
@
;i6;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iV;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iä;"%const u8                        ;@;!o;;o;	;
@
;i™;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÊ;",u32                             *const ;@;!o;;o;	;
@
;iÄ;"freq_khz;@;[ ;0{;{	; o;;o;	;
@
;iEÄ;",u32                             *const ;@;!o;;o;	;
@
;ilÄ;"par_freq_khz;@;[ ;0{;{	; o;;o;	;
@
;i®Ä;",vtss_clock_ratio_t              *const ;@;!o;;o;	;
@
;iœÄ;"
ratio;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iAÇ;"vtss_rc ;@;!o;;o;	;
@
;iIÇ;" vtss_clock_output_level_set;@;[ ;0;$[{;{	; o;;o;	;
@
;ieÇ;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iÖÇ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iØÇ;"%const u8                        ;@;!o;;o;	;
@
;iœÇ;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÉ;"%const u16                       ;@;!o;;o;	;
@
;i!É;"level_mv;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iSÑ;"vtss_rc ;@;!o;;o;	;
@
;i[Ñ;" vtss_clock_output_level_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iwÑ;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ióÑ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¡Ñ;"%const u8                        ;@;!o;;o;	;
@
;i·Ñ;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÖ;",u16                             *const ;@;!o;;o;	;
@
;i:Ö;"level_mv;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i#Ü;"vtss_rc ;@;!o;;o;	;
@
;i+Ü;"#vtss_clock_output_selector_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iJÜ;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ijÜ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ióÜ;"%const u8                        ;@;!o;;o;	;
@
;i∑Ü;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;iÏÜ;".const vtss_clock_input_selector_t *const ;@;!o;;o;	;
@
;iá;"
input;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i˛á;"vtss_rc ;@;!o;;o;	;
@
;ià;"#vtss_clock_output_selector_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i%à;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iEà;"	inst;@;[ ;0{;{	; o;;o;	;
@
;irà;"%const u8                        ;@;!o;;o;	;
@
;iíà;"clock_output;@;[ ;0{;{	; o;;o;	;
@
;i«à;",vtss_clock_input_selector_t     *const ;@;!o;;o;	;
@
;iÓà;"
input;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iä;"vtss_rc ;@;!o;;o;	;
@
;iä;"$vtss_clock_input_alarm_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;i8ä;"%const vtss_inst_t               ;@;!o;;o;	;
@
;iXä;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÜä;"%const u8                        ;@;!o;;o;	;
@
;i¶ä;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i€ä;",const vtss_clock_input_conf_t   *const ;@;!o;;o;	;
@
;iã;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i#å;"vtss_rc ;@;!o;;o;	;
@
;i+å;"$vtss_clock_input_alarm_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iKå;"%const vtss_inst_t               ;@;!o;;o;	;
@
;ikå;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iôå;"%const u8                        ;@;!o;;o;	;
@
;iπå;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÓå;",vtss_clock_input_conf_t         *const ;@;!o;;o;	;
@
;iç;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i1é;"vtss_rc ;@;!o;;o;	;
@
;i9é;""vtss_clock_input_cfm_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iWé;""const vtss_inst_t            ;@;!o;;o;	;
@
;ité;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i†é;""const u8                     ;@;!o;;o;	;
@
;iΩé;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;ié;")const vtss_clock_cfm_conf_t  *const ;@;!o;;o;	;
@
;iè;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i0ê;"vtss_rc ;@;!o;;o;	;
@
;i8ê;""vtss_clock_input_cfm_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iVê;""const vtss_inst_t            ;@;!o;;o;	;
@
;isê;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iüê;""const u8                     ;@;!o;;o;	;
@
;iºê;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÔê;")vtss_clock_cfm_conf_t        *const ;@;!o;;o;	;
@
;ië;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i1í;"vtss_rc ;@;!o;;o;	;
@
;i9í;""vtss_clock_input_pfm_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iWí;""const vtss_inst_t            ;@;!o;;o;	;
@
;ití;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i†í;""const u8                     ;@;!o;;o;	;
@
;iΩí;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;ií;")const vtss_clock_pfm_conf_t  *const ;@;!o;;o;	;
@
;iì;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i2î;"vtss_rc ;@;!o;;o;	;
@
;i:î;""vtss_clock_input_pfm_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iXî;""const vtss_inst_t            ;@;!o;;o;	;
@
;iuî;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i°î;""const u8                     ;@;!o;;o;	;
@
;iæî;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÒî;")vtss_clock_pfm_conf_t        *const ;@;!o;;o;	;
@
;iï;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i ñ;"vtss_rc ;@;!o;;o;	;
@
;i(ñ;""vtss_clock_input_gst_conf_set;@;[ ;0;$[{;{	; o;;o;	;
@
;iFñ;""const vtss_inst_t            ;@;!o;;o;	;
@
;icñ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;ièñ;""const u8                     ;@;!o;;o;	;
@
;i¨ñ;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iﬂñ;")const vtss_clock_gst_conf_t  *const ;@;!o;;o;	;
@
;ió;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iò;"vtss_rc ;@;!o;;o;	;
@
;iò;""vtss_clock_input_gst_conf_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i5ò;""const vtss_inst_t            ;@;!o;;o;	;
@
;iRò;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i~ò;""const u8                     ;@;!o;;o;	;
@
;iõò;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iŒò;")vtss_clock_gst_conf_t        *const ;@;!o;;o;	;
@
;iÚò;"	conf;@;[ ;0;0{;#{;{	; o;;o;	;
@
;iÈö;"vtss_rc ;@;!o;;o;	;
@
;iÒö;""vtss_clock_selector_state_get;@;[ ;0;$[	{;{	; o;;o;	;
@
;iõ;"#const vtss_inst_t             ;@;!o;;o;	;
@
;i-õ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iYõ;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;iwõ;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i£õ;"*vtss_clock_selector_state_t   *const ;@;!o;;o;	;
@
;i»õ;"selector_state;@;[ ;0{;{	; o;;o;	;
@
;i˛õ;"*u8                            *const ;@;!o;;o;	;
@
;i#ú;"clock_input;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i
ù;"vtss_rc ;@;!o;;o;	;
@
;iù;"vtss_clock_dpll_state_get;@;[ ;0;$[{;{	; o;;o;	;
@
;i,ù;"#const vtss_inst_t             ;@;!o;;o;	;
@
;iJù;"	inst;@;[ ;0{;{	; o;;o;	;
@
;irù;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;iêù;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i∏ù;"*vtss_clock_dpll_state_t       *const ;@;!o;;o;	;
@
;i›ù;"pll_state;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i=ü;"vtss_rc ;@;!o;;o;	;
@
;iEü;"-vtss_clock_ho_stack_frequency_offset_get;@;[ ;0;$[{;{	; o;;o;	;
@
;inü;"#const vtss_inst_t             ;@;!o;;o;	;
@
;iåü;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i√ü;"#const vtss_clock_dpll_inst_t  ;@;!o;;o;	;
@
;i·ü;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i†;"*i64                           *const ;@;!o;;o;	;
@
;i=†;"offset;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i°;"vtss_rc ;@;!o;;o;	;
@
;i&°;"vtss_clock_input_state_get;@;[ ;0;$[{;{	; o;;o;	;
@
;iA°;""const vtss_inst_t            ;@;!o;;o;	;
@
;i^°;"	inst;@;[ ;0{;{	; o;;o;	;
@
;iÜ°;"#const u8                      ;@;!o;;o;	;
@
;i§°;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i”°;"*vtss_clock_input_state_t      *const ;@;!o;;o;	;
@
;i¯°;"input_state;@;[ ;0;0{;o;;o;	;
@
;i,£;"Y#define VTSS_CLOCK_INPUT_LOS_EV     (1 << 0)  /**< External Loss Of Signal event */
;@{;o;;o;	;
@
;iÄ£;"[#define VTSS_CLOCK_INPUT_PFM_EV     (1 << 1)  /**< Precise frequency monitor event */
;@{;o;;o;	;
@
;i÷£;"Z#define VTSS_CLOCK_INPUT_CFM_EV     (1 << 2)  /**< Coarse frequency monitor event */
;@{;o;;o;	;
@
;i+§;"V#define VTSS_CLOCK_INPUT_SCM_EV     (1 << 3)  /**< Single Cycle monitor event */
;@{;o;;o;	;
@
;i|§;"R#define VTSS_CLOCK_INPUT_GST_EV     (1 << 4)  /**< Guard Soak timer event */
;@{;o;;o;	;
@
;i…§;"N#define VTSS_CLOCK_INPUT_LOL_EV     (1 << 5)  /**< Loss of Lock event */
;@{
;o;;o;	;
@
;i•;"typedef;@;o;;o;	;
@
;i•;"	u32 ;@;o;;o;	;
@
;i•;""vtss_clock_input_event_type_t;@;[ ;0{;#{;{	; o;;o;	;
@
;ivß;"vtss_rc ;@;!o;;o;	;
@
;i~ß;" vtss_clock_input_event_poll;@;[ ;0;$[{;{	; o;;o;	;
@
;iöß;"%const vtss_inst_t               ;@;!o;;o;	;
@
;i∫ß;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i‰ß;"%const u8                        ;@;!o;;o;	;
@
;i®;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;i5®;",vtss_clock_input_event_type_t   *const ;@;!o;;o;	;
@
;i\®;"ev_mask;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i≤©;"vtss_rc ;@;!o;;o;	;
@
;i∫©;""vtss_clock_input_event_enable;@;[ ;0;$[	{;{	; o;;o;	;
@
;iÿ©;"+const vtss_inst_t                     ;@;!o;;o;	;
@
;i˛©;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i*™;"+const u8                              ;@;!o;;o;	;
@
;iP™;"clock_input;@;[ ;0{;{	; o;;o;	;
@
;iÉ™;"+const vtss_clock_input_event_type_t   ;@;!o;;o;	;
@
;i©™;"ev_mask;@;[ ;0{;{	; o;;o;	;
@
;iÿ™;"+const BOOL                            ;@;!o;;o;	;
@
;i˛™;"enable;@;[ ;0;0{;o;;o;	;
@
;i‹¨;"^#define VTSS_CLOCK_DPLL_STATE_CHANGE_EV   (1 << 0) /**< State change event in EEC FSM */
;@{
;o;;o;	;
@
;i5≠;"typedef;@;o;;o;	;
@
;i=≠;"	u32 ;@;o;;o;	;
@
;iA≠;"!vtss_clock_dpll_event_type_t;@;[ ;0{;#{;{	; o;;o;	;
@
;içØ;"vtss_rc ;@;!o;;o;	;
@
;iïØ;"vtss_clock_dpll_event_poll;@;[ ;0;$[{;{	; o;;o;	;
@
;i∞Ø;"$const vtss_inst_t              ;@;!o;;o;	;
@
;iœØ;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i¯Ø;"$const vtss_clock_dpll_inst_t   ;@;!o;;o;	;
@
;i∞;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;i@∞;"+vtss_clock_dpll_event_type_t   *const ;@;!o;;o;	;
@
;if∞;"ev_mask;@;[ ;0;0{;#{;{	; o;;o;	;
@
;i¿±;"vtss_rc ;@;!o;;o;	;
@
;i»±;"!vtss_clock_dpll_event_enable;@;[ ;0;$[	{;{	; o;;o;	;
@
;iÂ±;"(const vtss_inst_t                  ;@;!o;;o;	;
@
;i≤;"	inst;@;[ ;0{;{	; o;;o;	;
@
;i3≤;"(const vtss_clock_dpll_inst_t       ;@;!o;;o;	;
@
;iV≤;"	dpll;@;[ ;0{;{	; o;;o;	;
@
;iÅ≤;"(const vtss_clock_dpll_event_type_t ;@;!o;;o;	;
@
;i§≤;"ev_mask;@;[ ;0{;{	; o;;o;	;
@
;i“≤;"(const BOOL                         ;@;!o;;o;	;
@
;iı≤;"enable;@;[ ;0;0{;o;;o;	;
@
;iˇ≤;"#ifdef __cplusplus
;@{;o;;o;	;
@
;i≥;"#endif
;@{;o;;o;	;
@
;i≥;"%#endif /* VTSS_FEATURE_OMEGA */
;@{;o;;o;	;
@
;i;≥;"$#endif // _VTSS_CLOCK_API_H_


;@