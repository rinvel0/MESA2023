// Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
// SPDX-License-Identifier: MIT

:sectnums:

== TS Functional Description.

TS is short for Time Stamping and the API covers a range of functionality that
is related to Time stamping of PTP frames at ingress and egress.

To timestamp packets by the PHY, PHY is initially loaded with required
classifier and clock configurations. When a packet passes through the PHY,
contents of the packet are matched with classifier configuration in the PHY.
If there is a successful match for the given packet, then a timestamp is
generated by the PHY and depending on the configured clock action, the
timestamp will be updated in the packet or saved in the timestamp FIFO of
the PHY.

=== TS Mode Configuration

The API `mepa_ts_mode_set()` can be used to enable the timestamping block to send the
frames to the TS block, disabling the timestamp block will bypass the
TS block.

The API `mepa_ts_mode_get()` allows to know if timestamping block is
enabled/disabled.

=== TS Initialization Configurations

The API `mepa_ts_init_conf_set()` allows initialization of timestamp block by
configuring the reference clock source, clock frequency, Rx time stamp position,
time stamp length, Tx TS FIFO access mode, TSFIFO time stamp size.

The API `mepa_ts_init_conf_get()` can be used to get PHY timestamping unit
initialization parameters

Example pseudo code for sequence::

The following pseudo code provides an example on how MEPA TS can be
initialized.

NOTE: The code is conceptual, and does not include application specific
examples and does not include the needed error handling.

----
///////////////////////////////////////
// Notes: Application must
// 1. initialize PHY
// 2. set base-port appropriately
// 3. know which PHY it is using
// 4. know appropriate PTP configuration for the PHY
// 5. ensure 1PPS pulse on GPIO3
// 6. handle ptp interrupts
///////////////////////////////////////

mepa_rc test_ptp_init(mepa_device_t *dev) {
    if(dev == NULL || dev->drv == NULL) {
        return MEPA_RC_ERROR;
    }
    mepa_driver_t *drv =  dev->drv;
    mepa_ts_init_conf_t ptp_cfg;
    if (drv->mepa_ts->mepa_ts_init_conf_get(drv, &ptp_cfg) != MEPA_RC_OK) {
        return MEPA_RC_ERROR;
    }
    /**
     * Set PHY specific PTP configurations
     * Ex:
     *
     *  #if defined(MEPA_HAS_LAN8814)
     *      ptp_cfg.clk_src = MEPA_TS_CLOCK_SRC_125MHZ_INTERNAL_SYS_PLL;
     *      ptp_cfg.clk_freq = MEPA_TS_CLOCK_FREQ_250M;            //Or MEPA_TS_CLOCK_FREQ_200M
     *      ptp_cfg.rx_ts_len = MEPA_TS_RX_TIMESTAMP_LEN_30BIT;    //ONLY
     *      ptp_cfg.rx_ts_pos = MEPA_TS_RX_TIMESTAMP_POS_IN_PTP;   //ONLY
     *      ptp_cfg.tx_fifo_mode = MEPA_TS_FIFO_MODE_NORMAL;       //ONLY
     *  #endif
     *  #if defined(MEPA_HAS_VTSS)
     *      ptp_cfg.clk_src = MEPA_TS_CLOCK_SRC_INTERNAL;
     *      ptp_cfg.clk_freq = MEPA_TS_CLOCK_FREQ_250M;            //ONLY
     *      ptp_cfg.rx_ts_len = MEPA_TS_RX_TIMESTAMP_LEN_30BIT;
     *      ptp_cfg.rx_ts_pos = MEPA_TS_RX_TIMESTAMP_POS_IN_PTP;
     *      ptp_cfg.tx_fifo_mode = MEPA_TS_FIFO_MODE_NORMAL;
     *  #endif
     *
     *  ptp_cfg.tx_ts_len = MEPA_TS_FIFO_TIMESTAMP_LEN_10BYTE;
     *  ptp_cfg.tx_fifo_spi_conf = 0;
     *  ptp_cfg.auto_clear_ls = 0;
     *  ptp_cfg.tc_op_mode = MEPA_TS_TC_OP_MODE_A;
     *  ptp_cfg.dly_req_recv_10byte_ts = 1;
     *
     */

    //Set the modified configuration
    if (drv->mepa_ts->mepa_ts_init_conf_set(drv, &ptp_cfg) != MEPA_RC_OK) {
        return MEPA_RC_ERROR;
    }

    //Enable TS
    if (drv->mepa_ts->mepa_ts_mode_set (dev, TRUE) != MEPA_RC_OK) {
        return MEPA_RC_ERROR;
    }

    //Enable TS Events
    if (drv->mepa_ts->mepa_ts_event_set (dev, 1, MEPA_TS_EGR_TIMESTAMP_CAPTURED) != MEPA_RC_OK) {
        return MEPA_RC_ERROR;
    }

    //Install FIFO cbk
    mepa_ts_fifo_read_t ts_cbk = ts_handler;
    if (drv->mepa_ts->mepa_ts_fifo_read_install (dev, ts_cbk) != MEPA_RC_OK) {
        return MEPA_RC_ERROR;
    }

    return MEPA_RC_OK;
}
----

=== Ingress/Egress PTP Packet Classifier Configurations

These APIs are used to configure Ingress/Egress PTP classifier configurations
`mepa_ts_classifier_t` which includes:

* Packet Encapsulation Type - `MEPA_TS_ENCAP_ETH_PTP` (PTP over ethernet),
`MEPA_TS_ENCAP_ETH_IP_PTP` (PTP over UDP over IP over ethernet) supports
ipv4 and ipv6 frames.
* Classifier parameters specific to ethernet header can be configured in
`mepa_ts_classifier_eth_t` structure and IP header specific parameters can be
configured using `mepa_ts_classifier_ip_t` structure.

`mepa_ts_rx_classifier_conf_get()` and `mepa_ts_rx_classifier_conf_set` APIs
can be used to get/set ingress classifier configurations.

`mepa_ts_tx_classifier_conf_get()` and `mepa_ts_tx_classifier_conf_set` APIs
can be used to get/set egress classifier configurations.

Example pseudo code for sequence::

The following pseudo code provides an example on how MEPA TS classifier
configuration can be done.

NOTE: The code is conceptual, and does not include application specific
examples and does not include the needed error handling.

----
mepa_rc test_prp_classifier_cfg(mepa_device_t *dev, bool const is_baseport) {
    if(dev == NULL || dev->drv == NULL) {
        return MEPA_RC_ERROR;
    }
    mepa_driver_t *drv =  dev->drv;
    mepa_ts_classifier_t cls_cf;
    uint16_t flow_id = 0, clk_id = 0;

    // In vsc-phys like vsc8574, the timestamping block is shared between two ports.
    // So, the base port uses flow-id '0', clock-id '0'. Alternate port uses flow-id '8', clock-id '2'.
    if (is_baseport) {
        flow_id = 8;
        clk_id = 2;
    }
    // Get the classifier config
    if (drv->mepa_ts->mepa_ts_rx_classifier_conf_get(dev, flow_id, &cls_cf) == MEPA_RC_OK) {
        cls_cf.pkt_encap_type = MEPA_TS_ENCAP_ETH_PTP; //Or MEPA_TS_ENCAP_ETH_IP_PTP
        cls_cf.enable = TRUE;
        cls_cf.eth_class_conf.mac_match_mode = MEPA_TS_ETH_ADDR_MATCH_ANY;
        cls_cf.eth_class_conf.mac_match_select = MEPA_TS_ETH_MATCH_DEST_ADDR;
        cls_cf.eth_class_conf.vlan_check = FALSE;
        cls_cf.eth_class_conf.vlan_conf.pbb_en = FALSE;
        cls_cf.eth_class_conf.vlan_conf.num_tag = 0;
        cls_cf.eth_class_conf.vlan_conf.etype = 0x88f7;
        if (cls_cf.pkt_encap_type == MEPA_TS_ENCAP_ETH_IP_PTP) {
            cls_cf.eth_class_conf.vlan_conf.etype = 0x800;
            cls_cf.ip_class_conf.udp_dport_en = TRUE;
            cls_cf.ip_class_conf.udp_dport    = PTP_EVENT_PORT;
            cls_cf.ip_class_conf.udp_sport_en = FALSE;
            cls_cf.ip_class_conf.udp_sport    = 0;
            cls_cf.ip_class_conf.ip_ver = MEPA_TS_IP_VER_4;
            cls_cf.ip_class_conf.ip_match_mode = MEPA_TS_IP_MATCH_DEST;
            memset(&cls_cf.ip_class_conf.ip_addr.ipv4.addr, 0, sizeof(cls_cf.ip_class_conf.ip_addr.ipv4.addr));
            memset(&cls_cf.ip_class_conf.ip_addr.ipv4.mask, 0, sizeof(cls_cf.ip_class_conf.ip_addr.ipv4.mask));
        }

        //
        // Anything else?
        //

        // Configure ingress classifier
        if (drv->mepa_ts->mepa_ts_rx_classifier_conf_set(dev, flow_id, &cls_cf) != MEPA_RC_OK) {
            return MEPA_RC_ERROR;
        }
        // Configure egress classifier
        if (drv->mepa_ts->mepa_ts_tx_classifier_conf_set(dev, flow_id, &cls_cf) != MEPA_RC_OK) {
            return MEPA_RC_ERROR;
        }
    }
    return MEPA_RC_OK;
}
----

=== Ingress/Egress PTP Clock Configurations

These APIs can be used to configure Ingress/Egress PTP Clock configurations
`mepa_ts_ptp_clock_conf_t` which includes:

* PTP Header Classifier(`mepa_ts_classifier_ptp_t`) - version, minor version,
domain, sdoid.
* Clock Mode(`mepa_ts_ptp_clock_mode_t`) - can be configured to boundary clock
(BC1STEP, BC2STEP) or transparent clock(TC1STEP, TC2STEP).
* Delay Measurement Method(`mepa_ts_ptp_delaym_type_t`) - can be configured to
Peer-to-Peer(P2P) or End-to-End(E2E) delay measurement method.
* Correction field update for BC1STEP.

The APIs `mepa_ts_rx_clock_conf_get()` and `mepa_ts_rx_clock_conf_set()` can
be used to get/set ingress clock configurations.

The APIs `mepa_ts_tx_clock_conf_get()` and `mepa_ts_tx_clock_conf_set()` can
be used to get/set egress clock configurations.

In BC1STEP mode on egress side, 10-byte timestamp will be inserted into the
origin timestamp field.

In BC2STEP or TC2STEP modes on egress side, 10-byte timestamp will be saved
into FIFO and it has to be read by application by enabling timestamp events.

In TC1STEP mode on egress side, correction field will be updated in the packet.

In all the modes on ingress side, 4-byte nano second part of timestamp will be
updated in the reserved field of the PTP header.
Currently, it is also possible to append it to PTP frame for VSC8574 phys.

Example pseudo code for sequence::

The following pseudo code provides an example on how MEPA TS clock
action can be configured.

NOTE: The code is conceptual, and does not include application specific
examples and does not include the needed error handling.

----
mepa_rc test_prp_clk_cfg(mepa_device_t *dev, bool const is_baseport) {
    if(dev == NULL || dev->drv == NULL) {
        return MEPA_RC_ERROR;
    }
    mepa_driver_t *drv =  dev->drv;
    mepa_ts_ptp_clock_conf_t clk_cf;
    uint16_t flow_id = 0, clk_id = 0;

    // In vsc-phys like vsc8574, the timestamping block is shared between two ports.
    // So, the base port uses flow-id '0', clock-id '0'. Alternate port uses flow-id '8', clock-id '2'.
    if (is_baseport) {
        flow_id = 8;
        clk_id = 2;
    }
    // Get the default clock action
    if (drv->mepa_ts->mepa_ts_tx_clock_conf_get(dev, clk_id, &clk_cf) == MEPA_RC_OK) {
        clk_cf.pkt_encap_type = MEPA_TS_ENCAP_ETH_PTP; //Or MEPA_TS_ENCAP_ETH_IP_PTP
        clk_cf.enable = TRUE;
        clk_cf.clock_id = clk_id;
        clk_cf.clk_mode = MEPA_TS_PTP_CLOCK_MODE_BC1STEP;
        clk_cf.delaym_type = MEPA_TS_PTP_DELAYM_E2E;
        clk_cf.ptp_class_conf.version.lower = 2;
        clk_cf.ptp_class_conf.version.upper = 2;
        clk_cf.ptp_class_conf.minor_version.lower = 0;
        clk_cf.ptp_class_conf.minor_version.upper = 1;

        // Configure ingress clock action
        if (drv->mepa_ts->mepa_ts_rx_clock_conf_set(dev, clk_id, &clk_cf) != MEPA_RC_OK) {
            return MEPA_RC_ERROR;
        }

        // Configure egress clock action
        if (drv->mepa_ts->mepa_ts_tx_clock_conf_set(dev, clk_id, &clk_cf) != MEPA_RC_OK) {
            return MEPA_RC_ERROR;
        }
        return MEPA_RC_OK;
    }
    return MEPA_RC_ERROR;
}
----

=== Other TS Clock Configurations

The API `mepa_ts_clock_rateadj_set()` can be used to set LTC(Local Time Counter)
frequency/Rate adjust value.

The API `mepa_ts_clock_rateadj_get()` allows to get LTC(Local Time Counter)
frequency/Rate adjust value.

The API `mepa_ts_clock_adj1ns()` can be used to adjust LTC with one nanaosecond.

The APIs `mepa_ts_delay_asymmetry_get()` and `mepa_ts_delay_asymmetry_set()`
can be used to get/set clock delay asymmetry.

The APIs `mepa_ts_path_delay_get()` and `mepa_ts_path_delay_set()` can be used
to get/set clock path delay.

Note:: In peer to peer transparent clock, the path delay value set will be used
for updating correction field on egress side.

The APIs `mepa_ts_egress_latency_get` and `mepa_ts_egress_latency_set` can be
used to get/set egress clock latency.

The APIs `mepa_ts_ingress_latency_get()` and `mepa_ts_ingress_latency_set()` can
be used ro get/set ingress clock latency.

=== TS LTC Configurations

Application can use following APIs to load/save PHY LTC values when 1PPS is
received. 1PPS on a HW pin is board specific which needs to be handled by
application. Upon 1PPS rising edge, either TS registers can be loaded/read
depending on the `mepa_ts_ltc_ls_en()` option used.
LOAD to update PHY LTC from TS registers upon 1PPS pulse.
SAVE to read PHY LTC into TS registers upon 1PPS pulse.
This has to be continuous process by application depending on the requirement.

==== Loading time into PHY LTC

Initially, before 1PPS signal is received, `mepa_ts_ltc_set()` must be called
to set the required time value into TS register and set the load operation bit
in register.
Once a 1PPS pulse is received, immediately PHY will load time into LTC
using API `mepa_ts_ltc_ls_en()` with option `MEPA_TS_CMD_LOAD`. At this point,
load operation bit which loads time should be cleared.

Sequence is as below:

* `mepa_ts_ltc_set()` to load TS registers.
* Wait for 1PPS pulse on GPIO3.
* Up on 1PPS, `mepa_ts_ltc_ls_en()` with `MEPA_TS_CMD_LOAD` to update the PHY LTC from
TS registers.

==== Saving time from PHY LTC

Application need to call `mepa_ts_ltc_ls_en()` with option `MEPA_TS_CMD_SAVE`.
Once a 1PPS pulse is received, PHY LTC value will be saved into local
registers and the API `mepa_ts_ltc_get()` can be used to read the saved time.

Sequence is as below:

* `mepa_ts_ltc_ls_en()` with `MEPA_TS_CMD_SAVE`.
* Wait for 1PPS pulse on GPIO3.
* `mepa_ts_ltc_get()` to read the saved time. SAVE bit will be cleared.

When 1PPS pulse is received, we can either perform LOAD/SAVE operation.
Load operation can be performed when desired for protocol time adjustment and
so need not be a continuous operation. Most of the times, save operation will
be used to read time from the PHY and check if it is in synchronization with
system time or not.

=== Reading TS from FIFO

TS FIFO has two interfaces: SPI and MDIO/Parallel interface to access the
TX timestamps. FIFO supports maximum of 8 TS entries.

* SPI Interface - For PHYs such as the LAN8814, an alternate method of
providing timestamping event information is provided. Rather than placing
the event in a FIFO for the host to retrieve, the PHY will asynchronously
output the event over a SPI bus. The PHY is in total control of this bus,
providing the clock and data signals. External logic must be added to the
design using this method to capture the data and provide it to the host.
// Feature yet to be supported.

* MDIO or Parallel Interface - Timestamps are gathered into a FIFO,
application can register a callback function to read the FIFO.

Note:: MDIO or Parallel interface is disabled if timestamp mode is set to SPI.

For MDIO access, the application has to install the callback function which is
called to push timestamp from the HW TXFIFO to the application.
The application can read a timestamp for a specific signature.

The following APIs will be used to read/empty the TSFIFO timestamp:

* Callback Register - `mepa_ts_fifo_read_install()`
* Read timestamp FIFO entry - `mepa_ts_fifo_read()`
* Empty timestamp FIFO entry - `mepa_ts_fifo_empty()`

Install callback to read data (signature + timestamp) from TX TSFIFO.

=== TS Reset

The API `mepa_ts_reset()` allows to reset the timestamping block.

=== TS Statistics

The API `mepa_ts_stats_get()` allows to get timestamping statistics which includes
`mepa_ts_stats_t` parameters.

=== TS PPS Configurations

PPS configuration APIs are used for configuring required parameters for
1pps(pulse per second) signal. When the nano-second part of the LTC crosses
zero, 1pps signal is generated. Using these APIs, it is possible to configure
the width of the 1pps pulse and the offset from the nano-second rollover point
at which the pulse is started.

The API `mepa_ts_pps_conf_get()` allows to get configured offset
`mepa_ts_pps_conf_t` for PPS generation.

The API `mepa_ts_pps_conf_set()` can be used to set offset for the PPS
generation using `mepa_ts_pps_conf_t` structure.

=== PHY TS Event Interrupts

These APIs allows setting PHY TS interrupt mask, reading current masked
interrupts, polling for given interrupts.

Interrupt event APIs are particularly useful for 2-step clocks where the
timestamp will be saved to FIFO. As soon as a timestamp is saved to FIFO,
`MEPA_TS_EGR_TIMESTAMP_CAPTURED` event will be triggered. Application has
to check for this event for reading timestamp from the FIFO.

The API `mepa_ts_event_set()` allows to enable event generation for a specific
event type or group of events using `mepa_ts_event_t` structure.

The API `mepa_ts_event_get()` allows to get status of currently enabled events
of a given PHY, provided event mask.

The API `mepa_ts_event_poll()` helps to poll and see if a interrupt/event
is generated or not.

=== MEPA TS functions.
`mepa_ts_init_conf_set()` +
`mepa_ts_init_conf_get()` +
`mepa_ts_mode_set()` +
`mepa_ts_mode_get()` +
`mepa_ts_ltc_ls_en()` +
`mepa_ts_ltc_get()` +
`mepa_ts_ltc_set()` +
`mepa_ts_reset()` +
`mepa_ts_stats_get()` +
`mepa_ts_clock_rateadj_get()` +
`mepa_ts_clock_rateadj_set()` +
`mepa_ts_clock_adj1ns()` +
`mepa_ts_pps_conf_get()` +
`mepa_ts_pps_conf_set()` +
`mepa_ts_rx_classifier_conf_get()` +
`mepa_ts_tx_classifier_conf_get()` +
`mepa_ts_rx_classifier_conf_set()` +
`mepa_ts_tx_classifier_conf_set()` +
`mepa_ts_rx_clock_conf_get()` +
`mepa_ts_tx_clock_conf_get()` +
`mepa_ts_rx_clock_conf_set()` +
`mepa_ts_tx_clock_conf_set()` +
`mepa_ts_event_set()` +
`mepa_ts_event_get()` +
`mepa_ts_event_poll()` +
`mepa_ts_fifo_read_install()` +
`mepa_ts_fifo_read()` +
`mepa_ts_fifo_empty()` +
`mepa_ts_test_config()`
